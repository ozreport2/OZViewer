/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var OZSealRecognition;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/OZCardPreview.js":
/*!******************************!*\
  !*** ./src/OZCardPreview.js ***!
  \******************************/
/***/ (() => {

eval("const OZCardPreview = window[\"OZCardPreview\"] = function(nDPI) {\r\n    const _this = OZCardPreview.prototype;\r\n    \r\n    this.m_myUI = null;\r\n\r\n    this.m_pGuideRectOverlay = null;\r\n    this.m_pGuideMaskOverlay = null;\r\n\r\n    this.m_nDPI = nDPI;\r\n    this.m_bForceCapture = false;\r\n    this.m_bShowMaskGuide = true;\r\n    \r\n    this.m_nCheckSize = 0;\r\n    this.m_nScanWidth = 0;\r\n    this.m_nScanHeight = 0;\r\n    \r\n    this.m_pPaperInfo = null;\r\n    this.m_pScanSP = null;\r\n    this.m_pScanArea = null;\r\n    this.m_pScanAreaCenterPoint = null;\r\n\r\n    this.m_constraints = {};\r\n    this.m_videoTracks = null;\r\n    this.m_pCanvasUpdateFunc = null;\r\n\r\n    this.m_pRecognitionPack = null;\r\n    this.m_bFacingMode = false;\r\n    this.m_pVideo = null;\r\n    this.m_pTmpCanvas = null;\r\n    this.m_pTargetMat = null;\r\n    this.m_pEndCallback = null;\r\n    this.m_nContentsWidth = 0;\r\n    this.m_nContentsHeight = 0;\r\n    this.m_nVideoMinWidth = 1280;\r\n    this.m_nVideoMinHeight = 720;\r\n\r\n    this.m_pFile = null;\r\n    this.m_strMimeType = \"\";\r\n\r\n    /**\r\n     * 메모리 해제용 함수\r\n     */\r\n    _this[\"Dispose\"] = function() {\r\n        this.stopPreview();\r\n\r\n        if (this.m_myUI) {\r\n            this.m_pVideo = null;\r\n            this.m_pTmpCanvas = null;\r\n            $(this.m_myUI).remove();\r\n            this.m_myUI = null;\r\n        }\r\n        if (this.m_pRecognitionPack) {\r\n            this.m_pRecognitionPack.dispose();\r\n            this.m_pRecognitionPack = null;\r\n        }\r\n        if (this.m_pTargetMat) {\r\n            this.m_pTargetMat[\"delete\"]();\r\n            this.m_pTargetMat = null;\r\n        }\r\n        this.m_nDPI = null;\r\n        this.m_constraints = null;\r\n        this.m_pEndCallback = null;\r\n\r\n        this.m_pPaperInfo = null;\r\n        this.m_pScanSP = null;\r\n        this.m_pScanArea = null;\r\n        this.m_pScanAreaCenterPoint = null;\r\n    };\r\n\r\n    _this.InitConstraints = function() {\r\n        const pConstraints = {};\r\n        pConstraints[\"audio\"] = false;\r\n        pConstraints[\"video\"] = {};\r\n\r\n        //var bFacingMode = document.getElementById(\"btn_facingmode\").checked;\r\n        //pConstraints[\"video\"][\"facingMode\"] = (this.m_bFacingMode ? { [\"exact\"]: \"user\" } : { [\"exact\"]: \"environment\" });\r\n        let facingMode = {};\r\n        facingMode[\"exact\"] = \"environment\";\r\n        if (this.m_bFacingMode) {\r\n            facingMode = \"user\";\r\n        }\r\n        pConstraints[\"video\"][\"facingMode\"] = facingMode;\r\n\r\n        let width = {};\r\n        let height = {};\r\n\r\n        width[\"min\"] = this.m_nVideoMinWidth;\r\n        height[\"min\"] = this.m_nVideoMinHeight;\r\n        \r\n        width[\"ideal\"] = this.m_nContentsWidth;\r\n        height[\"ideal\"] = this.m_nContentsHeight;\r\n\r\n        if (window.innerWidth > window.innerHeight) {\r\n            pConstraints[\"video\"].width = width;\r\n            pConstraints[\"video\"].height = height;\r\n        } else {\r\n            pConstraints[\"video\"].width = height;\r\n            pConstraints[\"video\"].height = width;\r\n        }\r\n\r\n        pConstraints[\"video\"][\"advanced\"] = [{ \"focusMode\": \"continuous\" }];\r\n        this.m_constraints = pConstraints;\r\n    };\r\n\r\n    _this.SetMediaStream = function() {\r\n        this.InitConstraints();\r\n\r\n        const oThis = this;\r\n        navigator.mediaDevices.getUserMedia(this.m_constraints)\r\n        .then(function(mediaStream) {\r\n            // Older browsers may not have srcObject\r\n            if (\"srcObject\" in oThis.m_pVideo) {\r\n                oThis.m_pVideo.srcObject = mediaStream;\r\n            } else {\r\n                var vendorURL = window.URL || window.webkitURL;\r\n                // Avoid using this in new browsers, as it is going away.\r\n                oThis.m_pVideo.src = vendorURL.createObjectURL(mediaStream);\r\n            }\r\n            oThis.m_videoTracks = mediaStream.getVideoTracks();\r\n            oThis.m_pVideo.onloadedmetadata = function(e) {\r\n                oThis.m_pVideo.play();\r\n                oThis.m_pVideo.width = oThis.m_pVideo.videoWidth;\r\n                oThis.m_pVideo.height = oThis.m_pVideo.videoHeight;\r\n                oThis.StartFindArea();\r\n            };\r\n        }).catch(function(err) {\r\n            if (oThis.m_bFacingMode) {\r\n                OZRecognitionPack[\"trace\"](err.name + \": \" + err.message);\r\n                oThis[\"FindAreaFromFile\"](oThis.m_pEndCallback);\r\n            } else {\r\n                oThis.m_bFacingMode = true;\r\n                oThis.SetMediaStream();\r\n            }\r\n        });\r\n    };\r\n\r\n    _this.StartFindArea = function() {\r\n        if (this.m_videoTracks) {\r\n            var currentTrack = this.m_videoTracks[0];\r\n            if (currentTrack && currentTrack.applyConstraints) {\r\n                var bUpdate;\r\n                if (this.m_pVideo.paused || this.m_pVideo.ended) {\r\n                    // srcObject ? active state check\r\n                    bUpdate = false;\r\n                } else {\r\n                    bUpdate = true;\r\n                }\r\n                if (bUpdate) {\r\n                    const nFPS = 700;\r\n                    const video = this.m_pVideo;\r\n                    const pHiddenCanvas = this.m_pTmpCanvas;\r\n                    const pCtx = this.m_pTmpCanvas.getContext(\"2d\");\r\n\r\n                    try {\r\n                        this.m_pRecognitionPack = new OZRecognitionPack(OZRecognitionPack.MODE_ID);\r\n                        this.m_pRecognitionPack.SetResultMimeType(this.m_strMimeType);\r\n                        \r\n                        const nDPI = this.m_nDPI;\r\n                        \r\n                        const tmpCanvasRect = this.getTmpCanvasRect(video.videoWidth, video.videoHeight);\r\n                        const sx = tmpCanvasRect.Left;\r\n                        const sy = tmpCanvasRect.Top;\r\n                        pHiddenCanvas.width = tmpCanvasRect.Width;\r\n                        pHiddenCanvas.height = tmpCanvasRect.Height;\r\n                        this.setScanArea(pHiddenCanvas.width, pHiddenCanvas.height);\r\n                        \r\n                        const targetMatWidth = parseInt(this.m_pScanEP.x - this.m_pScanSP.x);\r\n                        const targetMatHeight = parseInt(this.m_pScanEP.y - this.m_pScanSP.y);\r\n                        this.m_pTargetMat = new cv[\"Mat\"](targetMatHeight, targetMatWidth, cv[\"CV_8UC4\"]);\r\n\r\n                        this.drawGuideRect(1);\r\n\r\n                        const oThis = this;\r\n                        this.m_pCanvasUpdateFunc = setInterval(function() {\r\n                            pCtx.drawImage(video, sx, sy, pHiddenCanvas.width, pHiddenCanvas.height,\r\n                                0, 0, pHiddenCanvas.width, pHiddenCanvas.height);\r\n                            oThis.m_pTargetMat.data.set(pCtx.getImageData(parseInt(oThis.m_pScanSP.x), parseInt(oThis.m_pScanSP.y), targetMatWidth, targetMatHeight).data);\r\n                            \r\n                            try {\r\n                                if (oThis.m_pRecognitionPack.FindArea(nDPI, pHiddenCanvas, oThis.m_pTargetMat, oThis.m_pPaperInfo, \r\n                                        oThis.m_pScanArea, oThis.m_pScanAreaCenterPoint, oThis.m_nScanWidth, oThis.m_nScanHeight, \r\n                                        true, oThis.m_bForceCapture) == 999) {\r\n                                    oThis.drawGuideRect(2);\r\n    \r\n                                    oThis.m_pTargetMat.delete();\r\n                                    oThis.m_pTargetMat = null;\r\n                                    clearInterval(oThis.m_pCanvasUpdateFunc);\r\n                                    // 촬영 후 0.5초 뒤 콜백함수 호출\r\n                                    setTimeout(function() {\r\n                                        oThis.stopPreview();\r\n                                        oThis.m_pEndCallback(true);\r\n                                        $(oThis.m_myUI)[\"css\"](\"display\", \"none\");\r\n                                    }, 500);\r\n                                    //return;\r\n                                }\r\n                            } catch(e) {\r\n                                oThis.stopPreview();\r\n                                OZRecognitionPack[\"trace\"](e.name + \": \" + e.message);\r\n                                if (oThis.m_pTargetMat) {\r\n                                    oThis.m_pTargetMat.delete();\r\n                                    oThis.m_pTargetMat = null;\r\n                                }     \r\n                            }\r\n                        }, nFPS); // setInterval\r\n                    } catch (err) {\r\n                        OZRecognitionPack[\"trace\"](err.name + \": \" + err.message);\r\n                        if (this.m_pTargetMat) {\r\n                            this.m_pTargetMat.delete();\r\n                            this.m_pTargetMat = null;\r\n                        }\r\n                    } \r\n                }\r\n            }\r\n        } else {\r\n            OZRecognitionPack[\"trace\"](\"!videoTracks\");\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 미리보기를 시작시키는 함수(재시작할 때도 사용가능)\r\n     */\r\n    _this[\"StartCapture\"] = function() {\r\n        this.stopPreview();\r\n        this.SetMediaStream();\r\n    };\r\n\r\n    _this.stopPreview = function() {\r\n        if (this.m_pCanvasUpdateFunc) {\r\n            clearInterval(this.m_pCanvasUpdateFunc);\r\n            this.m_pCanvasUpdateFunc = null;\r\n        }\r\n        if (this.m_videoTracks) {\r\n            this.m_videoTracks.forEach(function(track) { track.stop() });\r\n            this.m_videoTracks = null;\r\n        }\r\n        if (this.m_pVideo) {\r\n            if (\"srcObject\" in this.m_pVideo) {\r\n                this.m_pVideo.srcObject = null;\r\n            } else {\r\n                this.m_pVideo.src = null;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * CardPreviewDiv를 붙이는 함수\r\n     * @param target PreviewDiv가 붙을 엘리먼트\r\n     * @param nContentsWidth 미리보기 너비\r\n     * @param nContentsHeight 미리보기 높이\r\n     * @param pEndCallback 인감 스캔 후 호출될 콜백\r\n     * @return CardPreviewDiv 생성된 CardPreviewDiv\r\n     */\r\n    _this[\"ShowPreviewOn\"] = function(target, nContentsWidth, nContentsHeight, pEndCallback) {\r\n        this.m_pEndCallback = pEndCallback;\r\n\r\n        this.m_myUI = document.createElement(\"div\");\r\n        $(this.m_myUI)[\"css\"](\"width\", nContentsWidth);\r\n        $(this.m_myUI)[\"css\"](\"height\", nContentsHeight);\r\n        $(this.m_myUI)[\"css\"](\"display\", \"flex\");\r\n\r\n        let margin = 0;\r\n        if (nContentsWidth > nContentsHeight) {\r\n            margin = nContentsWidth * 0.05;\r\n        } else {\r\n            margin = nContentsHeight * 0.05;\r\n        }\r\n\r\n        this.m_nContentsWidth = nContentsWidth - margin;;\r\n        this.m_nContentsHeight = nContentsHeight - margin;;\r\n\r\n        const pDivPreview = document.createElement(\"div\");\r\n        $(pDivPreview)[\"css\"](\"border\", \"1px solid black\")\r\n            [\"css\"](\"overflow\", \"hidden\")\r\n            [\"css\"](\"margin\", \"auto\")\r\n            [\"css\"](\"background-color\", \"black\");\r\n\r\n        const pVideoPreview = document.createElement(\"video\");\r\n        $(pVideoPreview).attr(\"playsinline\",  \"\");\r\n        $(pVideoPreview)[\"css\"](\"display\", \"block\")\r\n            [\"css\"](\"object-fit\", \"cover\")\r\n            [\"css\"](\"margin\", \"auto\")\r\n            [\"css\"](\"width\", this.m_nContentsWidth)\r\n            [\"css\"](\"height\", this.m_nContentsHeight);\r\n\r\n        this.m_pVideo = pVideoPreview;\r\n        const pCanvasOutput = document.createElement(\"canvas\");\r\n        $(pCanvasOutput)[\"css\"](\"margin\", \"auto\")\r\n            [\"css\"](\"display\", \"none\");\r\n\r\n        this.m_pGuideRectOverlay = document.createElement(\"canvas\");\r\n        $(this.m_pGuideRectOverlay)[\"css\"](\"margin\", \"auto\")\r\n            [\"css\"](\"position\", \"absolute\")\r\n            [\"css\"](\"width\", this.m_nContentsWidth)\r\n            [\"css\"](\"height\", this.m_nContentsHeight);\r\n\r\n        this.m_pGuideMaskOverlay = document.createElement(\"canvas\");\r\n        $(this.m_pGuideMaskOverlay)[\"css\"](\"margin\", \"auto\")\r\n            [\"css\"](\"position\", \"absolute\")\r\n            [\"css\"](\"width\", this.m_nContentsWidth)\r\n            [\"css\"](\"height\", this.m_nContentsHeight);\r\n\r\n        $(pDivPreview).append(this.m_pGuideRectOverlay)\r\n            .append(this.m_pGuideMaskOverlay)\r\n            .append(pVideoPreview)\r\n            .append(pCanvasOutput);\r\n        $(this.m_myUI).append(pDivPreview);\r\n\r\n        this.m_pTmpCanvas = pCanvasOutput;\r\n        $(target).append(this.m_myUI);\r\n        return this.m_myUI;\r\n    };\r\n\r\n    _this.getTmpCanvasRect = function(videoWidth, videoHeight) {\r\n        const pRect = {};\r\n\t\tpRect.Left = 0;\r\n\t\tpRect.Top = 0;\r\n\t\tpRect.Width = videoWidth;\r\n\t\tpRect.Height = videoHeight;\r\n\t\tif (pRect.Width / this.m_nContentsWidth > pRect.Height / this.m_nContentsHeight) {\r\n\t\t\tpRect.Width = this.m_nContentsWidth * pRect.Height / this.m_nContentsHeight;\r\n\t\t\tpRect.Left += (videoWidth - pRect.Width) / 2;\r\n\t\t} else {\r\n\t\t\tpRect.Height = this.m_nContentsHeight * pRect.Width / this.m_nContentsWidth;\r\n\t\t\tpRect.Top += (videoHeight - pRect.Height) / 2;\r\n\t\t}\r\n\t\treturn pRect;\r\n    };\r\n\r\n    _this.setScanArea = function(nWidth, nHeight) {\r\n        let nPreviewWidth = nWidth;\r\n        let nPreviewHeight = nHeight;\r\n        this.m_nCheckSize = parseInt(Math.min(nPreviewWidth, nPreviewHeight) * 0.3);\r\n        const cardRatio = this.m_pPaperInfo.sizeHeight / this.m_pPaperInfo.sizeWidth;\r\n        const maxHeight = nPreviewHeight - this.m_nCheckSize;\r\n        const maxWidth = nPreviewWidth - this.m_nCheckSize;\r\n\r\n        let nCardHeight = maxHeight;\r\n        let nCardWidth = maxHeight / cardRatio;\r\n\r\n        if (nCardWidth > maxWidth) {\r\n            nCardWidth = maxWidth;\r\n            nCardHeight = maxWidth * cardRatio;\r\n        }\r\n\r\n        this.m_nScanWidth = nCardWidth + this.m_nCheckSize;\r\n        this.m_nScanHeight = nCardHeight + this.m_nCheckSize;\r\n    \r\n        this.m_pScanSP = new cv[\"Point\"]((nPreviewWidth - this.m_nScanWidth) / 2,  (nPreviewHeight - this.m_nScanHeight) / 2);\r\n        this.m_pScanEP = new cv[\"Point\"](this.m_pScanSP.x + this.m_nScanWidth, this.m_pScanSP.y + this.m_nScanHeight);\r\n\r\n        this.m_pScanArea = [];\r\n        this.m_pScanArea.push(new cv[\"Rect\"](0, 0, this.m_nCheckSize, this.m_nCheckSize));\r\n        this.m_pScanArea.push(new cv[\"Rect\"](this.m_nScanWidth - this.m_nCheckSize, 0, this.m_nCheckSize, this.m_nCheckSize));\r\n        this.m_pScanArea.push(new cv[\"Rect\"](this.m_nScanWidth - this.m_nCheckSize, this.m_nScanHeight - this.m_nCheckSize, this.m_nCheckSize, this.m_nCheckSize));\r\n        this.m_pScanArea.push(new cv[\"Rect\"](0, this.m_nScanHeight - this.m_nCheckSize, this.m_nCheckSize, this.m_nCheckSize));\r\n\r\n        this.m_pScanAreaCenterPoint = this.getScanAreaCenterPoint(this.m_nCheckSize/2, this.m_nScanWidth, this.m_nScanHeight)\r\n    };\r\n\r\n    _this.getScanAreaCenterPoint = function(nHalfCheckSize, nScanWidth, nScanHeight) {\r\n        pScanAreaCenterPoint = [];\r\n        pScanAreaCenterPoint.push(new cv[\"Point\"](nHalfCheckSize, nHalfCheckSize));\r\n        pScanAreaCenterPoint.push(new cv[\"Point\"](nScanWidth - (nHalfCheckSize), (nHalfCheckSize)));\r\n        pScanAreaCenterPoint.push(new cv[\"Point\"](nScanWidth - (nHalfCheckSize), nScanHeight - (nHalfCheckSize)));\r\n        pScanAreaCenterPoint.push(new cv[\"Point\"](nHalfCheckSize, (nScanHeight - nHalfCheckSize)));\r\n\r\n        return pScanAreaCenterPoint;\r\n    };\r\n\r\n    _this.drawGuideRect = function(nState) {\r\n        let pCtx = this.m_pGuideRectOverlay.getContext(\"2d\");\r\n        pCtx.clearRect(0, 0, this.m_pGuideRectOverlay.width, this.m_pGuideRectOverlay.height);\r\n\r\n        pCtx.beginPath();\r\n        if (nState == 0) {\r\n            pCtx.strokeStyle = \"rgb(255, 255, 255)\";\r\n        } else if (nState == 1) {\r\n            pCtx.strokeStyle = \"rgb(255, 178, 150)\";\r\n        } else if (nState == 2) {\r\n            pCtx.strokeStyle = \"rgb(254, 100, 46)\";\r\n        } else {\r\n            pCtx.strokeStyle = \"rgb(255, 255, 255)\";\r\n        }\r\n        pCtx.lineWidth = 1.5;\r\n\r\n        let nPreviewWidth = this.m_pGuideRectOverlay.width;\r\n        let nPreviewHeight = this.m_pGuideRectOverlay.height;\r\n        const nCheckSize = parseInt(Math.min(nPreviewWidth, nPreviewHeight) * 0.3);\r\n        const cardRatio = this.m_pPaperInfo.sizeHeight / this.m_pPaperInfo.sizeWidth;\r\n        const maxHeight = nPreviewHeight - nCheckSize;\r\n        const maxWidth = nPreviewWidth - nCheckSize;\r\n\r\n        let nCardHeight = maxHeight;\r\n        let nCardWidth = maxHeight / cardRatio;\r\n        if (nCardWidth > maxWidth) {\r\n            nCardWidth = maxWidth;\r\n            nCardHeight = maxWidth * cardRatio;\r\n        }\r\n\r\n        const nScanWidth = nCardWidth + nCheckSize;\r\n        const nScanHeight = nCardHeight + nCheckSize;\r\n    \r\n        const pScanSP = new cv[\"Point\"]((nPreviewWidth - nScanWidth) / 2,  (nPreviewHeight - nScanHeight) / 2);\r\n        const pScanAreaCenterPoint = this.getScanAreaCenterPoint(nCheckSize/2, nScanWidth, nScanHeight);\r\n\r\n        const cardSP_x = (pScanSP.x + pScanAreaCenterPoint[0].x);\r\n        const cardSP_y = (pScanSP.y + pScanAreaCenterPoint[0].y);\r\n\r\n        pCtx.rect(cardSP_x, cardSP_y,\r\n            (pScanAreaCenterPoint[1].x - pScanAreaCenterPoint[0].x),\r\n            (pScanAreaCenterPoint[2].y - pScanAreaCenterPoint[1].y));\r\n        pCtx.stroke();\r\n        \r\n\t\tif (this.m_bShowMaskGuide) {\r\n\t        if (nState == 0) {\r\n\t            pCtx = this.m_pGuideMaskOverlay.getContext(\"2d\");\r\n\t            pCtx.clearRect(0, 0, this.m_pGuideMaskOverlay.width, this.m_pGuideMaskOverlay.height);\r\n\t    \r\n\t            const scale = ((nScanWidth - nCheckSize) / this.m_pPaperInfo.sizeWidth);\r\n\t            for(let i = 0; i < this.m_pPaperInfo.item.length; i++) {\r\n\t                pCtx.beginPath();\r\n\t                pCtx.lineWidth = 0.5;\r\n\t                pCtx.strokeStyle = \"rgb(66, 133, 244)\";\r\n\t                pCtx.fillStyle = \"rgba(0, 255, 0, 0.3)\";\r\n\t    \r\n\t                const item = this.m_pPaperInfo.item[i];\r\n\t                pCtx.rect(\r\n\t                    cardSP_x + (item.left * scale),\r\n\t                    cardSP_y + (item.top * scale),\r\n\t                    item.width * scale,\r\n\t                    item.height * scale);\r\n\t                pCtx.stroke();\r\n\t                pCtx.fill();\r\n\t            }\r\n\t        }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * CardPreviewDiv여부를 반환\r\n     * @return CardPreviewDiv유무\r\n     */\r\n    _this[\"IsShown\"] = function() {\r\n        return (this.m_myUI != null);\r\n    };\r\n\r\n    /**\r\n     * 인감 프리뷰를 사용 못 할 때 카메라 촬영 또는 파일 탐색으로 인감 인식하는 함수\r\n     * capture=camera 속성을 지원하지 않으면 파일 탐색으로 동작\r\n     * @param pEndCallback 함수처리 후 호출될 콜백함수\r\n     */\r\n    _this[\"FindAreaFromFile\"] = function(pEndCallback) {\r\n        if (!this.m_pFile) {\r\n            this.m_pFile = document.createElement(\"input\");\r\n            $(this.m_pFile).attr(\"type\", \"file\");\r\n            $(this.m_pFile).attr(\"accept\", \"image/*\");\r\n            $(this.m_pFile).attr(\"capture\", \"camera\");\r\n            $(this.m_pFile)[\"css\"](\"display\", \"none\");\r\n            const oThis = this;\r\n            $(this.m_pFile).on(\"change\", function() {\r\n                oThis[\"FindAreaFromImage\"](URL.createObjectURL(this.files[0]), pEndCallback);\r\n                $(oThis.m_pFile).remove();\r\n                oThis.m_pFile = null;\r\n            });\r\n            $(document.body).append(this.m_pFile);\r\n        }\r\n        $(this.m_pFile).click();\r\n    };\r\n\r\n    /**\r\n     * 전달받은 이미지 데이터로 인감 인식하는 함수\r\n     * @param src 이미지 데이터\r\n     * @param pEndCallback 함수처리 후 호출될 콜백함수\r\n     */\r\n    _this[\"FindAreaFromImage\"] = function(src, pEndCallback) {\r\n        this.m_pEndCallback = pEndCallback;\r\n        const selectedImg = new Image();\r\n        $(selectedImg)[\"css\"](\"display\", \"none\");\r\n        $(selectedImg).attr(\"src\", src);\r\n        const oThis = this;\r\n        $(selectedImg).on(\"load\", function() {\r\n            \r\n            // HD(1280*720)에 근접하게 이미지 사이즈 보정 (긴 면이 1280 사이즈로 설정되도록 함)\r\n            const bLandscape = selectedImg.width > selectedImg.height;\r\n            const nRatio = 1280 / (bLandscape ? selectedImg.width : selectedImg.height);\r\n            selectedImg.width *= nRatio;\r\n            selectedImg.height *= nRatio;\r\n            \r\n            let pHiddenCanvas = null;\r\n            try {\r\n                const imgCard = selectedImg;\r\n                const nDPI = oThis.m_nDPI;\r\n                oThis.m_pTargetMat = cv[\"imread\"](imgCard);\r\n                oThis.m_pRecognitionPack = new OZRecognitionPack(OZRecognitionPack.MODE_ID);\r\n                oThis.m_pRecognitionPack.SetResultMimeType(oThis.m_strMimeType);\r\n                \r\n                pHiddenCanvas = document.createElement(\"canvas\");\r\n                pHiddenCanvas.width = imgCard.width;\r\n                pHiddenCanvas.height = imgCard.height;\r\n                const pCtx = pHiddenCanvas.getContext(\"2d\");\r\n\r\n                oThis.setScanArea(selectedImg.width, selectedImg.height);\r\n\r\n                pCtx.drawImage(imgCard, 0, 0, imgCard.width, imgCard.height);\r\n                oThis.m_pTargetMat.data.set(pCtx.getImageData(0, 0, imgCard.width, imgCard.height).data);\r\n                if (oThis.m_pRecognitionPack.FindArea(nDPI, pHiddenCanvas, oThis.m_pTargetMat, oThis.m_pPaperInfo, \r\n                    oThis.m_pScanArea, oThis.m_pScanAreaCenterPoint, oThis.m_nScanWidth, oThis.m_nScanHeight, false, false) == 999) {\r\n                    oThis.m_pEndCallback(true);\r\n                } else {\r\n                    $(selectedImg)[\"css\"](\"display\", \"\");\r\n                    oThis.m_pEndCallback(false, selectedImg);\r\n                }\r\n                oThis.m_pTargetMat.delete();\r\n                oThis.m_pTargetMat = null;\r\n            } catch (e) {\r\n                OZRecognitionPack[\"trace\"](e);\r\n                $(selectedImg)[\"css\"](\"display\", \"\");\r\n                oThis.m_pEndCallback(false, selectedImg);\r\n            } finally {\r\n                if (oThis.m_pTargetMat) {\r\n                    oThis.m_pTargetMat.delete();\r\n                    oThis.m_pTargetMat = null;\r\n                }\r\n                $(pHiddenCanvas).remove();\r\n                $(selectedImg).remove();\r\n            }\r\n        });\r\n        $(document.body).append(selectedImg);\r\n    };\r\n    /**\r\n     * Preview 크기를 재설정하는 함수\r\n     * @param nContentsWidth 너비\r\n     * @param nContentsHeight 높이\r\n     */\r\n    _this[\"UpdatePreviewSize\"] = function(nContentsWidth, nContentsHeight) {\r\n        $(this.m_myUI)[\"css\"](\"width\", nContentsWidth);\r\n        $(this.m_myUI)[\"css\"](\"height\", nContentsHeight);\r\n\r\n        let margin = 0;\r\n        if (nContentsWidth > nContentsHeight) {\r\n            margin = nContentsWidth * 0.05;\r\n        } else {\r\n            margin = nContentsHeight * 0.05;\r\n        }\r\n\r\n        let nWidth = nContentsWidth - margin;\r\n        let nHeight = nContentsHeight - margin;\r\n\r\n        this.m_nContentsWidth = nWidth;\r\n        this.m_nContentsHeight = nHeight;\r\n\r\n        const pCardPreviewWrappingDiv = $(this.m_myUI).children(\"div\");\r\n        \r\n        pCardPreviewWrappingDiv[\"css\"](\"width\", Math.floor(nWidth));\r\n        pCardPreviewWrappingDiv[\"css\"](\"height\", Math.floor(nHeight));\r\n\r\n        nWidth = Math.ceil(nWidth);\r\n        nHeight = Math.ceil(nHeight);\r\n\r\n        $(this.m_pVideo)[\"css\"](\"width\", nWidth)\r\n            [\"css\"](\"height\", nHeight);\r\n        $(this.m_pGuideRectOverlay)[\"css\"](\"width\", nWidth)\r\n            [\"css\"](\"height\", nHeight);\r\n        $(this.m_pGuideMaskOverlay)[\"css\"](\"width\", nWidth)\r\n            [\"css\"](\"height\", nHeight);\r\n\r\n        this.m_pGuideRectOverlay.width = nWidth;\r\n        this.m_pGuideRectOverlay.height = nHeight;\r\n        this.m_pGuideMaskOverlay.width = nWidth;\r\n        this.m_pGuideMaskOverlay.height = nHeight;\r\n\r\n        this.drawGuideRect(0);\r\n    };\r\n\r\n    /**\r\n     * 마스크 처리 전 이미지 데이터 반환\r\n     */\r\n    _this[\"GetUnmaskedImage\"] = function() {\r\n        return this.m_pRecognitionPack.GetPreprocessingImage();\r\n    };\r\n    /**\r\n     * 마스크 처리 후 이미지 데이터 반환\r\n     */\r\n    _this[\"GetMaskedImage\"] = function() {\r\n        return this.m_pRecognitionPack.GetPostprocessingImage();\r\n    };\r\n\r\n    /**\r\n     * 스캔 이미지 MIME 타입 설정\r\n     */\r\n     _this[\"SetResultMimeType\"] = function(strMimeType) {\r\n        this.m_strMimeType = strMimeType;\r\n    };\r\n\r\n    /**\r\n     * 스캔 이미지 MIME 타입 반환\r\n     */\r\n    _this[\"GetResultMimeType\"] = function() {\r\n        return this.m_pRecognitionPack.GetResultMimeType();\r\n    };\r\n\r\n    /**\r\n     * 프리뷰지원여부 체크하여 지원 시 pPreviewCallback을 호출하고 지원안하면 FindAreaFromFile을 호출하는 함수\r\n     * @param pEndCallback 함수처리 후 호출될 콜백함수\r\n     * @param pPreviewCallback 미리보기 지원 시 호출할 콜백함수\r\n     */\r\n    _this[\"IsSupportPreview\"] = function(pEndCallback, pPreviewCallback) {\r\n        \r\n        if (location.protocol !== \"https:\" || (typeof navigator.mediaDevices == \"undefined\")) {\r\n            OZRecognitionPack[\"trace\"](\"Current protocol is \" + location.protocol);\r\n            // no preview\r\n            this[\"FindAreaFromFile\"](pEndCallback);\r\n        } else {\r\n            var oThis = this;\r\n            navigator.mediaDevices.enumerateDevices()\r\n            .then(function(devices) {\r\n                let bEnablePreview = false;\r\n                devices.forEach(function(device) {\r\n                    if (device[\"kind\"][\"startsWith\"](\"video\")) {\r\n                        bEnablePreview = true;\r\n                        return;\r\n                    }\r\n                })\r\n                if (bEnablePreview) { // preview\r\n                    pPreviewCallback();\r\n                } else { // no preview\r\n                    oThis[\"FindAreaFromFile\"](pEndCallback);\r\n                }\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * 비디오 최소 해상도를 설정하는 함수\r\n     * @param width 최소 너비\r\n     * @param height 최소 높이\r\n     */\r\n    _this[\"SetVideoMinResolution\"] = function(width, height) {\r\n        if (isNaN(width) || isNaN(height)) {\r\n            OZRecognitionPack[\"trace\"](\"Invalid Resolution Value\");\r\n            throw new Error(\"Invalid Resolution Value\");\r\n        }\r\n        \r\n        this.m_nVideoMinWidth = width;\r\n        this.m_nVideoMinHeight = height;\r\n    };\r\n\r\n    _this[\"SetForceCaptrue\"] = function(b) {\r\n        this.m_bForceCapture = b;\r\n    };\r\n    \r\n    _this[\"SetShowMaskGuide\"] = function(b) {\r\n        this.m_bShowMaskGuide = b;\r\n    };\r\n\r\n    _this[\"SetJSONInfo\"] = function(objIDInfo) {\r\n        if (!objIDInfo[\"size\"]) { // size (required)\r\n            OZRecognitionPack[\"trace\"](\"The size property is missing.\");\r\n            throw new Error(OZCardPreview[\"INVALID_SIZE_PROP\"]);\r\n        }\r\n\r\n        const size = objIDInfo[\"size\"].split(\"x\");\r\n        const checkNaN = function(arr) {\r\n            for (let i=0; i<arr.length; i++) {\r\n                if (isNaN(arr[i])) {\r\n                    OZRecognitionPack[\"trace\"](\"The size property value can't be NaN\");\r\n                    throw new Error(OZCardPreview[\"INVALID_SIZE_PROP\"]);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (size.length != 2) {\r\n            OZRecognitionPack[\"trace\"](\"The size property can't be split into 2.\");\r\n            throw new Error(OZCardPreview[\"INVALID_SIZE_PROP\"]);\r\n        } \r\n        checkNaN(size);\r\n\r\n        const objPaper = {};\r\n\r\n        // cm -> mm\r\n        objPaper.sizeWidth = size[0] / 10;\r\n        objPaper.sizeHeight = size[1] / 10;\r\n        \r\n        let margin;\r\n        // margin (optional)\r\n        if (!objIDInfo[\"margin\"]) {\r\n            margin = 0;\r\n        } else {\r\n            if (isNaN(objIDInfo[\"margin\"])) {\r\n                OZRecognitionPack[\"trace\"](\"The margin property value can't be NaN.\");\r\n                throw new Error(OZCardPreview[\"INVALID_MARGIN_PROP\"]);\r\n            }\r\n            margin = objIDInfo[\"margin\"] / 10;\r\n        }\r\n\r\n        objPaper.sizeMargin = margin;\r\n        objPaper.item = [];\r\n\r\n        // mask (optional)\r\n        for (let i=0; i<objIDInfo[\"mask\"].length; i++) {\r\n            const arr = objIDInfo[\"mask\"][i][\"area\"].split(\",\");\r\n            \r\n            if (arr.length == 4) {\r\n                checkNaN(arr);\r\n                const maskArea = {};\r\n                maskArea.left = arr[0] / 10;\r\n                maskArea.top = arr[1] / 10;\r\n                maskArea.width = arr[2] / 10;\r\n                maskArea.height = arr[3] / 10;\r\n                objPaper.item.push(maskArea);\r\n            } else {\r\n                OZRecognitionPack[\"trace\"](\"The mask property can't be split into 4.\");\r\n                throw new Error(OZCardPreview[\"INVALID_MASK_PROP\"]);\r\n            }\r\n        }\r\n        this.m_pPaperInfo = objPaper;\r\n    };\r\n};\r\n\r\nOZCardPreview[\"INVALID_SIZE_PROP\"] = 0;\r\nOZCardPreview[\"INVALID_MARGIN_PROP\"] = 1;\r\nOZCardPreview[\"INVALID_MASK_PROP\"] = 2;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvT1pDYXJkUHJldmlldy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0Usb0JBQW9CLElBQUksMEJBQTBCO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDJCQUEyQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFTO0FBQ2xDLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxjQUFjO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQ0FBbUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixzQ0FBc0M7QUFDdEM7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vT1pTZWFsUmVjb2duaXRpb24vLi9zcmMvT1pDYXJkUHJldmlldy5qcz9hZGE5Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IE9aQ2FyZFByZXZpZXcgPSB3aW5kb3dbXCJPWkNhcmRQcmV2aWV3XCJdID0gZnVuY3Rpb24obkRQSSkge1xyXG4gICAgY29uc3QgX3RoaXMgPSBPWkNhcmRQcmV2aWV3LnByb3RvdHlwZTtcclxuICAgIFxyXG4gICAgdGhpcy5tX215VUkgPSBudWxsO1xyXG5cclxuICAgIHRoaXMubV9wR3VpZGVSZWN0T3ZlcmxheSA9IG51bGw7XHJcbiAgICB0aGlzLm1fcEd1aWRlTWFza092ZXJsYXkgPSBudWxsO1xyXG5cclxuICAgIHRoaXMubV9uRFBJID0gbkRQSTtcclxuICAgIHRoaXMubV9iRm9yY2VDYXB0dXJlID0gZmFsc2U7XHJcbiAgICB0aGlzLm1fYlNob3dNYXNrR3VpZGUgPSB0cnVlO1xyXG4gICAgXHJcbiAgICB0aGlzLm1fbkNoZWNrU2l6ZSA9IDA7XHJcbiAgICB0aGlzLm1fblNjYW5XaWR0aCA9IDA7XHJcbiAgICB0aGlzLm1fblNjYW5IZWlnaHQgPSAwO1xyXG4gICAgXHJcbiAgICB0aGlzLm1fcFBhcGVySW5mbyA9IG51bGw7XHJcbiAgICB0aGlzLm1fcFNjYW5TUCA9IG51bGw7XHJcbiAgICB0aGlzLm1fcFNjYW5BcmVhID0gbnVsbDtcclxuICAgIHRoaXMubV9wU2NhbkFyZWFDZW50ZXJQb2ludCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5tX2NvbnN0cmFpbnRzID0ge307XHJcbiAgICB0aGlzLm1fdmlkZW9UcmFja3MgPSBudWxsO1xyXG4gICAgdGhpcy5tX3BDYW52YXNVcGRhdGVGdW5jID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLm1fcFJlY29nbml0aW9uUGFjayA9IG51bGw7XHJcbiAgICB0aGlzLm1fYkZhY2luZ01vZGUgPSBmYWxzZTtcclxuICAgIHRoaXMubV9wVmlkZW8gPSBudWxsO1xyXG4gICAgdGhpcy5tX3BUbXBDYW52YXMgPSBudWxsO1xyXG4gICAgdGhpcy5tX3BUYXJnZXRNYXQgPSBudWxsO1xyXG4gICAgdGhpcy5tX3BFbmRDYWxsYmFjayA9IG51bGw7XHJcbiAgICB0aGlzLm1fbkNvbnRlbnRzV2lkdGggPSAwO1xyXG4gICAgdGhpcy5tX25Db250ZW50c0hlaWdodCA9IDA7XHJcbiAgICB0aGlzLm1fblZpZGVvTWluV2lkdGggPSAxMjgwO1xyXG4gICAgdGhpcy5tX25WaWRlb01pbkhlaWdodCA9IDcyMDtcclxuXHJcbiAgICB0aGlzLm1fcEZpbGUgPSBudWxsO1xyXG4gICAgdGhpcy5tX3N0ck1pbWVUeXBlID0gXCJcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOuplOuqqOumrCDtlbTsoJzsmqkg7ZWo7IiYXHJcbiAgICAgKi9cclxuICAgIF90aGlzW1wiRGlzcG9zZVwiXSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuc3RvcFByZXZpZXcoKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMubV9teVVJKSB7XHJcbiAgICAgICAgICAgIHRoaXMubV9wVmlkZW8gPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLm1fcFRtcENhbnZhcyA9IG51bGw7XHJcbiAgICAgICAgICAgICQodGhpcy5tX215VUkpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLm1fbXlVSSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm1fcFJlY29nbml0aW9uUGFjaykge1xyXG4gICAgICAgICAgICB0aGlzLm1fcFJlY29nbml0aW9uUGFjay5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIHRoaXMubV9wUmVjb2duaXRpb25QYWNrID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubV9wVGFyZ2V0TWF0KSB7XHJcbiAgICAgICAgICAgIHRoaXMubV9wVGFyZ2V0TWF0W1wiZGVsZXRlXCJdKCk7XHJcbiAgICAgICAgICAgIHRoaXMubV9wVGFyZ2V0TWF0ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tX25EUEkgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubV9jb25zdHJhaW50cyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tX3BFbmRDYWxsYmFjayA9IG51bGw7XHJcblxyXG4gICAgICAgIHRoaXMubV9wUGFwZXJJbmZvID0gbnVsbDtcclxuICAgICAgICB0aGlzLm1fcFNjYW5TUCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tX3BTY2FuQXJlYSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tX3BTY2FuQXJlYUNlbnRlclBvaW50ID0gbnVsbDtcclxuICAgIH07XHJcblxyXG4gICAgX3RoaXMuSW5pdENvbnN0cmFpbnRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgY29uc3QgcENvbnN0cmFpbnRzID0ge307XHJcbiAgICAgICAgcENvbnN0cmFpbnRzW1wiYXVkaW9cIl0gPSBmYWxzZTtcclxuICAgICAgICBwQ29uc3RyYWludHNbXCJ2aWRlb1wiXSA9IHt9O1xyXG5cclxuICAgICAgICAvL3ZhciBiRmFjaW5nTW9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYnRuX2ZhY2luZ21vZGVcIikuY2hlY2tlZDtcclxuICAgICAgICAvL3BDb25zdHJhaW50c1tcInZpZGVvXCJdW1wiZmFjaW5nTW9kZVwiXSA9ICh0aGlzLm1fYkZhY2luZ01vZGUgPyB7IFtcImV4YWN0XCJdOiBcInVzZXJcIiB9IDogeyBbXCJleGFjdFwiXTogXCJlbnZpcm9ubWVudFwiIH0pO1xyXG4gICAgICAgIGxldCBmYWNpbmdNb2RlID0ge307XHJcbiAgICAgICAgZmFjaW5nTW9kZVtcImV4YWN0XCJdID0gXCJlbnZpcm9ubWVudFwiO1xyXG4gICAgICAgIGlmICh0aGlzLm1fYkZhY2luZ01vZGUpIHtcclxuICAgICAgICAgICAgZmFjaW5nTW9kZSA9IFwidXNlclwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwQ29uc3RyYWludHNbXCJ2aWRlb1wiXVtcImZhY2luZ01vZGVcIl0gPSBmYWNpbmdNb2RlO1xyXG5cclxuICAgICAgICBsZXQgd2lkdGggPSB7fTtcclxuICAgICAgICBsZXQgaGVpZ2h0ID0ge307XHJcblxyXG4gICAgICAgIHdpZHRoW1wibWluXCJdID0gdGhpcy5tX25WaWRlb01pbldpZHRoO1xyXG4gICAgICAgIGhlaWdodFtcIm1pblwiXSA9IHRoaXMubV9uVmlkZW9NaW5IZWlnaHQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgd2lkdGhbXCJpZGVhbFwiXSA9IHRoaXMubV9uQ29udGVudHNXaWR0aDtcclxuICAgICAgICBoZWlnaHRbXCJpZGVhbFwiXSA9IHRoaXMubV9uQ29udGVudHNIZWlnaHQ7XHJcblxyXG4gICAgICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA+IHdpbmRvdy5pbm5lckhlaWdodCkge1xyXG4gICAgICAgICAgICBwQ29uc3RyYWludHNbXCJ2aWRlb1wiXS53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgICBwQ29uc3RyYWludHNbXCJ2aWRlb1wiXS5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcENvbnN0cmFpbnRzW1widmlkZW9cIl0ud2lkdGggPSBoZWlnaHQ7XHJcbiAgICAgICAgICAgIHBDb25zdHJhaW50c1tcInZpZGVvXCJdLmhlaWdodCA9IHdpZHRoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcENvbnN0cmFpbnRzW1widmlkZW9cIl1bXCJhZHZhbmNlZFwiXSA9IFt7IFwiZm9jdXNNb2RlXCI6IFwiY29udGludW91c1wiIH1dO1xyXG4gICAgICAgIHRoaXMubV9jb25zdHJhaW50cyA9IHBDb25zdHJhaW50cztcclxuICAgIH07XHJcblxyXG4gICAgX3RoaXMuU2V0TWVkaWFTdHJlYW0gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLkluaXRDb25zdHJhaW50cygpO1xyXG5cclxuICAgICAgICBjb25zdCBvVGhpcyA9IHRoaXM7XHJcbiAgICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEodGhpcy5tX2NvbnN0cmFpbnRzKVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKG1lZGlhU3RyZWFtKSB7XHJcbiAgICAgICAgICAgIC8vIE9sZGVyIGJyb3dzZXJzIG1heSBub3QgaGF2ZSBzcmNPYmplY3RcclxuICAgICAgICAgICAgaWYgKFwic3JjT2JqZWN0XCIgaW4gb1RoaXMubV9wVmlkZW8pIHtcclxuICAgICAgICAgICAgICAgIG9UaGlzLm1fcFZpZGVvLnNyY09iamVjdCA9IG1lZGlhU3RyZWFtO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZlbmRvclVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTDtcclxuICAgICAgICAgICAgICAgIC8vIEF2b2lkIHVzaW5nIHRoaXMgaW4gbmV3IGJyb3dzZXJzLCBhcyBpdCBpcyBnb2luZyBhd2F5LlxyXG4gICAgICAgICAgICAgICAgb1RoaXMubV9wVmlkZW8uc3JjID0gdmVuZG9yVVJMLmNyZWF0ZU9iamVjdFVSTChtZWRpYVN0cmVhbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb1RoaXMubV92aWRlb1RyYWNrcyA9IG1lZGlhU3RyZWFtLmdldFZpZGVvVHJhY2tzKCk7XHJcbiAgICAgICAgICAgIG9UaGlzLm1fcFZpZGVvLm9ubG9hZGVkbWV0YWRhdGEgPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICBvVGhpcy5tX3BWaWRlby5wbGF5KCk7XHJcbiAgICAgICAgICAgICAgICBvVGhpcy5tX3BWaWRlby53aWR0aCA9IG9UaGlzLm1fcFZpZGVvLnZpZGVvV2lkdGg7XHJcbiAgICAgICAgICAgICAgICBvVGhpcy5tX3BWaWRlby5oZWlnaHQgPSBvVGhpcy5tX3BWaWRlby52aWRlb0hlaWdodDtcclxuICAgICAgICAgICAgICAgIG9UaGlzLlN0YXJ0RmluZEFyZWEoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgaWYgKG9UaGlzLm1fYkZhY2luZ01vZGUpIHtcclxuICAgICAgICAgICAgICAgIE9aUmVjb2duaXRpb25QYWNrW1widHJhY2VcIl0oZXJyLm5hbWUgKyBcIjogXCIgKyBlcnIubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICBvVGhpc1tcIkZpbmRBcmVhRnJvbUZpbGVcIl0ob1RoaXMubV9wRW5kQ2FsbGJhY2spO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb1RoaXMubV9iRmFjaW5nTW9kZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBvVGhpcy5TZXRNZWRpYVN0cmVhbSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF90aGlzLlN0YXJ0RmluZEFyZWEgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5tX3ZpZGVvVHJhY2tzKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50VHJhY2sgPSB0aGlzLm1fdmlkZW9UcmFja3NbMF07XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50VHJhY2sgJiYgY3VycmVudFRyYWNrLmFwcGx5Q29uc3RyYWludHMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBiVXBkYXRlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubV9wVmlkZW8ucGF1c2VkIHx8IHRoaXMubV9wVmlkZW8uZW5kZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzcmNPYmplY3QgPyBhY3RpdmUgc3RhdGUgY2hlY2tcclxuICAgICAgICAgICAgICAgICAgICBiVXBkYXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJVcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGJVcGRhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuRlBTID0gNzAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZGVvID0gdGhpcy5tX3BWaWRlbztcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwSGlkZGVuQ2FudmFzID0gdGhpcy5tX3BUbXBDYW52YXM7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcEN0eCA9IHRoaXMubV9wVG1wQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tX3BSZWNvZ25pdGlvblBhY2sgPSBuZXcgT1pSZWNvZ25pdGlvblBhY2soT1pSZWNvZ25pdGlvblBhY2suTU9ERV9JRCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubV9wUmVjb2duaXRpb25QYWNrLlNldFJlc3VsdE1pbWVUeXBlKHRoaXMubV9zdHJNaW1lVHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuRFBJID0gdGhpcy5tX25EUEk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0bXBDYW52YXNSZWN0ID0gdGhpcy5nZXRUbXBDYW52YXNSZWN0KHZpZGVvLnZpZGVvV2lkdGgsIHZpZGVvLnZpZGVvSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ggPSB0bXBDYW52YXNSZWN0LkxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN5ID0gdG1wQ2FudmFzUmVjdC5Ub3A7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBIaWRkZW5DYW52YXMud2lkdGggPSB0bXBDYW52YXNSZWN0LldpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwSGlkZGVuQ2FudmFzLmhlaWdodCA9IHRtcENhbnZhc1JlY3QuSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFNjYW5BcmVhKHBIaWRkZW5DYW52YXMud2lkdGgsIHBIaWRkZW5DYW52YXMuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldE1hdFdpZHRoID0gcGFyc2VJbnQodGhpcy5tX3BTY2FuRVAueCAtIHRoaXMubV9wU2NhblNQLngpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRNYXRIZWlnaHQgPSBwYXJzZUludCh0aGlzLm1fcFNjYW5FUC55IC0gdGhpcy5tX3BTY2FuU1AueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubV9wVGFyZ2V0TWF0ID0gbmV3IGN2W1wiTWF0XCJdKHRhcmdldE1hdEhlaWdodCwgdGFyZ2V0TWF0V2lkdGgsIGN2W1wiQ1ZfOFVDNFwiXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdHdWlkZVJlY3QoMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvVGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubV9wQ2FudmFzVXBkYXRlRnVuYyA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcEN0eC5kcmF3SW1hZ2UodmlkZW8sIHN4LCBzeSwgcEhpZGRlbkNhbnZhcy53aWR0aCwgcEhpZGRlbkNhbnZhcy5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwgMCwgcEhpZGRlbkNhbnZhcy53aWR0aCwgcEhpZGRlbkNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb1RoaXMubV9wVGFyZ2V0TWF0LmRhdGEuc2V0KHBDdHguZ2V0SW1hZ2VEYXRhKHBhcnNlSW50KG9UaGlzLm1fcFNjYW5TUC54KSwgcGFyc2VJbnQob1RoaXMubV9wU2NhblNQLnkpLCB0YXJnZXRNYXRXaWR0aCwgdGFyZ2V0TWF0SGVpZ2h0KS5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob1RoaXMubV9wUmVjb2duaXRpb25QYWNrLkZpbmRBcmVhKG5EUEksIHBIaWRkZW5DYW52YXMsIG9UaGlzLm1fcFRhcmdldE1hdCwgb1RoaXMubV9wUGFwZXJJbmZvLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9UaGlzLm1fcFNjYW5BcmVhLCBvVGhpcy5tX3BTY2FuQXJlYUNlbnRlclBvaW50LCBvVGhpcy5tX25TY2FuV2lkdGgsIG9UaGlzLm1fblNjYW5IZWlnaHQsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSwgb1RoaXMubV9iRm9yY2VDYXB0dXJlKSA9PSA5OTkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb1RoaXMuZHJhd0d1aWRlUmVjdCgyKTtcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvVGhpcy5tX3BUYXJnZXRNYXQuZGVsZXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9UaGlzLm1fcFRhcmdldE1hdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwob1RoaXMubV9wQ2FudmFzVXBkYXRlRnVuYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOy0rOyYgSDtm4QgMC417LSIIOuSpCDsvZzrsLHtlajsiJgg7Zi47LacXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvVGhpcy5zdG9wUHJldmlldygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb1RoaXMubV9wRW5kQ2FsbGJhY2sodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKG9UaGlzLm1fbXlVSSlbXCJjc3NcIl0oXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgNTAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb1RoaXMuc3RvcFByZXZpZXcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPWlJlY29nbml0aW9uUGFja1tcInRyYWNlXCJdKGUubmFtZSArIFwiOiBcIiArIGUubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9UaGlzLm1fcFRhcmdldE1hdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvVGhpcy5tX3BUYXJnZXRNYXQuZGVsZXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9UaGlzLm1fcFRhcmdldE1hdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIG5GUFMpOyAvLyBzZXRJbnRlcnZhbFxyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBPWlJlY29nbml0aW9uUGFja1tcInRyYWNlXCJdKGVyci5uYW1lICsgXCI6IFwiICsgZXJyLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tX3BUYXJnZXRNYXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubV9wVGFyZ2V0TWF0LmRlbGV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tX3BUYXJnZXRNYXQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIE9aUmVjb2duaXRpb25QYWNrW1widHJhY2VcIl0oXCIhdmlkZW9UcmFja3NcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOuvuOumrOuztOq4sOulvCDsi5zsnpHsi5ztgqTripQg7ZWo7IiYKOyerOyLnOyeke2VoCDrlYzrj4Qg7IKs7Jqp6rCA64qlKVxyXG4gICAgICovXHJcbiAgICBfdGhpc1tcIlN0YXJ0Q2FwdHVyZVwiXSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuc3RvcFByZXZpZXcoKTtcclxuICAgICAgICB0aGlzLlNldE1lZGlhU3RyZWFtKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIF90aGlzLnN0b3BQcmV2aWV3ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubV9wQ2FudmFzVXBkYXRlRnVuYykge1xyXG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMubV9wQ2FudmFzVXBkYXRlRnVuYyk7XHJcbiAgICAgICAgICAgIHRoaXMubV9wQ2FudmFzVXBkYXRlRnVuYyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm1fdmlkZW9UcmFja3MpIHtcclxuICAgICAgICAgICAgdGhpcy5tX3ZpZGVvVHJhY2tzLmZvckVhY2goZnVuY3Rpb24odHJhY2spIHsgdHJhY2suc3RvcCgpIH0pO1xyXG4gICAgICAgICAgICB0aGlzLm1fdmlkZW9UcmFja3MgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5tX3BWaWRlbykge1xyXG4gICAgICAgICAgICBpZiAoXCJzcmNPYmplY3RcIiBpbiB0aGlzLm1fcFZpZGVvKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1fcFZpZGVvLnNyY09iamVjdCA9IG51bGw7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1fcFZpZGVvLnNyYyA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FyZFByZXZpZXdEaXbrpbwg67aZ7J2064qUIO2VqOyImFxyXG4gICAgICogQHBhcmFtIHRhcmdldCBQcmV2aWV3RGl26rCAIOu2meydhCDsl5jrpqzrqLztirhcclxuICAgICAqIEBwYXJhbSBuQ29udGVudHNXaWR0aCDrr7jrpqzrs7TquLAg64SI67mEXHJcbiAgICAgKiBAcGFyYW0gbkNvbnRlbnRzSGVpZ2h0IOuvuOumrOuztOq4sCDrhpLsnbRcclxuICAgICAqIEBwYXJhbSBwRW5kQ2FsbGJhY2sg7J246rCQIOyKpOy6lCDtm4Qg7Zi47Lac65CgIOy9nOuwsVxyXG4gICAgICogQHJldHVybiBDYXJkUHJldmlld0RpdiDsg53shLHrkJwgQ2FyZFByZXZpZXdEaXZcclxuICAgICAqL1xyXG4gICAgX3RoaXNbXCJTaG93UHJldmlld09uXCJdID0gZnVuY3Rpb24odGFyZ2V0LCBuQ29udGVudHNXaWR0aCwgbkNvbnRlbnRzSGVpZ2h0LCBwRW5kQ2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLm1fcEVuZENhbGxiYWNrID0gcEVuZENhbGxiYWNrO1xyXG5cclxuICAgICAgICB0aGlzLm1fbXlVSSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgJCh0aGlzLm1fbXlVSSlbXCJjc3NcIl0oXCJ3aWR0aFwiLCBuQ29udGVudHNXaWR0aCk7XHJcbiAgICAgICAgJCh0aGlzLm1fbXlVSSlbXCJjc3NcIl0oXCJoZWlnaHRcIiwgbkNvbnRlbnRzSGVpZ2h0KTtcclxuICAgICAgICAkKHRoaXMubV9teVVJKVtcImNzc1wiXShcImRpc3BsYXlcIiwgXCJmbGV4XCIpO1xyXG5cclxuICAgICAgICBsZXQgbWFyZ2luID0gMDtcclxuICAgICAgICBpZiAobkNvbnRlbnRzV2lkdGggPiBuQ29udGVudHNIZWlnaHQpIHtcclxuICAgICAgICAgICAgbWFyZ2luID0gbkNvbnRlbnRzV2lkdGggKiAwLjA1O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1hcmdpbiA9IG5Db250ZW50c0hlaWdodCAqIDAuMDU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm1fbkNvbnRlbnRzV2lkdGggPSBuQ29udGVudHNXaWR0aCAtIG1hcmdpbjs7XHJcbiAgICAgICAgdGhpcy5tX25Db250ZW50c0hlaWdodCA9IG5Db250ZW50c0hlaWdodCAtIG1hcmdpbjs7XHJcblxyXG4gICAgICAgIGNvbnN0IHBEaXZQcmV2aWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICAkKHBEaXZQcmV2aWV3KVtcImNzc1wiXShcImJvcmRlclwiLCBcIjFweCBzb2xpZCBibGFja1wiKVxyXG4gICAgICAgICAgICBbXCJjc3NcIl0oXCJvdmVyZmxvd1wiLCBcImhpZGRlblwiKVxyXG4gICAgICAgICAgICBbXCJjc3NcIl0oXCJtYXJnaW5cIiwgXCJhdXRvXCIpXHJcbiAgICAgICAgICAgIFtcImNzc1wiXShcImJhY2tncm91bmQtY29sb3JcIiwgXCJibGFja1wiKTtcclxuXHJcbiAgICAgICAgY29uc3QgcFZpZGVvUHJldmlldyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiKTtcclxuICAgICAgICAkKHBWaWRlb1ByZXZpZXcpLmF0dHIoXCJwbGF5c2lubGluZVwiLCAgXCJcIik7XHJcbiAgICAgICAgJChwVmlkZW9QcmV2aWV3KVtcImNzc1wiXShcImRpc3BsYXlcIiwgXCJibG9ja1wiKVxyXG4gICAgICAgICAgICBbXCJjc3NcIl0oXCJvYmplY3QtZml0XCIsIFwiY292ZXJcIilcclxuICAgICAgICAgICAgW1wiY3NzXCJdKFwibWFyZ2luXCIsIFwiYXV0b1wiKVxyXG4gICAgICAgICAgICBbXCJjc3NcIl0oXCJ3aWR0aFwiLCB0aGlzLm1fbkNvbnRlbnRzV2lkdGgpXHJcbiAgICAgICAgICAgIFtcImNzc1wiXShcImhlaWdodFwiLCB0aGlzLm1fbkNvbnRlbnRzSGVpZ2h0KTtcclxuXHJcbiAgICAgICAgdGhpcy5tX3BWaWRlbyA9IHBWaWRlb1ByZXZpZXc7XHJcbiAgICAgICAgY29uc3QgcENhbnZhc091dHB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XHJcbiAgICAgICAgJChwQ2FudmFzT3V0cHV0KVtcImNzc1wiXShcIm1hcmdpblwiLCBcImF1dG9cIilcclxuICAgICAgICAgICAgW1wiY3NzXCJdKFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XHJcblxyXG4gICAgICAgIHRoaXMubV9wR3VpZGVSZWN0T3ZlcmxheSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XHJcbiAgICAgICAgJCh0aGlzLm1fcEd1aWRlUmVjdE92ZXJsYXkpW1wiY3NzXCJdKFwibWFyZ2luXCIsIFwiYXV0b1wiKVxyXG4gICAgICAgICAgICBbXCJjc3NcIl0oXCJwb3NpdGlvblwiLCBcImFic29sdXRlXCIpXHJcbiAgICAgICAgICAgIFtcImNzc1wiXShcIndpZHRoXCIsIHRoaXMubV9uQ29udGVudHNXaWR0aClcclxuICAgICAgICAgICAgW1wiY3NzXCJdKFwiaGVpZ2h0XCIsIHRoaXMubV9uQ29udGVudHNIZWlnaHQpO1xyXG5cclxuICAgICAgICB0aGlzLm1fcEd1aWRlTWFza092ZXJsYXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG4gICAgICAgICQodGhpcy5tX3BHdWlkZU1hc2tPdmVybGF5KVtcImNzc1wiXShcIm1hcmdpblwiLCBcImF1dG9cIilcclxuICAgICAgICAgICAgW1wiY3NzXCJdKFwicG9zaXRpb25cIiwgXCJhYnNvbHV0ZVwiKVxyXG4gICAgICAgICAgICBbXCJjc3NcIl0oXCJ3aWR0aFwiLCB0aGlzLm1fbkNvbnRlbnRzV2lkdGgpXHJcbiAgICAgICAgICAgIFtcImNzc1wiXShcImhlaWdodFwiLCB0aGlzLm1fbkNvbnRlbnRzSGVpZ2h0KTtcclxuXHJcbiAgICAgICAgJChwRGl2UHJldmlldykuYXBwZW5kKHRoaXMubV9wR3VpZGVSZWN0T3ZlcmxheSlcclxuICAgICAgICAgICAgLmFwcGVuZCh0aGlzLm1fcEd1aWRlTWFza092ZXJsYXkpXHJcbiAgICAgICAgICAgIC5hcHBlbmQocFZpZGVvUHJldmlldylcclxuICAgICAgICAgICAgLmFwcGVuZChwQ2FudmFzT3V0cHV0KTtcclxuICAgICAgICAkKHRoaXMubV9teVVJKS5hcHBlbmQocERpdlByZXZpZXcpO1xyXG5cclxuICAgICAgICB0aGlzLm1fcFRtcENhbnZhcyA9IHBDYW52YXNPdXRwdXQ7XHJcbiAgICAgICAgJCh0YXJnZXQpLmFwcGVuZCh0aGlzLm1fbXlVSSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubV9teVVJO1xyXG4gICAgfTtcclxuXHJcbiAgICBfdGhpcy5nZXRUbXBDYW52YXNSZWN0ID0gZnVuY3Rpb24odmlkZW9XaWR0aCwgdmlkZW9IZWlnaHQpIHtcclxuICAgICAgICBjb25zdCBwUmVjdCA9IHt9O1xyXG5cdFx0cFJlY3QuTGVmdCA9IDA7XHJcblx0XHRwUmVjdC5Ub3AgPSAwO1xyXG5cdFx0cFJlY3QuV2lkdGggPSB2aWRlb1dpZHRoO1xyXG5cdFx0cFJlY3QuSGVpZ2h0ID0gdmlkZW9IZWlnaHQ7XHJcblx0XHRpZiAocFJlY3QuV2lkdGggLyB0aGlzLm1fbkNvbnRlbnRzV2lkdGggPiBwUmVjdC5IZWlnaHQgLyB0aGlzLm1fbkNvbnRlbnRzSGVpZ2h0KSB7XHJcblx0XHRcdHBSZWN0LldpZHRoID0gdGhpcy5tX25Db250ZW50c1dpZHRoICogcFJlY3QuSGVpZ2h0IC8gdGhpcy5tX25Db250ZW50c0hlaWdodDtcclxuXHRcdFx0cFJlY3QuTGVmdCArPSAodmlkZW9XaWR0aCAtIHBSZWN0LldpZHRoKSAvIDI7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRwUmVjdC5IZWlnaHQgPSB0aGlzLm1fbkNvbnRlbnRzSGVpZ2h0ICogcFJlY3QuV2lkdGggLyB0aGlzLm1fbkNvbnRlbnRzV2lkdGg7XHJcblx0XHRcdHBSZWN0LlRvcCArPSAodmlkZW9IZWlnaHQgLSBwUmVjdC5IZWlnaHQpIC8gMjtcclxuXHRcdH1cclxuXHRcdHJldHVybiBwUmVjdDtcclxuICAgIH07XHJcblxyXG4gICAgX3RoaXMuc2V0U2NhbkFyZWEgPSBmdW5jdGlvbihuV2lkdGgsIG5IZWlnaHQpIHtcclxuICAgICAgICBsZXQgblByZXZpZXdXaWR0aCA9IG5XaWR0aDtcclxuICAgICAgICBsZXQgblByZXZpZXdIZWlnaHQgPSBuSGVpZ2h0O1xyXG4gICAgICAgIHRoaXMubV9uQ2hlY2tTaXplID0gcGFyc2VJbnQoTWF0aC5taW4oblByZXZpZXdXaWR0aCwgblByZXZpZXdIZWlnaHQpICogMC4zKTtcclxuICAgICAgICBjb25zdCBjYXJkUmF0aW8gPSB0aGlzLm1fcFBhcGVySW5mby5zaXplSGVpZ2h0IC8gdGhpcy5tX3BQYXBlckluZm8uc2l6ZVdpZHRoO1xyXG4gICAgICAgIGNvbnN0IG1heEhlaWdodCA9IG5QcmV2aWV3SGVpZ2h0IC0gdGhpcy5tX25DaGVja1NpemU7XHJcbiAgICAgICAgY29uc3QgbWF4V2lkdGggPSBuUHJldmlld1dpZHRoIC0gdGhpcy5tX25DaGVja1NpemU7XHJcblxyXG4gICAgICAgIGxldCBuQ2FyZEhlaWdodCA9IG1heEhlaWdodDtcclxuICAgICAgICBsZXQgbkNhcmRXaWR0aCA9IG1heEhlaWdodCAvIGNhcmRSYXRpbztcclxuXHJcbiAgICAgICAgaWYgKG5DYXJkV2lkdGggPiBtYXhXaWR0aCkge1xyXG4gICAgICAgICAgICBuQ2FyZFdpZHRoID0gbWF4V2lkdGg7XHJcbiAgICAgICAgICAgIG5DYXJkSGVpZ2h0ID0gbWF4V2lkdGggKiBjYXJkUmF0aW87XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm1fblNjYW5XaWR0aCA9IG5DYXJkV2lkdGggKyB0aGlzLm1fbkNoZWNrU2l6ZTtcclxuICAgICAgICB0aGlzLm1fblNjYW5IZWlnaHQgPSBuQ2FyZEhlaWdodCArIHRoaXMubV9uQ2hlY2tTaXplO1xyXG4gICAgXHJcbiAgICAgICAgdGhpcy5tX3BTY2FuU1AgPSBuZXcgY3ZbXCJQb2ludFwiXSgoblByZXZpZXdXaWR0aCAtIHRoaXMubV9uU2NhbldpZHRoKSAvIDIsICAoblByZXZpZXdIZWlnaHQgLSB0aGlzLm1fblNjYW5IZWlnaHQpIC8gMik7XHJcbiAgICAgICAgdGhpcy5tX3BTY2FuRVAgPSBuZXcgY3ZbXCJQb2ludFwiXSh0aGlzLm1fcFNjYW5TUC54ICsgdGhpcy5tX25TY2FuV2lkdGgsIHRoaXMubV9wU2NhblNQLnkgKyB0aGlzLm1fblNjYW5IZWlnaHQpO1xyXG5cclxuICAgICAgICB0aGlzLm1fcFNjYW5BcmVhID0gW107XHJcbiAgICAgICAgdGhpcy5tX3BTY2FuQXJlYS5wdXNoKG5ldyBjdltcIlJlY3RcIl0oMCwgMCwgdGhpcy5tX25DaGVja1NpemUsIHRoaXMubV9uQ2hlY2tTaXplKSk7XHJcbiAgICAgICAgdGhpcy5tX3BTY2FuQXJlYS5wdXNoKG5ldyBjdltcIlJlY3RcIl0odGhpcy5tX25TY2FuV2lkdGggLSB0aGlzLm1fbkNoZWNrU2l6ZSwgMCwgdGhpcy5tX25DaGVja1NpemUsIHRoaXMubV9uQ2hlY2tTaXplKSk7XHJcbiAgICAgICAgdGhpcy5tX3BTY2FuQXJlYS5wdXNoKG5ldyBjdltcIlJlY3RcIl0odGhpcy5tX25TY2FuV2lkdGggLSB0aGlzLm1fbkNoZWNrU2l6ZSwgdGhpcy5tX25TY2FuSGVpZ2h0IC0gdGhpcy5tX25DaGVja1NpemUsIHRoaXMubV9uQ2hlY2tTaXplLCB0aGlzLm1fbkNoZWNrU2l6ZSkpO1xyXG4gICAgICAgIHRoaXMubV9wU2NhbkFyZWEucHVzaChuZXcgY3ZbXCJSZWN0XCJdKDAsIHRoaXMubV9uU2NhbkhlaWdodCAtIHRoaXMubV9uQ2hlY2tTaXplLCB0aGlzLm1fbkNoZWNrU2l6ZSwgdGhpcy5tX25DaGVja1NpemUpKTtcclxuXHJcbiAgICAgICAgdGhpcy5tX3BTY2FuQXJlYUNlbnRlclBvaW50ID0gdGhpcy5nZXRTY2FuQXJlYUNlbnRlclBvaW50KHRoaXMubV9uQ2hlY2tTaXplLzIsIHRoaXMubV9uU2NhbldpZHRoLCB0aGlzLm1fblNjYW5IZWlnaHQpXHJcbiAgICB9O1xyXG5cclxuICAgIF90aGlzLmdldFNjYW5BcmVhQ2VudGVyUG9pbnQgPSBmdW5jdGlvbihuSGFsZkNoZWNrU2l6ZSwgblNjYW5XaWR0aCwgblNjYW5IZWlnaHQpIHtcclxuICAgICAgICBwU2NhbkFyZWFDZW50ZXJQb2ludCA9IFtdO1xyXG4gICAgICAgIHBTY2FuQXJlYUNlbnRlclBvaW50LnB1c2gobmV3IGN2W1wiUG9pbnRcIl0obkhhbGZDaGVja1NpemUsIG5IYWxmQ2hlY2tTaXplKSk7XHJcbiAgICAgICAgcFNjYW5BcmVhQ2VudGVyUG9pbnQucHVzaChuZXcgY3ZbXCJQb2ludFwiXShuU2NhbldpZHRoIC0gKG5IYWxmQ2hlY2tTaXplKSwgKG5IYWxmQ2hlY2tTaXplKSkpO1xyXG4gICAgICAgIHBTY2FuQXJlYUNlbnRlclBvaW50LnB1c2gobmV3IGN2W1wiUG9pbnRcIl0oblNjYW5XaWR0aCAtIChuSGFsZkNoZWNrU2l6ZSksIG5TY2FuSGVpZ2h0IC0gKG5IYWxmQ2hlY2tTaXplKSkpO1xyXG4gICAgICAgIHBTY2FuQXJlYUNlbnRlclBvaW50LnB1c2gobmV3IGN2W1wiUG9pbnRcIl0obkhhbGZDaGVja1NpemUsIChuU2NhbkhlaWdodCAtIG5IYWxmQ2hlY2tTaXplKSkpO1xyXG5cclxuICAgICAgICByZXR1cm4gcFNjYW5BcmVhQ2VudGVyUG9pbnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF90aGlzLmRyYXdHdWlkZVJlY3QgPSBmdW5jdGlvbihuU3RhdGUpIHtcclxuICAgICAgICBsZXQgcEN0eCA9IHRoaXMubV9wR3VpZGVSZWN0T3ZlcmxheS5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICAgICAgcEN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5tX3BHdWlkZVJlY3RPdmVybGF5LndpZHRoLCB0aGlzLm1fcEd1aWRlUmVjdE92ZXJsYXkuaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgcEN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBpZiAoblN0YXRlID09IDApIHtcclxuICAgICAgICAgICAgcEN0eC5zdHJva2VTdHlsZSA9IFwicmdiKDI1NSwgMjU1LCAyNTUpXCI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChuU3RhdGUgPT0gMSkge1xyXG4gICAgICAgICAgICBwQ3R4LnN0cm9rZVN0eWxlID0gXCJyZ2IoMjU1LCAxNzgsIDE1MClcIjtcclxuICAgICAgICB9IGVsc2UgaWYgKG5TdGF0ZSA9PSAyKSB7XHJcbiAgICAgICAgICAgIHBDdHguc3Ryb2tlU3R5bGUgPSBcInJnYigyNTQsIDEwMCwgNDYpXCI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcEN0eC5zdHJva2VTdHlsZSA9IFwicmdiKDI1NSwgMjU1LCAyNTUpXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBDdHgubGluZVdpZHRoID0gMS41O1xyXG5cclxuICAgICAgICBsZXQgblByZXZpZXdXaWR0aCA9IHRoaXMubV9wR3VpZGVSZWN0T3ZlcmxheS53aWR0aDtcclxuICAgICAgICBsZXQgblByZXZpZXdIZWlnaHQgPSB0aGlzLm1fcEd1aWRlUmVjdE92ZXJsYXkuaGVpZ2h0O1xyXG4gICAgICAgIGNvbnN0IG5DaGVja1NpemUgPSBwYXJzZUludChNYXRoLm1pbihuUHJldmlld1dpZHRoLCBuUHJldmlld0hlaWdodCkgKiAwLjMpO1xyXG4gICAgICAgIGNvbnN0IGNhcmRSYXRpbyA9IHRoaXMubV9wUGFwZXJJbmZvLnNpemVIZWlnaHQgLyB0aGlzLm1fcFBhcGVySW5mby5zaXplV2lkdGg7XHJcbiAgICAgICAgY29uc3QgbWF4SGVpZ2h0ID0gblByZXZpZXdIZWlnaHQgLSBuQ2hlY2tTaXplO1xyXG4gICAgICAgIGNvbnN0IG1heFdpZHRoID0gblByZXZpZXdXaWR0aCAtIG5DaGVja1NpemU7XHJcblxyXG4gICAgICAgIGxldCBuQ2FyZEhlaWdodCA9IG1heEhlaWdodDtcclxuICAgICAgICBsZXQgbkNhcmRXaWR0aCA9IG1heEhlaWdodCAvIGNhcmRSYXRpbztcclxuICAgICAgICBpZiAobkNhcmRXaWR0aCA+IG1heFdpZHRoKSB7XHJcbiAgICAgICAgICAgIG5DYXJkV2lkdGggPSBtYXhXaWR0aDtcclxuICAgICAgICAgICAgbkNhcmRIZWlnaHQgPSBtYXhXaWR0aCAqIGNhcmRSYXRpbztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IG5TY2FuV2lkdGggPSBuQ2FyZFdpZHRoICsgbkNoZWNrU2l6ZTtcclxuICAgICAgICBjb25zdCBuU2NhbkhlaWdodCA9IG5DYXJkSGVpZ2h0ICsgbkNoZWNrU2l6ZTtcclxuICAgIFxyXG4gICAgICAgIGNvbnN0IHBTY2FuU1AgPSBuZXcgY3ZbXCJQb2ludFwiXSgoblByZXZpZXdXaWR0aCAtIG5TY2FuV2lkdGgpIC8gMiwgIChuUHJldmlld0hlaWdodCAtIG5TY2FuSGVpZ2h0KSAvIDIpO1xyXG4gICAgICAgIGNvbnN0IHBTY2FuQXJlYUNlbnRlclBvaW50ID0gdGhpcy5nZXRTY2FuQXJlYUNlbnRlclBvaW50KG5DaGVja1NpemUvMiwgblNjYW5XaWR0aCwgblNjYW5IZWlnaHQpO1xyXG5cclxuICAgICAgICBjb25zdCBjYXJkU1BfeCA9IChwU2NhblNQLnggKyBwU2NhbkFyZWFDZW50ZXJQb2ludFswXS54KTtcclxuICAgICAgICBjb25zdCBjYXJkU1BfeSA9IChwU2NhblNQLnkgKyBwU2NhbkFyZWFDZW50ZXJQb2ludFswXS55KTtcclxuXHJcbiAgICAgICAgcEN0eC5yZWN0KGNhcmRTUF94LCBjYXJkU1BfeSxcclxuICAgICAgICAgICAgKHBTY2FuQXJlYUNlbnRlclBvaW50WzFdLnggLSBwU2NhbkFyZWFDZW50ZXJQb2ludFswXS54KSxcclxuICAgICAgICAgICAgKHBTY2FuQXJlYUNlbnRlclBvaW50WzJdLnkgLSBwU2NhbkFyZWFDZW50ZXJQb2ludFsxXS55KSk7XHJcbiAgICAgICAgcEN0eC5zdHJva2UoKTtcclxuICAgICAgICBcclxuXHRcdGlmICh0aGlzLm1fYlNob3dNYXNrR3VpZGUpIHtcclxuXHQgICAgICAgIGlmIChuU3RhdGUgPT0gMCkge1xyXG5cdCAgICAgICAgICAgIHBDdHggPSB0aGlzLm1fcEd1aWRlTWFza092ZXJsYXkuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG5cdCAgICAgICAgICAgIHBDdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMubV9wR3VpZGVNYXNrT3ZlcmxheS53aWR0aCwgdGhpcy5tX3BHdWlkZU1hc2tPdmVybGF5LmhlaWdodCk7XHJcblx0ICAgIFxyXG5cdCAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gKChuU2NhbldpZHRoIC0gbkNoZWNrU2l6ZSkgLyB0aGlzLm1fcFBhcGVySW5mby5zaXplV2lkdGgpO1xyXG5cdCAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLm1fcFBhcGVySW5mby5pdGVtLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgIHBDdHguYmVnaW5QYXRoKCk7XHJcblx0ICAgICAgICAgICAgICAgIHBDdHgubGluZVdpZHRoID0gMC41O1xyXG5cdCAgICAgICAgICAgICAgICBwQ3R4LnN0cm9rZVN0eWxlID0gXCJyZ2IoNjYsIDEzMywgMjQ0KVwiO1xyXG5cdCAgICAgICAgICAgICAgICBwQ3R4LmZpbGxTdHlsZSA9IFwicmdiYSgwLCAyNTUsIDAsIDAuMylcIjtcclxuXHQgICAgXHJcblx0ICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLm1fcFBhcGVySW5mby5pdGVtW2ldO1xyXG5cdCAgICAgICAgICAgICAgICBwQ3R4LnJlY3QoXHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXJkU1BfeCArIChpdGVtLmxlZnQgKiBzY2FsZSksXHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXJkU1BfeSArIChpdGVtLnRvcCAqIHNjYWxlKSxcclxuXHQgICAgICAgICAgICAgICAgICAgIGl0ZW0ud2lkdGggKiBzY2FsZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIGl0ZW0uaGVpZ2h0ICogc2NhbGUpO1xyXG5cdCAgICAgICAgICAgICAgICBwQ3R4LnN0cm9rZSgpO1xyXG5cdCAgICAgICAgICAgICAgICBwQ3R4LmZpbGwoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhcmRQcmV2aWV3RGl27Jes67aA66W8IOuwmO2ZmFxyXG4gICAgICogQHJldHVybiBDYXJkUHJldmlld0RpduycoOustFxyXG4gICAgICovXHJcbiAgICBfdGhpc1tcIklzU2hvd25cIl0gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMubV9teVVJICE9IG51bGwpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOyduOqwkCDtlITrpqzrt7Drpbwg7IKs7JqpIOuquyDtlaAg65WMIOy5tOuplOudvCDstKzsmIEg65iQ64qUIO2MjOydvCDtg5Dsg4nsnLzroZwg7J246rCQIOyduOyLne2VmOuKlCDtlajsiJhcclxuICAgICAqIGNhcHR1cmU9Y2FtZXJhIOyGjeyEseydhCDsp4Dsm5DtlZjsp4Ag7JWK7Jy866m0IO2MjOydvCDtg5Dsg4nsnLzroZwg64+Z7J6RXHJcbiAgICAgKiBAcGFyYW0gcEVuZENhbGxiYWNrIO2VqOyImOyymOumrCDtm4Qg7Zi47Lac65CgIOy9nOuwse2VqOyImFxyXG4gICAgICovXHJcbiAgICBfdGhpc1tcIkZpbmRBcmVhRnJvbUZpbGVcIl0gPSBmdW5jdGlvbihwRW5kQ2FsbGJhY2spIHtcclxuICAgICAgICBpZiAoIXRoaXMubV9wRmlsZSkge1xyXG4gICAgICAgICAgICB0aGlzLm1fcEZpbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XHJcbiAgICAgICAgICAgICQodGhpcy5tX3BGaWxlKS5hdHRyKFwidHlwZVwiLCBcImZpbGVcIik7XHJcbiAgICAgICAgICAgICQodGhpcy5tX3BGaWxlKS5hdHRyKFwiYWNjZXB0XCIsIFwiaW1hZ2UvKlwiKTtcclxuICAgICAgICAgICAgJCh0aGlzLm1fcEZpbGUpLmF0dHIoXCJjYXB0dXJlXCIsIFwiY2FtZXJhXCIpO1xyXG4gICAgICAgICAgICAkKHRoaXMubV9wRmlsZSlbXCJjc3NcIl0oXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcclxuICAgICAgICAgICAgY29uc3Qgb1RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAkKHRoaXMubV9wRmlsZSkub24oXCJjaGFuZ2VcIiwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBvVGhpc1tcIkZpbmRBcmVhRnJvbUltYWdlXCJdKFVSTC5jcmVhdGVPYmplY3RVUkwodGhpcy5maWxlc1swXSksIHBFbmRDYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICAkKG9UaGlzLm1fcEZpbGUpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgb1RoaXMubV9wRmlsZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAkKGRvY3VtZW50LmJvZHkpLmFwcGVuZCh0aGlzLm1fcEZpbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAkKHRoaXMubV9wRmlsZSkuY2xpY2soKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDsoITri6zrsJvsnYAg7J2066+47KeAIOuNsOydtO2EsOuhnCDsnbjqsJAg7J247Iud7ZWY64qUIO2VqOyImFxyXG4gICAgICogQHBhcmFtIHNyYyDsnbTrr7jsp4Ag642w7J207YSwXHJcbiAgICAgKiBAcGFyYW0gcEVuZENhbGxiYWNrIO2VqOyImOyymOumrCDtm4Qg7Zi47Lac65CgIOy9nOuwse2VqOyImFxyXG4gICAgICovXHJcbiAgICBfdGhpc1tcIkZpbmRBcmVhRnJvbUltYWdlXCJdID0gZnVuY3Rpb24oc3JjLCBwRW5kQ2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLm1fcEVuZENhbGxiYWNrID0gcEVuZENhbGxiYWNrO1xyXG4gICAgICAgIGNvbnN0IHNlbGVjdGVkSW1nID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgJChzZWxlY3RlZEltZylbXCJjc3NcIl0oXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcclxuICAgICAgICAkKHNlbGVjdGVkSW1nKS5hdHRyKFwic3JjXCIsIHNyYyk7XHJcbiAgICAgICAgY29uc3Qgb1RoaXMgPSB0aGlzO1xyXG4gICAgICAgICQoc2VsZWN0ZWRJbWcpLm9uKFwibG9hZFwiLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEhEKDEyODAqNzIwKeyXkCDqt7zsoJHtlZjqsowg7J2066+47KeAIOyCrOydtOymiCDrs7TsoJUgKOq4tCDrqbTsnbQgMTI4MCDsgqzsnbTspojroZwg7ISk7KCV65CY64+E66GdIO2VqClcclxuICAgICAgICAgICAgY29uc3QgYkxhbmRzY2FwZSA9IHNlbGVjdGVkSW1nLndpZHRoID4gc2VsZWN0ZWRJbWcuaGVpZ2h0O1xyXG4gICAgICAgICAgICBjb25zdCBuUmF0aW8gPSAxMjgwIC8gKGJMYW5kc2NhcGUgPyBzZWxlY3RlZEltZy53aWR0aCA6IHNlbGVjdGVkSW1nLmhlaWdodCk7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkSW1nLndpZHRoICo9IG5SYXRpbztcclxuICAgICAgICAgICAgc2VsZWN0ZWRJbWcuaGVpZ2h0ICo9IG5SYXRpbztcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGxldCBwSGlkZGVuQ2FudmFzID0gbnVsbDtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGltZ0NhcmQgPSBzZWxlY3RlZEltZztcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5EUEkgPSBvVGhpcy5tX25EUEk7XHJcbiAgICAgICAgICAgICAgICBvVGhpcy5tX3BUYXJnZXRNYXQgPSBjdltcImltcmVhZFwiXShpbWdDYXJkKTtcclxuICAgICAgICAgICAgICAgIG9UaGlzLm1fcFJlY29nbml0aW9uUGFjayA9IG5ldyBPWlJlY29nbml0aW9uUGFjayhPWlJlY29nbml0aW9uUGFjay5NT0RFX0lEKTtcclxuICAgICAgICAgICAgICAgIG9UaGlzLm1fcFJlY29nbml0aW9uUGFjay5TZXRSZXN1bHRNaW1lVHlwZShvVGhpcy5tX3N0ck1pbWVUeXBlKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgcEhpZGRlbkNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XHJcbiAgICAgICAgICAgICAgICBwSGlkZGVuQ2FudmFzLndpZHRoID0gaW1nQ2FyZC53aWR0aDtcclxuICAgICAgICAgICAgICAgIHBIaWRkZW5DYW52YXMuaGVpZ2h0ID0gaW1nQ2FyZC5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwQ3R4ID0gcEhpZGRlbkNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgb1RoaXMuc2V0U2NhbkFyZWEoc2VsZWN0ZWRJbWcud2lkdGgsIHNlbGVjdGVkSW1nLmhlaWdodCk7XHJcblxyXG4gICAgICAgICAgICAgICAgcEN0eC5kcmF3SW1hZ2UoaW1nQ2FyZCwgMCwgMCwgaW1nQ2FyZC53aWR0aCwgaW1nQ2FyZC5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgb1RoaXMubV9wVGFyZ2V0TWF0LmRhdGEuc2V0KHBDdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGltZ0NhcmQud2lkdGgsIGltZ0NhcmQuaGVpZ2h0KS5kYXRhKTtcclxuICAgICAgICAgICAgICAgIGlmIChvVGhpcy5tX3BSZWNvZ25pdGlvblBhY2suRmluZEFyZWEobkRQSSwgcEhpZGRlbkNhbnZhcywgb1RoaXMubV9wVGFyZ2V0TWF0LCBvVGhpcy5tX3BQYXBlckluZm8sIFxyXG4gICAgICAgICAgICAgICAgICAgIG9UaGlzLm1fcFNjYW5BcmVhLCBvVGhpcy5tX3BTY2FuQXJlYUNlbnRlclBvaW50LCBvVGhpcy5tX25TY2FuV2lkdGgsIG9UaGlzLm1fblNjYW5IZWlnaHQsIGZhbHNlLCBmYWxzZSkgPT0gOTk5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb1RoaXMubV9wRW5kQ2FsbGJhY2sodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICQoc2VsZWN0ZWRJbWcpW1wiY3NzXCJdKFwiZGlzcGxheVwiLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICBvVGhpcy5tX3BFbmRDYWxsYmFjayhmYWxzZSwgc2VsZWN0ZWRJbWcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb1RoaXMubV9wVGFyZ2V0TWF0LmRlbGV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgb1RoaXMubV9wVGFyZ2V0TWF0ID0gbnVsbDtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgT1pSZWNvZ25pdGlvblBhY2tbXCJ0cmFjZVwiXShlKTtcclxuICAgICAgICAgICAgICAgICQoc2VsZWN0ZWRJbWcpW1wiY3NzXCJdKFwiZGlzcGxheVwiLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgIG9UaGlzLm1fcEVuZENhbGxiYWNrKGZhbHNlLCBzZWxlY3RlZEltZyk7XHJcbiAgICAgICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob1RoaXMubV9wVGFyZ2V0TWF0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb1RoaXMubV9wVGFyZ2V0TWF0LmRlbGV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIG9UaGlzLm1fcFRhcmdldE1hdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAkKHBIaWRkZW5DYW52YXMpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgJChzZWxlY3RlZEltZykucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAkKGRvY3VtZW50LmJvZHkpLmFwcGVuZChzZWxlY3RlZEltZyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBQcmV2aWV3IO2BrOq4sOulvCDsnqzshKTsoJXtlZjripQg7ZWo7IiYXHJcbiAgICAgKiBAcGFyYW0gbkNvbnRlbnRzV2lkdGgg64SI67mEXHJcbiAgICAgKiBAcGFyYW0gbkNvbnRlbnRzSGVpZ2h0IOuGkuydtFxyXG4gICAgICovXHJcbiAgICBfdGhpc1tcIlVwZGF0ZVByZXZpZXdTaXplXCJdID0gZnVuY3Rpb24obkNvbnRlbnRzV2lkdGgsIG5Db250ZW50c0hlaWdodCkge1xyXG4gICAgICAgICQodGhpcy5tX215VUkpW1wiY3NzXCJdKFwid2lkdGhcIiwgbkNvbnRlbnRzV2lkdGgpO1xyXG4gICAgICAgICQodGhpcy5tX215VUkpW1wiY3NzXCJdKFwiaGVpZ2h0XCIsIG5Db250ZW50c0hlaWdodCk7XHJcblxyXG4gICAgICAgIGxldCBtYXJnaW4gPSAwO1xyXG4gICAgICAgIGlmIChuQ29udGVudHNXaWR0aCA+IG5Db250ZW50c0hlaWdodCkge1xyXG4gICAgICAgICAgICBtYXJnaW4gPSBuQ29udGVudHNXaWR0aCAqIDAuMDU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbWFyZ2luID0gbkNvbnRlbnRzSGVpZ2h0ICogMC4wNTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBuV2lkdGggPSBuQ29udGVudHNXaWR0aCAtIG1hcmdpbjtcclxuICAgICAgICBsZXQgbkhlaWdodCA9IG5Db250ZW50c0hlaWdodCAtIG1hcmdpbjtcclxuXHJcbiAgICAgICAgdGhpcy5tX25Db250ZW50c1dpZHRoID0gbldpZHRoO1xyXG4gICAgICAgIHRoaXMubV9uQ29udGVudHNIZWlnaHQgPSBuSGVpZ2h0O1xyXG5cclxuICAgICAgICBjb25zdCBwQ2FyZFByZXZpZXdXcmFwcGluZ0RpdiA9ICQodGhpcy5tX215VUkpLmNoaWxkcmVuKFwiZGl2XCIpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHBDYXJkUHJldmlld1dyYXBwaW5nRGl2W1wiY3NzXCJdKFwid2lkdGhcIiwgTWF0aC5mbG9vcihuV2lkdGgpKTtcclxuICAgICAgICBwQ2FyZFByZXZpZXdXcmFwcGluZ0RpdltcImNzc1wiXShcImhlaWdodFwiLCBNYXRoLmZsb29yKG5IZWlnaHQpKTtcclxuXHJcbiAgICAgICAgbldpZHRoID0gTWF0aC5jZWlsKG5XaWR0aCk7XHJcbiAgICAgICAgbkhlaWdodCA9IE1hdGguY2VpbChuSGVpZ2h0KTtcclxuXHJcbiAgICAgICAgJCh0aGlzLm1fcFZpZGVvKVtcImNzc1wiXShcIndpZHRoXCIsIG5XaWR0aClcclxuICAgICAgICAgICAgW1wiY3NzXCJdKFwiaGVpZ2h0XCIsIG5IZWlnaHQpO1xyXG4gICAgICAgICQodGhpcy5tX3BHdWlkZVJlY3RPdmVybGF5KVtcImNzc1wiXShcIndpZHRoXCIsIG5XaWR0aClcclxuICAgICAgICAgICAgW1wiY3NzXCJdKFwiaGVpZ2h0XCIsIG5IZWlnaHQpO1xyXG4gICAgICAgICQodGhpcy5tX3BHdWlkZU1hc2tPdmVybGF5KVtcImNzc1wiXShcIndpZHRoXCIsIG5XaWR0aClcclxuICAgICAgICAgICAgW1wiY3NzXCJdKFwiaGVpZ2h0XCIsIG5IZWlnaHQpO1xyXG5cclxuICAgICAgICB0aGlzLm1fcEd1aWRlUmVjdE92ZXJsYXkud2lkdGggPSBuV2lkdGg7XHJcbiAgICAgICAgdGhpcy5tX3BHdWlkZVJlY3RPdmVybGF5LmhlaWdodCA9IG5IZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5tX3BHdWlkZU1hc2tPdmVybGF5LndpZHRoID0gbldpZHRoO1xyXG4gICAgICAgIHRoaXMubV9wR3VpZGVNYXNrT3ZlcmxheS5oZWlnaHQgPSBuSGVpZ2h0O1xyXG5cclxuICAgICAgICB0aGlzLmRyYXdHdWlkZVJlY3QoMCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog66eI7Iqk7YGsIOyymOumrCDsoIQg7J2066+47KeAIOuNsOydtO2EsCDrsJjtmZhcclxuICAgICAqL1xyXG4gICAgX3RoaXNbXCJHZXRVbm1hc2tlZEltYWdlXCJdID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubV9wUmVjb2duaXRpb25QYWNrLkdldFByZXByb2Nlc3NpbmdJbWFnZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog66eI7Iqk7YGsIOyymOumrCDtm4Qg7J2066+47KeAIOuNsOydtO2EsCDrsJjtmZhcclxuICAgICAqL1xyXG4gICAgX3RoaXNbXCJHZXRNYXNrZWRJbWFnZVwiXSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1fcFJlY29nbml0aW9uUGFjay5HZXRQb3N0cHJvY2Vzc2luZ0ltYWdlKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog7Iqk7LqUIOydtOuvuOyngCBNSU1FIO2DgOyehSDshKTsoJVcclxuICAgICAqL1xyXG4gICAgIF90aGlzW1wiU2V0UmVzdWx0TWltZVR5cGVcIl0gPSBmdW5jdGlvbihzdHJNaW1lVHlwZSkge1xyXG4gICAgICAgIHRoaXMubV9zdHJNaW1lVHlwZSA9IHN0ck1pbWVUeXBlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOyKpOy6lCDsnbTrr7jsp4AgTUlNRSDtg4DsnoUg67CY7ZmYXHJcbiAgICAgKi9cclxuICAgIF90aGlzW1wiR2V0UmVzdWx0TWltZVR5cGVcIl0gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tX3BSZWNvZ25pdGlvblBhY2suR2V0UmVzdWx0TWltZVR5cGUoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDtlITrpqzrt7Dsp4Dsm5Dsl6zrtoAg7LK07YGs7ZWY7JesIOyngOybkCDsi5wgcFByZXZpZXdDYWxsYmFja+ydhCDtmLjstpztlZjqs6Ag7KeA7JuQ7JWI7ZWY66m0IEZpbmRBcmVhRnJvbUZpbGXsnYQg7Zi47Lac7ZWY64qUIO2VqOyImFxyXG4gICAgICogQHBhcmFtIHBFbmRDYWxsYmFjayDtlajsiJjsspjrpqwg7ZuEIO2YuOy2nOuQoCDsvZzrsLHtlajsiJhcclxuICAgICAqIEBwYXJhbSBwUHJldmlld0NhbGxiYWNrIOuvuOumrOuztOq4sCDsp4Dsm5Ag7IucIO2YuOy2nO2VoCDsvZzrsLHtlajsiJhcclxuICAgICAqL1xyXG4gICAgX3RoaXNbXCJJc1N1cHBvcnRQcmV2aWV3XCJdID0gZnVuY3Rpb24ocEVuZENhbGxiYWNrLCBwUHJldmlld0NhbGxiYWNrKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGxvY2F0aW9uLnByb3RvY29sICE9PSBcImh0dHBzOlwiIHx8ICh0eXBlb2YgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyA9PSBcInVuZGVmaW5lZFwiKSkge1xyXG4gICAgICAgICAgICBPWlJlY29nbml0aW9uUGFja1tcInRyYWNlXCJdKFwiQ3VycmVudCBwcm90b2NvbCBpcyBcIiArIGxvY2F0aW9uLnByb3RvY29sKTtcclxuICAgICAgICAgICAgLy8gbm8gcHJldmlld1xyXG4gICAgICAgICAgICB0aGlzW1wiRmluZEFyZWFGcm9tRmlsZVwiXShwRW5kQ2FsbGJhY2spO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBvVGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGRldmljZXMpIHtcclxuICAgICAgICAgICAgICAgIGxldCBiRW5hYmxlUHJldmlldyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZGV2aWNlcy5mb3JFYWNoKGZ1bmN0aW9uKGRldmljZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXZpY2VbXCJraW5kXCJdW1wic3RhcnRzV2l0aFwiXShcInZpZGVvXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJFbmFibGVQcmV2aWV3ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICBpZiAoYkVuYWJsZVByZXZpZXcpIHsgLy8gcHJldmlld1xyXG4gICAgICAgICAgICAgICAgICAgIHBQcmV2aWV3Q2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIG5vIHByZXZpZXdcclxuICAgICAgICAgICAgICAgICAgICBvVGhpc1tcIkZpbmRBcmVhRnJvbUZpbGVcIl0ocEVuZENhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog67mE65SU7JikIOy1nOyGjCDtlbTsg4Hrj4Trpbwg7ISk7KCV7ZWY64qUIO2VqOyImFxyXG4gICAgICogQHBhcmFtIHdpZHRoIOy1nOyGjCDrhIjruYRcclxuICAgICAqIEBwYXJhbSBoZWlnaHQg7LWc7IaMIOuGkuydtFxyXG4gICAgICovXHJcbiAgICBfdGhpc1tcIlNldFZpZGVvTWluUmVzb2x1dGlvblwiXSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBpZiAoaXNOYU4od2lkdGgpIHx8IGlzTmFOKGhlaWdodCkpIHtcclxuICAgICAgICAgICAgT1pSZWNvZ25pdGlvblBhY2tbXCJ0cmFjZVwiXShcIkludmFsaWQgUmVzb2x1dGlvbiBWYWx1ZVwiKTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBSZXNvbHV0aW9uIFZhbHVlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB0aGlzLm1fblZpZGVvTWluV2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLm1fblZpZGVvTWluSGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfdGhpc1tcIlNldEZvcmNlQ2FwdHJ1ZVwiXSA9IGZ1bmN0aW9uKGIpIHtcclxuICAgICAgICB0aGlzLm1fYkZvcmNlQ2FwdHVyZSA9IGI7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBfdGhpc1tcIlNldFNob3dNYXNrR3VpZGVcIl0gPSBmdW5jdGlvbihiKSB7XHJcbiAgICAgICAgdGhpcy5tX2JTaG93TWFza0d1aWRlID0gYjtcclxuICAgIH07XHJcblxyXG4gICAgX3RoaXNbXCJTZXRKU09OSW5mb1wiXSA9IGZ1bmN0aW9uKG9iaklESW5mbykge1xyXG4gICAgICAgIGlmICghb2JqSURJbmZvW1wic2l6ZVwiXSkgeyAvLyBzaXplIChyZXF1aXJlZClcclxuICAgICAgICAgICAgT1pSZWNvZ25pdGlvblBhY2tbXCJ0cmFjZVwiXShcIlRoZSBzaXplIHByb3BlcnR5IGlzIG1pc3NpbmcuXCIpO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoT1pDYXJkUHJldmlld1tcIklOVkFMSURfU0laRV9QUk9QXCJdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHNpemUgPSBvYmpJREluZm9bXCJzaXplXCJdLnNwbGl0KFwieFwiKTtcclxuICAgICAgICBjb25zdCBjaGVja05hTiA9IGZ1bmN0aW9uKGFycikge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8YXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oYXJyW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIE9aUmVjb2duaXRpb25QYWNrW1widHJhY2VcIl0oXCJUaGUgc2l6ZSBwcm9wZXJ0eSB2YWx1ZSBjYW4ndCBiZSBOYU5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKE9aQ2FyZFByZXZpZXdbXCJJTlZBTElEX1NJWkVfUFJPUFwiXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzaXplLmxlbmd0aCAhPSAyKSB7XHJcbiAgICAgICAgICAgIE9aUmVjb2duaXRpb25QYWNrW1widHJhY2VcIl0oXCJUaGUgc2l6ZSBwcm9wZXJ0eSBjYW4ndCBiZSBzcGxpdCBpbnRvIDIuXCIpO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoT1pDYXJkUHJldmlld1tcIklOVkFMSURfU0laRV9QUk9QXCJdKTtcclxuICAgICAgICB9IFxyXG4gICAgICAgIGNoZWNrTmFOKHNpemUpO1xyXG5cclxuICAgICAgICBjb25zdCBvYmpQYXBlciA9IHt9O1xyXG5cclxuICAgICAgICAvLyBjbSAtPiBtbVxyXG4gICAgICAgIG9ialBhcGVyLnNpemVXaWR0aCA9IHNpemVbMF0gLyAxMDtcclxuICAgICAgICBvYmpQYXBlci5zaXplSGVpZ2h0ID0gc2l6ZVsxXSAvIDEwO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGxldCBtYXJnaW47XHJcbiAgICAgICAgLy8gbWFyZ2luIChvcHRpb25hbClcclxuICAgICAgICBpZiAoIW9iaklESW5mb1tcIm1hcmdpblwiXSkge1xyXG4gICAgICAgICAgICBtYXJnaW4gPSAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChpc05hTihvYmpJREluZm9bXCJtYXJnaW5cIl0pKSB7XHJcbiAgICAgICAgICAgICAgICBPWlJlY29nbml0aW9uUGFja1tcInRyYWNlXCJdKFwiVGhlIG1hcmdpbiBwcm9wZXJ0eSB2YWx1ZSBjYW4ndCBiZSBOYU4uXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKE9aQ2FyZFByZXZpZXdbXCJJTlZBTElEX01BUkdJTl9QUk9QXCJdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtYXJnaW4gPSBvYmpJREluZm9bXCJtYXJnaW5cIl0gLyAxMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG9ialBhcGVyLnNpemVNYXJnaW4gPSBtYXJnaW47XHJcbiAgICAgICAgb2JqUGFwZXIuaXRlbSA9IFtdO1xyXG5cclxuICAgICAgICAvLyBtYXNrIChvcHRpb25hbClcclxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8b2JqSURJbmZvW1wibWFza1wiXS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBhcnIgPSBvYmpJREluZm9bXCJtYXNrXCJdW2ldW1wiYXJlYVwiXS5zcGxpdChcIixcIik7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoYXJyLmxlbmd0aCA9PSA0KSB7XHJcbiAgICAgICAgICAgICAgICBjaGVja05hTihhcnIpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWFza0FyZWEgPSB7fTtcclxuICAgICAgICAgICAgICAgIG1hc2tBcmVhLmxlZnQgPSBhcnJbMF0gLyAxMDtcclxuICAgICAgICAgICAgICAgIG1hc2tBcmVhLnRvcCA9IGFyclsxXSAvIDEwO1xyXG4gICAgICAgICAgICAgICAgbWFza0FyZWEud2lkdGggPSBhcnJbMl0gLyAxMDtcclxuICAgICAgICAgICAgICAgIG1hc2tBcmVhLmhlaWdodCA9IGFyclszXSAvIDEwO1xyXG4gICAgICAgICAgICAgICAgb2JqUGFwZXIuaXRlbS5wdXNoKG1hc2tBcmVhKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIE9aUmVjb2duaXRpb25QYWNrW1widHJhY2VcIl0oXCJUaGUgbWFzayBwcm9wZXJ0eSBjYW4ndCBiZSBzcGxpdCBpbnRvIDQuXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKE9aQ2FyZFByZXZpZXdbXCJJTlZBTElEX01BU0tfUFJPUFwiXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tX3BQYXBlckluZm8gPSBvYmpQYXBlcjtcclxuICAgIH07XHJcbn07XHJcblxyXG5PWkNhcmRQcmV2aWV3W1wiSU5WQUxJRF9TSVpFX1BST1BcIl0gPSAwO1xyXG5PWkNhcmRQcmV2aWV3W1wiSU5WQUxJRF9NQVJHSU5fUFJPUFwiXSA9IDE7XHJcbk9aQ2FyZFByZXZpZXdbXCJJTlZBTElEX01BU0tfUFJPUFwiXSA9IDI7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/OZCardPreview.js\n");

/***/ }),

/***/ "./src/OZCardRecognizer.js":
/*!*********************************!*\
  !*** ./src/OZCardRecognizer.js ***!
  \*********************************/
/***/ (() => {

eval("const OZCardRecognizer = window[\"OZCardRecognizer\"] = function() {\r\n    const _this = OZCardRecognizer.prototype;\r\n\r\n    _this.ready = function(pHiddenCanvas, targetMat, pScanArea, pScanAreaCenterPoint, bIsPreview) {\r\n        this.m_algorithm = 0;\r\n        this.m_pHiddenCanvas = pHiddenCanvas;\r\n        this.m_pScanArea = pScanArea;\r\n        this.m_pScanAreaCenterPoint = pScanAreaCenterPoint;\r\n        this.m_bIsPreview = bIsPreview;\r\n\r\n        this.m_foundRect = [];\r\n        this.m_imageMat = new cv[\"Mat\"]();\r\n        cv[\"pyrDown\"](targetMat, this.m_imageMat, new cv[\"Size\"](0, 0), cv[\"BORDER_DEFAULT\"]);\r\n        cv[\"pyrDown\"](this.m_imageMat, this.m_imageMat, new cv[\"Size\"](0, 0), cv[\"BORDER_DEFAULT\"]);\r\n        this.m_nScale = 0.25;\r\n        this.m_blurMat = new cv[\"Mat\"]();\r\n\r\n        return true;\r\n    };\r\n\r\n    _this.dispose = function() {\r\n        if (this.m_blurMat) {\r\n            this.m_blurMat[\"delete\"]();\r\n            this.m_blurMat = null;\r\n        }\r\n        if (this.m_imageMat) {\r\n            this.m_imageMat[\"delete\"]();\r\n            this.m_imageMat = null;\r\n        }\r\n        this.m_pHiddenCanvas = null;\r\n        this.m_foundRect = null;\r\n    };\r\n\r\n    _this.find = function(nFindCount) {\r\n    \tthis.m_algorithm =  nFindCount % 3;\r\n\r\n    \tvar bIsFind = false;\r\n    \tif (!this.m_bIsPreview) {\r\n    \t\tbIsFind = this.thirdFind();\r\n    \t\tif (!bIsFind) bIsFind = this.firstFind();\r\n            if (!bIsFind) bIsFind = this.secondFind();\r\n    \t}else {\r\n\t\t\tif (this.m_algorithm == 0) {\r\n\t\t\t\tbIsFind = this.firstFind();\r\n\t\t\t} else if (this.m_algorithm == 1) {\r\n\t\t\t\tbIsFind = this.secondFind();\r\n\t\t\t} else {\r\n                bIsFind = this.thirdFind();\r\n            }\r\n    \t}\r\n    \treturn bIsFind;\r\n    };\r\n\r\n    this.firstFind = function() {\r\n    \tcv[\"GaussianBlur\"](this.m_imageMat, this.m_blurMat, new cv[\"Size\"](5, 5), 0.1);\r\n    \treturn this.__find();\r\n    }\r\n\r\n    this.secondFind = function() {\r\n    \tcv[\"GaussianBlur\"](this.m_imageMat, this.m_blurMat, new cv[\"Size\"](9, 9), 4.0);\r\n    \treturn this.__find();\r\n    }\r\n\r\n    this.thirdFind = function() {\r\n        let rrr = this.m_imageMat.rows;\r\n        let ccc = this.m_imageMat.cols;\r\n\r\n        if (rrr > 200 || ccc > 200) {\r\n            cv[\"pyrDown\"](this.m_imageMat, this.m_imageMat, new cv[\"Size\"](0, 0), cv[\"BORDER_DEFAULT\"]);\r\n\t\t\tthis.m_nScale = 0.125;\r\n\t\t\trrr = this.m_imageMat.rows;\r\n\t\t\tccc = this.m_imageMat.cols;\r\n\t\t}\r\n\r\n        const bgdModel = new cv[\"Mat\"]();\r\n        const fgdModel = new cv[\"Mat\"]();\r\n        const rect = new cv[\"Rect\"](ccc / 40, rrr/ 40, ccc - ccc / 40, rrr - rrr / 40);\r\n\r\n        cv[\"cvtColor\"](this.m_imageMat, this.m_imageMat, cv[\"COLOR_RGBA2RGB\"], 0);\r\n\t\tcv[\"grabCut\"](this.m_imageMat, this.m_blurMat, rect, bgdModel, fgdModel, 1, cv[\"GC_INIT_WITH_RECT\"]);\r\n\t\tcv[\"convertScaleAbs\"](this.m_blurMat, this.m_blurMat, 100, 0);\r\n\t\tcv[\"threshold\"](this.m_blurMat, this.m_blurMat, 200, 255, cv[\"THRESH_BINARY\"]);\r\n\r\n        return this.__find();\r\n\t}\r\n\r\n    _this.findPoint = function(pt, rect) {\r\n        if (pt.x <= (rect.x + rect.width) && pt.x >= rect.x\r\n            && pt.y <= (rect.y + rect.height) && pt.y >= rect.y) {\r\n            return 1;\r\n        }\r\n        return -1;\r\n    };\r\n\r\n    _this.filterRect = function(rr, contour, filtered) {\r\n        const pts = cv[\"RotatedRect\"][\"points\"](rr);\r\n        \r\n        let started = false;\r\n        for(let i=0;i < contour.length; i+=2) {\r\n            let pt = {}\r\n            pt[\"x\"] = contour[i];\r\n            pt[\"y\"] = contour[i+1];\r\n            if(this.inside(pt, pts)) {\r\n                filtered.push(pt);\r\n                if(!started) {\r\n                    started = true; \r\n                }\r\n            }\r\n        }\r\n        return started;\r\n    };\r\n    \r\n    _this.__find = function() {\r\n        let canny;\r\n        let contours;\r\n        let hierarchy;\r\n        let hull;\r\n        let tmp_pts;\r\n        try {\r\n            canny = new cv[\"Mat\"]();\r\n            cv[\"Canny\"](this.m_blurMat, canny, 40, 40);\r\n\r\n            contours = new cv[\"MatVector\"]();\r\n            hierarchy = new cv[\"Mat\"]();\r\n            cv[\"findContours\"](canny, contours, hierarchy, cv[\"RETR_EXTERNAL\"], cv[\"CHAIN_APPROX_NONE\"]);\r\n    \r\n            for (let i=0; i<contours[\"size\"](); i++) {\r\n                let contour = contours[\"get\"](i);\r\n                let approxCurve = new cv[\"Mat\"]();\r\n                const perimeter = cv[\"arcLength\"](contour, false);\r\n                if (perimeter < 150) continue;\r\n                \r\n                cv[\"approxPolyDP\"](contour, approxCurve, perimeter * 0.02, true);\r\n                if (!cv[\"isContourConvex\"](approxCurve)) {\r\n                    continue;\r\n                }\r\n                \r\n                if (approxCurve[\"data32S\"].length == 8) {\r\n                    const rotatedRect = cv[\"minAreaRect\"](contour);\r\n                    const rrpts = cv[\"RotatedRect\"][\"points\"](rotatedRect);\r\n                    const targetRect = this.fillterRect(rrpts);\r\n\r\n                    let bFound = true;\r\n                    if (this.m_bIsPreview) {\r\n                        for(let c=0; c < this.m_pScanArea.length; c++) {\r\n                            const foundIndex = this.findPoint(targetRect[c], this.m_pScanArea[c]);\r\n                            if (foundIndex < 0) {\r\n                                bFound = false;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if(bFound) {\r\n                        const rpts = [];\r\n                        rpts.push(new cv[\"Point\"](approxCurve[\"data32S\"][0], approxCurve[\"data32S\"][1]));\r\n                        rpts.push(new cv[\"Point\"](approxCurve[\"data32S\"][2], approxCurve[\"data32S\"][3]));\r\n                        rpts.push(new cv[\"Point\"](approxCurve[\"data32S\"][4], approxCurve[\"data32S\"][5]));\r\n                        rpts.push(new cv[\"Point\"](approxCurve[\"data32S\"][6], approxCurve[\"data32S\"][7]));\r\n                        this.m_foundRect = this.fillterRect(rpts);\r\n\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            this.m_foundRect = [];\r\n        } finally {\r\n            if (canny) canny[\"delete\"]();\r\n            if (contours) contours[\"delete\"]();\r\n            if (hierarchy) hierarchy[\"delete\"]();\r\n            if (hull) hull[\"delete\"]();\r\n\r\n            if (tmp_pts) tmp_pts[\"delete\"]();\r\n        }\r\n\r\n        return false;\r\n    };\r\n\r\n    _this.fillterRect = function(rrpts) {\r\n        // points sorting \r\n        let minDist = 99999;\r\n        let idxs = [0, 1, 2, 3];\r\n        let nLeftTop = 0;\r\n        let nRightTop = 0;\r\n        let nRightBottom = 0;\r\n        let nLeftBottom = 0;\r\n\r\n        for (let i=0; i < rrpts.length; i++) {\r\n            let dist = this.getDistance(0, 0, rrpts[i].x, rrpts[i].y);\r\n            if (minDist > dist) {\r\n                minDist = dist;\r\n                nLeftTop = i;\r\n            }\r\n        }\r\n        idxs.splice(idxs.indexOf(nLeftTop), 1);\r\n\r\n        let nMinX = 99999;\r\n        let nMinY = 99999;\r\n\r\n        for (let i=0; i < idxs.length; i++) {\r\n            const idx = idxs[i];\r\n            if (rrpts[idx].x < nMinX) {\r\n                nMinX = rrpts[idx].x;\r\n                nLeftBottom = idx;\r\n            }\r\n            if (rrpts[idx].y < nMinY) {\r\n                nMinY = rrpts[idx].y;\r\n                nRightTop = idx;\r\n            }\r\n        }\r\n\r\n        idxs.splice(idxs.indexOf(nLeftBottom), 1);\r\n        idxs.splice(idxs.indexOf(nRightTop), 1);\r\n\r\n        nRightBottom = idxs[0];\r\n\r\n        const sorted = [];\r\n        sorted.push(new cv[\"Point\"](this.scale(rrpts[nLeftTop].x), this.scale(rrpts[nLeftTop].y)));\r\n        sorted.push(new cv[\"Point\"](this.scale(rrpts[nRightTop].x), this.scale(rrpts[nRightTop].y)));\r\n        sorted.push(new cv[\"Point\"](this.scale(rrpts[nRightBottom].x), this.scale(rrpts[nRightBottom].y)));\r\n        sorted.push(new cv[\"Point\"](this.scale(rrpts[nLeftBottom].x), this.scale(rrpts[nLeftBottom].y)));\r\n\r\n        return sorted;\r\n    };\r\n\r\n    _this.scale = function(num) {\r\n        return num / this.m_nScale;\r\n    };\r\n\r\n    _this.getDistance = function(x1, y1, x2, y2) {\r\n        const dx = x2 - x1;\r\n        const dy = y2 - y1;\r\n        return Math.sqrt(dx * dx + dy * dy);\r\n    };\r\n\r\n    _this.cm2px = function(nDpi, cm) {\r\n        return parseInt(cm / 2.54 * nDpi);\r\n    };\r\n\r\n    _this.copyRectangle = function(targetMat, rectangle, width, height, marginL = 0, marginT = 0) {\r\n        const marginR = marginL;\r\n        const marginB = marginT;\r\n\r\n        let result = new cv[\"Mat\"][\"zeros\"](height, width, cv[\"CV_8UC3\"]);\r\n\r\n        let srcQuad = null;\r\n        let dstQuad = null;\r\n        try {\r\n            srcQuad = cv[\"matFromArray\"](4, 1, cv[\"CV_32FC2\"], [ // crop할 영역\r\n                rectangle[0].x, rectangle[0].y, \r\n                rectangle[1].x, rectangle[1].y,\r\n                rectangle[3].x, rectangle[3].y,\r\n                rectangle[2].x, rectangle[2].y\r\n            ]);\r\n    \r\n            dstQuad = cv[\"matFromArray\"](4, 1, cv[\"CV_32FC2\"], [ // dsize crop 결과물 크기\r\n                0  - marginL, 0 - marginT, \r\n                width  + marginR, 0 - marginT,\r\n                0 - marginL, height + marginB,\r\n                width + marginR, height + marginB\r\n            ]);\r\n    \r\n            const warpMatix = cv[\"getPerspectiveTransform\"](srcQuad, dstQuad);\r\n            cv[\"warpPerspective\"](targetMat, result, warpMatix, new cv[\"Size\"](width, height));\r\n        } finally {\r\n            srcQuad.delete();\r\n            srcQuad = null;\r\n            dstQuad.delete();\r\n            dstQuad = null;\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    _this.capture = function(targetMat, width, height, marginLeft, marginTop) {\r\n        return this.copyRectangle(targetMat, this.m_foundRect, width, height, -marginLeft, -marginTop);\r\n    };\r\n\r\n   _this.forceCapture = function(targetMat, width, height) {\r\n        return this.copyRectangle(targetMat, this.m_pScanAreaCenterPoint, width, height);\r\n    };\r\n\r\n    _this.setCheckSize = function(value) {\r\n        this.m_nCheckSize = value;\r\n    };\r\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvT1pDYXJkUmVjb2duaXplci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsNkJBQTZCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9PWlNlYWxSZWNvZ25pdGlvbi8uL3NyYy9PWkNhcmRSZWNvZ25pemVyLmpzP2Q4MzMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgT1pDYXJkUmVjb2duaXplciA9IHdpbmRvd1tcIk9aQ2FyZFJlY29nbml6ZXJcIl0gPSBmdW5jdGlvbigpIHtcclxuICAgIGNvbnN0IF90aGlzID0gT1pDYXJkUmVjb2duaXplci5wcm90b3R5cGU7XHJcblxyXG4gICAgX3RoaXMucmVhZHkgPSBmdW5jdGlvbihwSGlkZGVuQ2FudmFzLCB0YXJnZXRNYXQsIHBTY2FuQXJlYSwgcFNjYW5BcmVhQ2VudGVyUG9pbnQsIGJJc1ByZXZpZXcpIHtcclxuICAgICAgICB0aGlzLm1fYWxnb3JpdGhtID0gMDtcclxuICAgICAgICB0aGlzLm1fcEhpZGRlbkNhbnZhcyA9IHBIaWRkZW5DYW52YXM7XHJcbiAgICAgICAgdGhpcy5tX3BTY2FuQXJlYSA9IHBTY2FuQXJlYTtcclxuICAgICAgICB0aGlzLm1fcFNjYW5BcmVhQ2VudGVyUG9pbnQgPSBwU2NhbkFyZWFDZW50ZXJQb2ludDtcclxuICAgICAgICB0aGlzLm1fYklzUHJldmlldyA9IGJJc1ByZXZpZXc7XHJcblxyXG4gICAgICAgIHRoaXMubV9mb3VuZFJlY3QgPSBbXTtcclxuICAgICAgICB0aGlzLm1faW1hZ2VNYXQgPSBuZXcgY3ZbXCJNYXRcIl0oKTtcclxuICAgICAgICBjdltcInB5ckRvd25cIl0odGFyZ2V0TWF0LCB0aGlzLm1faW1hZ2VNYXQsIG5ldyBjdltcIlNpemVcIl0oMCwgMCksIGN2W1wiQk9SREVSX0RFRkFVTFRcIl0pO1xyXG4gICAgICAgIGN2W1wicHlyRG93blwiXSh0aGlzLm1faW1hZ2VNYXQsIHRoaXMubV9pbWFnZU1hdCwgbmV3IGN2W1wiU2l6ZVwiXSgwLCAwKSwgY3ZbXCJCT1JERVJfREVGQVVMVFwiXSk7XHJcbiAgICAgICAgdGhpcy5tX25TY2FsZSA9IDAuMjU7XHJcbiAgICAgICAgdGhpcy5tX2JsdXJNYXQgPSBuZXcgY3ZbXCJNYXRcIl0oKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG5cclxuICAgIF90aGlzLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5tX2JsdXJNYXQpIHtcclxuICAgICAgICAgICAgdGhpcy5tX2JsdXJNYXRbXCJkZWxldGVcIl0oKTtcclxuICAgICAgICAgICAgdGhpcy5tX2JsdXJNYXQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5tX2ltYWdlTWF0KSB7XHJcbiAgICAgICAgICAgIHRoaXMubV9pbWFnZU1hdFtcImRlbGV0ZVwiXSgpO1xyXG4gICAgICAgICAgICB0aGlzLm1faW1hZ2VNYXQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1fcEhpZGRlbkNhbnZhcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tX2ZvdW5kUmVjdCA9IG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIF90aGlzLmZpbmQgPSBmdW5jdGlvbihuRmluZENvdW50KSB7XHJcbiAgICBcdHRoaXMubV9hbGdvcml0aG0gPSAgbkZpbmRDb3VudCAlIDM7XHJcblxyXG4gICAgXHR2YXIgYklzRmluZCA9IGZhbHNlO1xyXG4gICAgXHRpZiAoIXRoaXMubV9iSXNQcmV2aWV3KSB7XHJcbiAgICBcdFx0YklzRmluZCA9IHRoaXMudGhpcmRGaW5kKCk7XHJcbiAgICBcdFx0aWYgKCFiSXNGaW5kKSBiSXNGaW5kID0gdGhpcy5maXJzdEZpbmQoKTtcclxuICAgICAgICAgICAgaWYgKCFiSXNGaW5kKSBiSXNGaW5kID0gdGhpcy5zZWNvbmRGaW5kKCk7XHJcbiAgICBcdH1lbHNlIHtcclxuXHRcdFx0aWYgKHRoaXMubV9hbGdvcml0aG0gPT0gMCkge1xyXG5cdFx0XHRcdGJJc0ZpbmQgPSB0aGlzLmZpcnN0RmluZCgpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMubV9hbGdvcml0aG0gPT0gMSkge1xyXG5cdFx0XHRcdGJJc0ZpbmQgPSB0aGlzLnNlY29uZEZpbmQoKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJJc0ZpbmQgPSB0aGlzLnRoaXJkRmluZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICBcdH1cclxuICAgIFx0cmV0dXJuIGJJc0ZpbmQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZmlyc3RGaW5kID0gZnVuY3Rpb24oKSB7XHJcbiAgICBcdGN2W1wiR2F1c3NpYW5CbHVyXCJdKHRoaXMubV9pbWFnZU1hdCwgdGhpcy5tX2JsdXJNYXQsIG5ldyBjdltcIlNpemVcIl0oNSwgNSksIDAuMSk7XHJcbiAgICBcdHJldHVybiB0aGlzLl9fZmluZCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc2Vjb25kRmluZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgXHRjdltcIkdhdXNzaWFuQmx1clwiXSh0aGlzLm1faW1hZ2VNYXQsIHRoaXMubV9ibHVyTWF0LCBuZXcgY3ZbXCJTaXplXCJdKDksIDkpLCA0LjApO1xyXG4gICAgXHRyZXR1cm4gdGhpcy5fX2ZpbmQoKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnRoaXJkRmluZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGxldCBycnIgPSB0aGlzLm1faW1hZ2VNYXQucm93cztcclxuICAgICAgICBsZXQgY2NjID0gdGhpcy5tX2ltYWdlTWF0LmNvbHM7XHJcblxyXG4gICAgICAgIGlmIChycnIgPiAyMDAgfHwgY2NjID4gMjAwKSB7XHJcbiAgICAgICAgICAgIGN2W1wicHlyRG93blwiXSh0aGlzLm1faW1hZ2VNYXQsIHRoaXMubV9pbWFnZU1hdCwgbmV3IGN2W1wiU2l6ZVwiXSgwLCAwKSwgY3ZbXCJCT1JERVJfREVGQVVMVFwiXSk7XHJcblx0XHRcdHRoaXMubV9uU2NhbGUgPSAwLjEyNTtcclxuXHRcdFx0cnJyID0gdGhpcy5tX2ltYWdlTWF0LnJvd3M7XHJcblx0XHRcdGNjYyA9IHRoaXMubV9pbWFnZU1hdC5jb2xzO1xyXG5cdFx0fVxyXG5cclxuICAgICAgICBjb25zdCBiZ2RNb2RlbCA9IG5ldyBjdltcIk1hdFwiXSgpO1xyXG4gICAgICAgIGNvbnN0IGZnZE1vZGVsID0gbmV3IGN2W1wiTWF0XCJdKCk7XHJcbiAgICAgICAgY29uc3QgcmVjdCA9IG5ldyBjdltcIlJlY3RcIl0oY2NjIC8gNDAsIHJyci8gNDAsIGNjYyAtIGNjYyAvIDQwLCBycnIgLSBycnIgLyA0MCk7XHJcblxyXG4gICAgICAgIGN2W1wiY3Z0Q29sb3JcIl0odGhpcy5tX2ltYWdlTWF0LCB0aGlzLm1faW1hZ2VNYXQsIGN2W1wiQ09MT1JfUkdCQTJSR0JcIl0sIDApO1xyXG5cdFx0Y3ZbXCJncmFiQ3V0XCJdKHRoaXMubV9pbWFnZU1hdCwgdGhpcy5tX2JsdXJNYXQsIHJlY3QsIGJnZE1vZGVsLCBmZ2RNb2RlbCwgMSwgY3ZbXCJHQ19JTklUX1dJVEhfUkVDVFwiXSk7XHJcblx0XHRjdltcImNvbnZlcnRTY2FsZUFic1wiXSh0aGlzLm1fYmx1ck1hdCwgdGhpcy5tX2JsdXJNYXQsIDEwMCwgMCk7XHJcblx0XHRjdltcInRocmVzaG9sZFwiXSh0aGlzLm1fYmx1ck1hdCwgdGhpcy5tX2JsdXJNYXQsIDIwMCwgMjU1LCBjdltcIlRIUkVTSF9CSU5BUllcIl0pO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5fX2ZpbmQoKTtcclxuXHR9XHJcblxyXG4gICAgX3RoaXMuZmluZFBvaW50ID0gZnVuY3Rpb24ocHQsIHJlY3QpIHtcclxuICAgICAgICBpZiAocHQueCA8PSAocmVjdC54ICsgcmVjdC53aWR0aCkgJiYgcHQueCA+PSByZWN0LnhcclxuICAgICAgICAgICAgJiYgcHQueSA8PSAocmVjdC55ICsgcmVjdC5oZWlnaHQpICYmIHB0LnkgPj0gcmVjdC55KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9O1xyXG5cclxuICAgIF90aGlzLmZpbHRlclJlY3QgPSBmdW5jdGlvbihyciwgY29udG91ciwgZmlsdGVyZWQpIHtcclxuICAgICAgICBjb25zdCBwdHMgPSBjdltcIlJvdGF0ZWRSZWN0XCJdW1wicG9pbnRzXCJdKHJyKTtcclxuICAgICAgICBcclxuICAgICAgICBsZXQgc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIGZvcihsZXQgaT0wO2kgPCBjb250b3VyLmxlbmd0aDsgaSs9Mikge1xyXG4gICAgICAgICAgICBsZXQgcHQgPSB7fVxyXG4gICAgICAgICAgICBwdFtcInhcIl0gPSBjb250b3VyW2ldO1xyXG4gICAgICAgICAgICBwdFtcInlcIl0gPSBjb250b3VyW2krMV07XHJcbiAgICAgICAgICAgIGlmKHRoaXMuaW5zaWRlKHB0LCBwdHMpKSB7XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZC5wdXNoKHB0KTtcclxuICAgICAgICAgICAgICAgIGlmKCFzdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRlZCA9IHRydWU7IFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdGFydGVkO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgX3RoaXMuX19maW5kID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgbGV0IGNhbm55O1xyXG4gICAgICAgIGxldCBjb250b3VycztcclxuICAgICAgICBsZXQgaGllcmFyY2h5O1xyXG4gICAgICAgIGxldCBodWxsO1xyXG4gICAgICAgIGxldCB0bXBfcHRzO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNhbm55ID0gbmV3IGN2W1wiTWF0XCJdKCk7XHJcbiAgICAgICAgICAgIGN2W1wiQ2FubnlcIl0odGhpcy5tX2JsdXJNYXQsIGNhbm55LCA0MCwgNDApO1xyXG5cclxuICAgICAgICAgICAgY29udG91cnMgPSBuZXcgY3ZbXCJNYXRWZWN0b3JcIl0oKTtcclxuICAgICAgICAgICAgaGllcmFyY2h5ID0gbmV3IGN2W1wiTWF0XCJdKCk7XHJcbiAgICAgICAgICAgIGN2W1wiZmluZENvbnRvdXJzXCJdKGNhbm55LCBjb250b3VycywgaGllcmFyY2h5LCBjdltcIlJFVFJfRVhURVJOQUxcIl0sIGN2W1wiQ0hBSU5fQVBQUk9YX05PTkVcIl0pO1xyXG4gICAgXHJcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxjb250b3Vyc1tcInNpemVcIl0oKTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY29udG91ciA9IGNvbnRvdXJzW1wiZ2V0XCJdKGkpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGFwcHJveEN1cnZlID0gbmV3IGN2W1wiTWF0XCJdKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwZXJpbWV0ZXIgPSBjdltcImFyY0xlbmd0aFwiXShjb250b3VyLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocGVyaW1ldGVyIDwgMTUwKSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgY3ZbXCJhcHByb3hQb2x5RFBcIl0oY29udG91ciwgYXBwcm94Q3VydmUsIHBlcmltZXRlciAqIDAuMDIsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjdltcImlzQ29udG91ckNvbnZleFwiXShhcHByb3hDdXJ2ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYgKGFwcHJveEN1cnZlW1wiZGF0YTMyU1wiXS5sZW5ndGggPT0gOCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdGF0ZWRSZWN0ID0gY3ZbXCJtaW5BcmVhUmVjdFwiXShjb250b3VyKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBycnB0cyA9IGN2W1wiUm90YXRlZFJlY3RcIl1bXCJwb2ludHNcIl0ocm90YXRlZFJlY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFJlY3QgPSB0aGlzLmZpbGx0ZXJSZWN0KHJycHRzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJGb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubV9iSXNQcmV2aWV3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihsZXQgYz0wOyBjIDwgdGhpcy5tX3BTY2FuQXJlYS5sZW5ndGg7IGMrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm91bmRJbmRleCA9IHRoaXMuZmluZFBvaW50KHRhcmdldFJlY3RbY10sIHRoaXMubV9wU2NhbkFyZWFbY10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kSW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYkZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGJGb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBycHRzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJwdHMucHVzaChuZXcgY3ZbXCJQb2ludFwiXShhcHByb3hDdXJ2ZVtcImRhdGEzMlNcIl1bMF0sIGFwcHJveEN1cnZlW1wiZGF0YTMyU1wiXVsxXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBycHRzLnB1c2gobmV3IGN2W1wiUG9pbnRcIl0oYXBwcm94Q3VydmVbXCJkYXRhMzJTXCJdWzJdLCBhcHByb3hDdXJ2ZVtcImRhdGEzMlNcIl1bM10pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnB0cy5wdXNoKG5ldyBjdltcIlBvaW50XCJdKGFwcHJveEN1cnZlW1wiZGF0YTMyU1wiXVs0XSwgYXBwcm94Q3VydmVbXCJkYXRhMzJTXCJdWzVdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJwdHMucHVzaChuZXcgY3ZbXCJQb2ludFwiXShhcHByb3hDdXJ2ZVtcImRhdGEzMlNcIl1bNl0sIGFwcHJveEN1cnZlW1wiZGF0YTMyU1wiXVs3XSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1fZm91bmRSZWN0ID0gdGhpcy5maWxsdGVyUmVjdChycHRzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm1fZm91bmRSZWN0ID0gW107XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgaWYgKGNhbm55KSBjYW5ueVtcImRlbGV0ZVwiXSgpO1xyXG4gICAgICAgICAgICBpZiAoY29udG91cnMpIGNvbnRvdXJzW1wiZGVsZXRlXCJdKCk7XHJcbiAgICAgICAgICAgIGlmIChoaWVyYXJjaHkpIGhpZXJhcmNoeVtcImRlbGV0ZVwiXSgpO1xyXG4gICAgICAgICAgICBpZiAoaHVsbCkgaHVsbFtcImRlbGV0ZVwiXSgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRtcF9wdHMpIHRtcF9wdHNbXCJkZWxldGVcIl0oKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgX3RoaXMuZmlsbHRlclJlY3QgPSBmdW5jdGlvbihycnB0cykge1xyXG4gICAgICAgIC8vIHBvaW50cyBzb3J0aW5nIFxyXG4gICAgICAgIGxldCBtaW5EaXN0ID0gOTk5OTk7XHJcbiAgICAgICAgbGV0IGlkeHMgPSBbMCwgMSwgMiwgM107XHJcbiAgICAgICAgbGV0IG5MZWZ0VG9wID0gMDtcclxuICAgICAgICBsZXQgblJpZ2h0VG9wID0gMDtcclxuICAgICAgICBsZXQgblJpZ2h0Qm90dG9tID0gMDtcclxuICAgICAgICBsZXQgbkxlZnRCb3R0b20gPSAwO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpPTA7IGkgPCBycnB0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgZGlzdCA9IHRoaXMuZ2V0RGlzdGFuY2UoMCwgMCwgcnJwdHNbaV0ueCwgcnJwdHNbaV0ueSk7XHJcbiAgICAgICAgICAgIGlmIChtaW5EaXN0ID4gZGlzdCkge1xyXG4gICAgICAgICAgICAgICAgbWluRGlzdCA9IGRpc3Q7XHJcbiAgICAgICAgICAgICAgICBuTGVmdFRvcCA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWR4cy5zcGxpY2UoaWR4cy5pbmRleE9mKG5MZWZ0VG9wKSwgMSk7XHJcblxyXG4gICAgICAgIGxldCBuTWluWCA9IDk5OTk5O1xyXG4gICAgICAgIGxldCBuTWluWSA9IDk5OTk5O1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpPTA7IGkgPCBpZHhzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IGlkeHNbaV07XHJcbiAgICAgICAgICAgIGlmIChycnB0c1tpZHhdLnggPCBuTWluWCkge1xyXG4gICAgICAgICAgICAgICAgbk1pblggPSBycnB0c1tpZHhdLng7XHJcbiAgICAgICAgICAgICAgICBuTGVmdEJvdHRvbSA9IGlkeDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocnJwdHNbaWR4XS55IDwgbk1pblkpIHtcclxuICAgICAgICAgICAgICAgIG5NaW5ZID0gcnJwdHNbaWR4XS55O1xyXG4gICAgICAgICAgICAgICAgblJpZ2h0VG9wID0gaWR4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZHhzLnNwbGljZShpZHhzLmluZGV4T2YobkxlZnRCb3R0b20pLCAxKTtcclxuICAgICAgICBpZHhzLnNwbGljZShpZHhzLmluZGV4T2YoblJpZ2h0VG9wKSwgMSk7XHJcblxyXG4gICAgICAgIG5SaWdodEJvdHRvbSA9IGlkeHNbMF07XHJcblxyXG4gICAgICAgIGNvbnN0IHNvcnRlZCA9IFtdO1xyXG4gICAgICAgIHNvcnRlZC5wdXNoKG5ldyBjdltcIlBvaW50XCJdKHRoaXMuc2NhbGUocnJwdHNbbkxlZnRUb3BdLngpLCB0aGlzLnNjYWxlKHJycHRzW25MZWZ0VG9wXS55KSkpO1xyXG4gICAgICAgIHNvcnRlZC5wdXNoKG5ldyBjdltcIlBvaW50XCJdKHRoaXMuc2NhbGUocnJwdHNbblJpZ2h0VG9wXS54KSwgdGhpcy5zY2FsZShycnB0c1tuUmlnaHRUb3BdLnkpKSk7XHJcbiAgICAgICAgc29ydGVkLnB1c2gobmV3IGN2W1wiUG9pbnRcIl0odGhpcy5zY2FsZShycnB0c1tuUmlnaHRCb3R0b21dLngpLCB0aGlzLnNjYWxlKHJycHRzW25SaWdodEJvdHRvbV0ueSkpKTtcclxuICAgICAgICBzb3J0ZWQucHVzaChuZXcgY3ZbXCJQb2ludFwiXSh0aGlzLnNjYWxlKHJycHRzW25MZWZ0Qm90dG9tXS54KSwgdGhpcy5zY2FsZShycnB0c1tuTGVmdEJvdHRvbV0ueSkpKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHNvcnRlZDtcclxuICAgIH07XHJcblxyXG4gICAgX3RoaXMuc2NhbGUgPSBmdW5jdGlvbihudW0pIHtcclxuICAgICAgICByZXR1cm4gbnVtIC8gdGhpcy5tX25TY2FsZTtcclxuICAgIH07XHJcblxyXG4gICAgX3RoaXMuZ2V0RGlzdGFuY2UgPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mikge1xyXG4gICAgICAgIGNvbnN0IGR4ID0geDIgLSB4MTtcclxuICAgICAgICBjb25zdCBkeSA9IHkyIC0geTE7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF90aGlzLmNtMnB4ID0gZnVuY3Rpb24obkRwaSwgY20pIHtcclxuICAgICAgICByZXR1cm4gcGFyc2VJbnQoY20gLyAyLjU0ICogbkRwaSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF90aGlzLmNvcHlSZWN0YW5nbGUgPSBmdW5jdGlvbih0YXJnZXRNYXQsIHJlY3RhbmdsZSwgd2lkdGgsIGhlaWdodCwgbWFyZ2luTCA9IDAsIG1hcmdpblQgPSAwKSB7XHJcbiAgICAgICAgY29uc3QgbWFyZ2luUiA9IG1hcmdpbkw7XHJcbiAgICAgICAgY29uc3QgbWFyZ2luQiA9IG1hcmdpblQ7XHJcblxyXG4gICAgICAgIGxldCByZXN1bHQgPSBuZXcgY3ZbXCJNYXRcIl1bXCJ6ZXJvc1wiXShoZWlnaHQsIHdpZHRoLCBjdltcIkNWXzhVQzNcIl0pO1xyXG5cclxuICAgICAgICBsZXQgc3JjUXVhZCA9IG51bGw7XHJcbiAgICAgICAgbGV0IGRzdFF1YWQgPSBudWxsO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHNyY1F1YWQgPSBjdltcIm1hdEZyb21BcnJheVwiXSg0LCAxLCBjdltcIkNWXzMyRkMyXCJdLCBbIC8vIGNyb3DtlaAg7JiB7JetXHJcbiAgICAgICAgICAgICAgICByZWN0YW5nbGVbMF0ueCwgcmVjdGFuZ2xlWzBdLnksIFxyXG4gICAgICAgICAgICAgICAgcmVjdGFuZ2xlWzFdLngsIHJlY3RhbmdsZVsxXS55LFxyXG4gICAgICAgICAgICAgICAgcmVjdGFuZ2xlWzNdLngsIHJlY3RhbmdsZVszXS55LFxyXG4gICAgICAgICAgICAgICAgcmVjdGFuZ2xlWzJdLngsIHJlY3RhbmdsZVsyXS55XHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgXHJcbiAgICAgICAgICAgIGRzdFF1YWQgPSBjdltcIm1hdEZyb21BcnJheVwiXSg0LCAxLCBjdltcIkNWXzMyRkMyXCJdLCBbIC8vIGRzaXplIGNyb3Ag6rKw6rO866y8IO2BrOq4sFxyXG4gICAgICAgICAgICAgICAgMCAgLSBtYXJnaW5MLCAwIC0gbWFyZ2luVCwgXHJcbiAgICAgICAgICAgICAgICB3aWR0aCAgKyBtYXJnaW5SLCAwIC0gbWFyZ2luVCxcclxuICAgICAgICAgICAgICAgIDAgLSBtYXJnaW5MLCBoZWlnaHQgKyBtYXJnaW5CLFxyXG4gICAgICAgICAgICAgICAgd2lkdGggKyBtYXJnaW5SLCBoZWlnaHQgKyBtYXJnaW5CXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgXHJcbiAgICAgICAgICAgIGNvbnN0IHdhcnBNYXRpeCA9IGN2W1wiZ2V0UGVyc3BlY3RpdmVUcmFuc2Zvcm1cIl0oc3JjUXVhZCwgZHN0UXVhZCk7XHJcbiAgICAgICAgICAgIGN2W1wid2FycFBlcnNwZWN0aXZlXCJdKHRhcmdldE1hdCwgcmVzdWx0LCB3YXJwTWF0aXgsIG5ldyBjdltcIlNpemVcIl0od2lkdGgsIGhlaWdodCkpO1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgIHNyY1F1YWQuZGVsZXRlKCk7XHJcbiAgICAgICAgICAgIHNyY1F1YWQgPSBudWxsO1xyXG4gICAgICAgICAgICBkc3RRdWFkLmRlbGV0ZSgpO1xyXG4gICAgICAgICAgICBkc3RRdWFkID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF90aGlzLmNhcHR1cmUgPSBmdW5jdGlvbih0YXJnZXRNYXQsIHdpZHRoLCBoZWlnaHQsIG1hcmdpbkxlZnQsIG1hcmdpblRvcCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvcHlSZWN0YW5nbGUodGFyZ2V0TWF0LCB0aGlzLm1fZm91bmRSZWN0LCB3aWR0aCwgaGVpZ2h0LCAtbWFyZ2luTGVmdCwgLW1hcmdpblRvcCk7XHJcbiAgICB9O1xyXG5cclxuICAgX3RoaXMuZm9yY2VDYXB0dXJlID0gZnVuY3Rpb24odGFyZ2V0TWF0LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weVJlY3RhbmdsZSh0YXJnZXRNYXQsIHRoaXMubV9wU2NhbkFyZWFDZW50ZXJQb2ludCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICB9O1xyXG5cclxuICAgIF90aGlzLnNldENoZWNrU2l6ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5tX25DaGVja1NpemUgPSB2YWx1ZTtcclxuICAgIH07XHJcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/OZCardRecognizer.js\n");

/***/ }),

/***/ "./src/OZRecognitionPack.js":
/*!**********************************!*\
  !*** ./src/OZRecognitionPack.js ***!
  \**********************************/
/***/ (() => {

eval("const OZRecognitionPack = window[\"OZRecognitionPack\"] = function(mode) {\r\n    const _this = OZRecognitionPack.prototype;\r\n\r\n    if (mode == OZRecognitionPack.MODE_ID)\r\n        this.m_cardRecognizer = new window[\"OZCardRecognizer\"]();\r\n    if (mode == OZRecognitionPack.MODE_SEAL)\r\n        this.m_sealRecognizer = new window[\"OZSealRecognizer\"]();\r\n\r\n    this.m_nFindCount = 0;\r\n    this.m_preprocessingImage = \"\";\r\n    this.m_postprocessingImage = \"\";\r\n    this.m_strMimeType = \"\";\r\n\r\n    this.m_specBarcode = {};\r\n    this.m_nSealSize = 0;\r\n\r\n    _this.SetResultMimeType = function(strMimeType) {\r\n        this.m_strMimeType = strMimeType;\r\n    };\r\n\r\n    _this.GetResultMimeType = function() {\r\n        if (this.m_strMimeType == \"\")\r\n            return \"image/png\";\r\n\r\n        return this.m_strMimeType;\r\n    };\r\n\r\n    _this.getDataFromMat = function (mat) { // imageData 추출\r\n        const pTmpCanvas = document.createElement('canvas');\r\n        pTmpCanvas.width = mat[\"cols\"];\r\n        pTmpCanvas.height = mat[\"rows\"];\r\n        pTmpCanvas.setAttribute(\"style\", \"display:none;\");\r\n        cv[\"imshow\"](pTmpCanvas, mat);\r\n\r\n        let data = null;\r\n        if (this.m_strMimeType == \"\") {\r\n            data = pTmpCanvas.toDataURL();\r\n        } else {\r\n            data = pTmpCanvas.toDataURL(this.m_strMimeType);\r\n        }\r\n        $(pTmpCanvas).remove();\r\n        return data;\r\n    };\r\n\r\n    _this.GetPreprocessingImage = function () {\r\n        return this.m_preprocessingImage;\r\n    };\r\n\r\n    _this.GetPostprocessingImage = function () {\r\n        return this.m_postprocessingImage;\r\n    };\r\n\r\n    _this.GetState = function () {\r\n        return this.m_cardRecognizer.GetState();\r\n    };\r\n\r\n    _this.GetSealSize = function () {\r\n        return this.m_nSealSize;\r\n    };\r\n\r\n    _this.GetSpecBarcode = function () {\r\n        return this.m_specBarcode;\r\n    };\r\n\r\n    _this.IsFoundPattern = function () {\r\n        return this.m_sealRecognizer.IsFoundPattern();\r\n    };\r\n\r\n    _this.IsFoundRectangle = function () {\r\n        return this.m_sealRecognizer.IsFoundRectangle();\r\n    };\r\n\r\n    _this.IsFoundSpecBarcode = function () {\r\n        return this.m_sealRecognizer.IsFoundSpecBarcode();\r\n    };\r\n\r\n    _this.fillMosaic = function (image, x, y, w, h, mosaicSize) {\r\n        for (let i = 0; i < h; i += mosaicSize) {\r\n            for (let j = 0; j < w; j += mosaicSize) {\r\n                const c = this.getRandomColor(image, x + j, y + i, mosaicSize * 3, mosaicSize * 3);\r\n                this.fillRect(image, x + j, y + i, mosaicSize, mosaicSize, c);\r\n            }\r\n        }\r\n    };\r\n\r\n    _this.getRandomColor = function (image, x, y, w, h) {\r\n        if (x + w > image.cols) {\r\n            w = image.cols - x <= 0 ? 1 : image.cols - x;\r\n        }\r\n        if (y + h > image.rows) {\r\n            h = image.rows - y <= 0 ? 1 : image.rows - y;\r\n        }\r\n        if (x > image.cols)\r\n            x = image.cols - 1;\r\n        if (y > image.rows)\r\n            y = image.rows - 1;\r\n\r\n        return image.ucharPtr(y + (Math.random() % h), x + (Math.random() % w));\r\n    };\r\n\r\n    _this.fillRect = function (image, x, y, w, h, color) {\r\n        if (x + w > image.cols) {\r\n            w = image.cols - x;\r\n        }\r\n        if (y + h > image.rows) {\r\n            h = image.rows - y;\r\n        }\r\n\r\n        for (let i = 0; i < h; i++) {\r\n            for (let j = 0; j < w; j++) {\r\n                image.ucharPtr(y + i, x + j)[0] = color[0];\r\n                image.ucharPtr(y + i, x + j)[1] = color[1];\r\n                image.ucharPtr(y + i, x + j)[2] = color[2];\r\n                image.ucharPtr(y + i, x + j)[3] = color[3];\r\n            }\r\n        }\r\n    };\r\n\r\n    _this.FindArea = function (nDPI, pHiddenCanvas, targetMat, pPaperInfo, pScanArea, pScanAreaCenterPoint, nScanWidth, nScanHeight, bIsPreview, bIsForceCapture) {\r\n        let result = 998;\r\n        let resultMat = null;\r\n        try {\r\n            if (this.m_cardRecognizer.ready(pHiddenCanvas, targetMat, pScanArea, pScanAreaCenterPoint, bIsPreview)) {\r\n                let resultMat;\r\n                const resultWidth = pPaperInfo.sizeWidth;\r\n                const resultHeight = pPaperInfo.sizeHeight;\r\n\r\n                if (bIsForceCapture) { //강제촬영 및 저장\r\n                    resultMat = this.m_cardRecognizer.forceCapture(targetMat,\r\n                        this.m_cardRecognizer.cm2px(nDPI, resultWidth),\r\n                        this.m_cardRecognizer.cm2px(nDPI, resultHeight));\r\n\r\n                    // unmasked image 저장\r\n                    this.m_preprocessingImage = this.getDataFromMat(resultMat);\r\n\r\n                    let mosaicSize = this.m_cardRecognizer.cm2px(nDPI, 0.07);\r\n                    if (mosaicSize < 6) mosaicSize = 6;\r\n                    for (let i = 0; i < pPaperInfo.item.length; i++) {\r\n                        const x = parseInt(this.m_cardRecognizer.cm2px(nDPI, pPaperInfo.item[i].left));\r\n                        const y = parseInt(this.m_cardRecognizer.cm2px(nDPI, pPaperInfo.item[i].top));\r\n                        const w = parseInt(this.m_cardRecognizer.cm2px(nDPI, pPaperInfo.item[i].width));\r\n                        const h = parseInt(this.m_cardRecognizer.cm2px(nDPI, pPaperInfo.item[i].height));\r\n                        this.fillMosaic(resultMat, x, y, w, h, mosaicSize);\r\n                    }\r\n\r\n                    // masked image 저장\r\n                    this.m_postprocessingImage = this.getDataFromMat(resultMat);\r\n\r\n                    resultMat[\"delete\"]();\r\n                    resultMat = null;\r\n                    this.m_cardRecognizer.m_resultMat = null;\r\n                    this.m_cardRecognizer.dispose();\r\n                    this.m_cardRecognizer = null;\r\n\r\n                    this.m_nFindCount = 0;\r\n                    result = 999;\r\n                } else {\r\n                    if (this.m_cardRecognizer.find(this.m_nFindCount++)) {\r\n                        // 신분증 최소 사이즈는 30%로 고정\r\n                        const nPxResultWidth = this.m_cardRecognizer.cm2px(nDPI, resultWidth);\r\n                        const nPxResultHeight = this.m_cardRecognizer.cm2px(nDPI, resultHeight);\r\n\r\n                        // 직사각형의 꼭지점(m_foundRect)을 이용해 이미지 추출 시 테두리가 잘리는 현상이 있어 margin 기본값에 2mm를 더해 보정함\r\n                        let marginLeft = this.m_cardRecognizer.cm2px(nDPI, (pPaperInfo.sizeMargin + 0.2));\r\n                        const minWidth = nPxResultWidth * 0.3;\r\n                        if (marginLeft > minWidth)\r\n                            marginLeft = parseInt(minWidth);\r\n                        const marginTop = parseInt(marginLeft * (nScanHeight / nScanWidth));\r\n\r\n                        resultMat = this.m_cardRecognizer.capture(targetMat,\r\n                            nPxResultWidth, nPxResultHeight, marginLeft, marginTop);\r\n\r\n                        // unmasked image 저장\r\n                        this.m_preprocessingImage = this.getDataFromMat(resultMat);\r\n\r\n                        const scaleX = (nPxResultWidth - marginLeft * 2) / nPxResultWidth;\r\n                        const scaleY = (nPxResultHeight - marginTop * 2) / nPxResultHeight;\r\n\r\n                        let mosaicSize = this.m_cardRecognizer.cm2px(nDPI, 0.07);\r\n                        if (mosaicSize < 6) mosaicSize = 6;\r\n                        for (let i = 0; i < pPaperInfo.item.length; i++) {\r\n                            const x = this.m_cardRecognizer.cm2px(nDPI, pPaperInfo.item[i].left);\r\n                            const y = this.m_cardRecognizer.cm2px(nDPI, pPaperInfo.item[i].top);\r\n                            const w = this.m_cardRecognizer.cm2px(nDPI, pPaperInfo.item[i].width);\r\n                            const h = this.m_cardRecognizer.cm2px(nDPI, pPaperInfo.item[i].height);\r\n\r\n                            const _x = parseInt(x * scaleX) + marginLeft;\r\n                            const _y = parseInt(y * scaleY) + marginTop;\r\n                            const _w = parseInt(w * scaleX);\r\n                            const _h = parseInt(h * scaleY);\r\n                            this.fillMosaic(resultMat, _x, _y, _w, _h, mosaicSize);\r\n                        }\r\n\r\n                        // masked image 저장\r\n                        this.m_postprocessingImage = this.getDataFromMat(resultMat);\r\n\r\n                        resultMat[\"delete\"]();\r\n                        resultMat = null;\r\n                        this.m_cardRecognizer.dispose();\r\n                        this.m_cardRecognizer = null;\r\n\r\n                        this.m_nFindCount = 0;\r\n                        result = 999;\r\n                    }\r\n                }\r\n            }\r\n        } catch (e) {\r\n            OZRecognitionPack.trace(e);\r\n            if (resultMat != null) {\r\n                resultMat[\"delete\"]();\r\n                resultMat = null;\r\n            }\r\n            this.m_cardRecognizer.dispose();\r\n            this.m_cardRecognizer = null;\r\n            throw new Error(e);\r\n        }\r\n        return result;\r\n    };\r\n\r\n    _this.FindSeal = function (nDPI, pHiddenCanvas, pHiddenMeta, targetMat, processType) {\r\n        let result = 998;\r\n        if (this.m_sealRecognizer.ready(nDPI, pHiddenCanvas, pHiddenMeta, targetMat)) {\r\n            try {\r\n                if (this.m_sealRecognizer.findPatternArea()) {\r\n                    if (this.m_sealRecognizer.capture()) {\r\n                        if (!this.m_sealRecognizer.getResult().empty()) {\r\n\r\n                            let resultMat = this.m_sealRecognizer.getResult();\r\n                            \r\n                            // spec barcode 저장\r\n                            this.m_specBarcode = this.m_sealRecognizer.getSpecBarcode();\r\n\r\n                            // preprocessing image 저장\r\n                            this.m_preprocessingImage = this.getDataFromMat(resultMat);\r\n                            this.m_nSealSize = resultMat[\"cols\"];\r\n\r\n                            if (processType != OZSealRecognizer.NONE) {\r\n                                const gray = new cv[\"Mat\"]();\r\n                                cv[\"cvtColor\"](resultMat, gray, cv[\"COLOR_RGB2GRAY\"]);\r\n\r\n                                let isBNW = false;\r\n                                let isNeedChangePixel = false;\r\n                                let isAlphaType = false;\r\n                                let isGray = false;\r\n\r\n                                let colorR = 0;\r\n                                let colorG = 0;\r\n                                let colorB = 0;\r\n\r\n                                switch (processType) {\r\n                                    case OZSealRecognizer.BLACK_AND_WHITE:\r\n                                        isBNW = true;\r\n                                        break;\r\n                                    case OZSealRecognizer.RED_AND_WHITE:\r\n                                        colorR = 255;\r\n                                        isNeedChangePixel = true;\r\n                                        break;\r\n                                    case OZSealRecognizer.BLACK_AND_BLANK:\r\n                                        isNeedChangePixel = true;\r\n                                        isAlphaType = true;\r\n                                        break;\r\n                                    case OZSealRecognizer.RED_AND_BLANK:\r\n                                        colorR = 255;\r\n                                        isNeedChangePixel = true;\r\n                                        isAlphaType = true;\r\n                                        break;\r\n                                    case OZSealRecognizer.GRAYSCALE:\r\n                                        isGray = true;\r\n                                        break;\r\n                                }\r\n\r\n                                let isNeedChangeColor = (colorR != 0 || colorG != 0 || colorB != 0);\r\n                                if (!isGray) {\r\n                                    cv[\"adaptiveThreshold\"](gray, resultMat, 255, cv[\"ADAPTIVE_THRESH_MEAN_C\"], cv[\"THRESH_BINARY\"], 201, 10);\r\n                                    const background = cv[\"Mat\"][\"zeros\"](resultMat[\"rows\"], resultMat[\"cols\"], cv[\"CV_8UC3\"]);\r\n                                    cv[\"cvtColor\"](resultMat, background, cv[\"COLOR_GRAY2BGRA\"]);\r\n\r\n                                    if (isNeedChangePixel) {\r\n                                        for (let y = 0; y < background[\"rows\"]; ++y) {\r\n                                            for (let x = 0; x < background[\"cols\"]; ++x) {\r\n                                                const pixel = background[\"ucharPtr\"](y, x); // cv::Vec4b &\r\n                                                let bChange = false;\r\n                                                if (isAlphaType) {\r\n                                                    // if pixel is white\r\n                                                    if (pixel[0] == 255 && pixel[1] == 255 && pixel[2] == 255) {\r\n                                                        // set alpha to zero:\r\n                                                        pixel[3] = 0;\r\n                                                        bChange = true;\r\n                                                    }\r\n                                                }\r\n                                                if (isNeedChangeColor && !bChange) {\r\n                                                    if (pixel[0] == 0 && pixel[1] == 0 && pixel[2] == 0) {\r\n                                                        pixel[0] = colorR;\r\n                                                        pixel[1] = colorG;\r\n                                                        pixel[2] = colorB;\r\n                                                        pixel[3] = 255;\r\n                                                        bChange = true;\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                    resultMat = background;\r\n                                } else {\r\n                                    resultMat = gray;\r\n                                }\r\n                                if (isBNW || isNeedChangePixel)\r\n                                    cv[\"blur\"](resultMat, resultMat, new cv[\"Size\"](3, 3));\r\n\r\n                                // postprocessing image 저장\r\n                                this.m_postprocessingImage = this.getDataFromMat(resultMat);\r\n\r\n                                ////////////// sup 6962 - 인감 스캔 결과에 메타 데이터 추가 기능 테스트\r\n                                const _oz_base64Encode = function (src) {\r\n                                    try {\r\n                                        var binary;\r\n                                        var len = src.length;\r\n                                        var chunk_size = 8192;\r\n                                        if (len <= chunk_size) {\r\n                                            binary = String.fromCharCode.apply(null, src);\r\n                                        } else if (src.slice !== undefined) {\r\n                                            binary = '';\r\n                                            for (var i = 0; i < len; i += chunk_size) {\r\n                                                var chunk = src.slice(i, i + chunk_size);\r\n                                                binary += String.fromCharCode.apply(null, chunk);\r\n                                            }\r\n                                        } else {\r\n                                            binary = '';\r\n                                            for (var i = 0; i < len; i++) {\r\n                                                binary += String.fromCharCode(src[i]);\r\n                                            }\r\n                                        }\r\n                                        return window.btoa(binary);\r\n                                    } catch (eee) {\r\n                                        return \"\";\r\n                                    }\r\n                                };\r\n                                const _oz_base64Decoder = function (str) {\r\n                                    try {\r\n                                        const binary_string = window.atob(str);\r\n                                        const len = binary_string.length;\r\n                                        let dst = new Uint8Array(len);\r\n                                        for (let i = 0; i < len; i++) {\r\n                                            dst[i] = binary_string.charCodeAt(i);\r\n                                        }\r\n                                        return dst;\r\n                                    } catch (eee) {\r\n                                        return null;\r\n                                    }\r\n                                };\r\n                                const _oz_getIntBigEndian = function (data, offset) {\r\n                                    return (data[offset] & 0xff) << 24 |\r\n                                        (data[offset + 1] & 0xff) << 16 |\r\n                                        (data[offset + 2] & 0xff) << 8 |\r\n                                        data[offset + 3] & 0xff;\r\n                                };\r\n                                const _oz_setIntBigEndian = function (data, offset, value) {\r\n                                    value = value & 0xFFFFFFFF;\r\n                                    data[offset + 3] = (value) & 0xFF;\r\n                                    data[offset + 2] = (value >>> 8) & 0xFF;\r\n                                    data[offset + 1] = (value >>> 16) & 0xFF;\r\n                                    data[offset + 0] = (value >>> 24) & 0xFF;\r\n                                };\r\n                                const CRC32_makeCrcTable = function () {\r\n                                    const crcTable = [];\r\n                                    for (let n = 0; n < 256; n++) {\r\n                                        let c = n;\r\n                                        for (var k = 8; --k >= 0;) {\r\n                                            if ((c & 1) != 0) c = 0xedb88320 ^ (c >>> 1);\r\n                                            else c = c >>> 1;\r\n                                        }\r\n                                        crcTable[n] = c;\r\n                                    }\r\n                                    return crcTable;\r\n                                };\r\n                                const CRC32_crcTable = CRC32_makeCrcTable();\r\n                                const _oz_Write_pHYs = function (dst, offset, pixel_info) {\r\n                                    _oz_setIntBigEndian(dst, offset, 9); //chunkLen\r\n                                    _oz_setIntBigEndian(dst, offset + 4, 0x70485973); //chunkType\r\n                                    let crc = 0;\r\n                                    const chunkData = new Uint8Array(9);\r\n                                    _oz_setIntBigEndian(chunkData, 0, pixel_info); //x\r\n                                    _oz_setIntBigEndian(chunkData, 4, pixel_info); //y\r\n                                    chunkData[8] = 1; //unit is the meter\r\n                                    {\r\n                                        let c = ~crc;\r\n                                        let len = chunkData.length;\r\n                                        let off = 0;\r\n                                        while (--len >= 0) c = CRC32_crcTable[(c ^ chunkData[off++]) & 0xff] ^ (c >>> 8);\r\n                                        crc = ~c;\r\n                                \r\n                                        crc = crc & 0xffffffff;\r\n                                    }\r\n                                    dst[\"set\"](chunkData, offset + 8);\r\n                                    _oz_setIntBigEndian(dst, offset + 17, crc); //crc\r\n                                };\r\n                                const _oz_Write_tEXt_Software = function (dst, offset) {\r\n                                    _oz_setIntBigEndian(dst, offset, 16); //chunkLen\r\n                                    _oz_setIntBigEndian(dst, offset + 4, 0x74455874); //chunkType\r\n                                    let crc = 0;\r\n                                    const chunkData = new Uint8Array(16);\r\n                                    _oz_setIntBigEndian(chunkData, 0, 0x536F6674);\r\n                                    _oz_setIntBigEndian(chunkData, 4, 0x77617265);\r\n                                    _oz_setIntBigEndian(chunkData, 8, 0x004F5A53);\r\n                                    _oz_setIntBigEndian(chunkData, 12, 0x65616C31); {\r\n                                        let c = ~crc;\r\n                                        let len = chunkData.length;\r\n                                        let off = 0;\r\n                                        while (--len >= 0) c = CRC32_crcTable[(c ^ chunkData[off++]) & 0xff] ^ (c >>> 8);\r\n                                        crc = ~c;\r\n                                \r\n                                        crc = crc & 0xffffffff;\r\n                                    }\r\n                                    dst[\"set\"](chunkData, offset + 8);\r\n                                    _oz_setIntBigEndian(dst, offset + 24, crc); //crc\r\n                                };\r\n                                const _oz_MakePNGWithDPI = function (data, dpi) {\r\n                                    let offset = 0;\r\n                                    if ((offset + 4) > data.length) return null;\r\n                                    const magic1 = _oz_getIntBigEndian(data, offset) >>> 0;\r\n                                    offset += 4;\r\n                                    if ((offset + 4) > data.length) return null;\r\n                                    const magic2 = _oz_getIntBigEndian(data, offset) >>> 0;\r\n                                    offset += 4;\r\n                                \r\n                                    if (!(magic1 == 0x89504e47 && magic2 == 0x0d0a1a0a)) { // magic\r\n                                        return null;\r\n                                    }\r\n                                    let check_oz = false;\r\n                                    let nEndPos = -1;\r\n                                    while (true) {\r\n                                        if ((offset + 4) > data.length) break;\r\n                                        const chunkLen = _oz_getIntBigEndian(data, offset);\r\n                                        offset += 4;\r\n                                \r\n                                        if ((offset + 4) > data.length) break;\r\n                                        const chunkType = _oz_getIntBigEndian(data, offset) >>> 0;\r\n                                        offset += 4;\r\n                                \r\n                                        //0x49484452   //IHDR\r\n                                        //0x70485973   //pHYs\r\n                                        //0x49444154   //IDAT\r\n                                        //0x49454E44   //IEND\r\n                                        //0x74455874   //tEXt\r\n                                        if (chunkType == 0x70485973) {\r\n                                            if ((offset + 4) > data.length) break;\r\n                                            const xPixel = _oz_getIntBigEndian(data, offset) >>> 0;\r\n                                            offset += 4;\r\n                                            if ((offset + 4) > data.length) break;\r\n                                            const yPixel = _oz_getIntBigEndian(data, offset) >>> 0;\r\n                                            offset += 4;\r\n                                            if ((offset + 1) > data.length) break;\r\n                                            dpi = dpi / 0.0254;\r\n                                            const pixel_info = (dpi + 0.5) | 0; // round\r\n                                            if (((data[offset] & 0xff) == 1) && (pixel_info == xPixel) && (pixel_info == yPixel)) {\r\n                                                if (check_oz) {\r\n                                                    return null;\r\n                                                }\r\n                                            }\r\n                                            offset -= 16;\r\n                                            const dst = new Uint8Array(data.length + (check_oz ? 0 : 28));\r\n                                            dst[\"set\"](data[\"subarray\"](0, offset), 0);\r\n                                            let nLen_tEXt = 0;\r\n                                            if (!check_oz) {\r\n                                                _oz_Write_tEXt_Software(dst, offset);\r\n                                                nLen_tEXt = 28;\r\n                                            }\r\n                                            _oz_Write_pHYs(dst, offset + nLen_tEXt, pixel_info);\r\n                                            dst[\"set\"](data[\"subarray\"](offset + 21, data.length), offset + nLen_tEXt + 21);\r\n                                            return dst;\r\n                                        } else if (chunkType == 0x74455874) {\r\n                                            if (chunkLen == 16) {\r\n                                                if ((offset + 16) > data.length) break;\r\n                                                const txt1 = _oz_getIntBigEndian(data, offset) >>> 0;\r\n                                                offset += 4;\r\n                                                const txt2 = _oz_getIntBigEndian(data, offset) >>> 0;\r\n                                                offset += 4;\r\n                                                const txt3 = _oz_getIntBigEndian(data, offset) >>> 0;\r\n                                                offset += 4;\r\n                                                const txt4 = _oz_getIntBigEndian(data, offset) >>> 0;\r\n                                                offset += 4;\r\n                                                if ((txt1 == 0x536F6674) && (txt2 == 0x77617265) && (txt3 == 0x004F5A53) && (txt4 == 0x65616C31)) { //Software\\0OZSeal1\r\n                                                    check_oz = true;\r\n                                                }\r\n                                                offset -= 16;\r\n                                            }\r\n                                        } else if (chunkType == 0x49444154) {\r\n                                            nEndPos = offset - 8;\r\n                                            break;\r\n                                        } else if (chunkType == 0x49454E44) {\r\n                                            break;\r\n                                        }\r\n                                        offset += chunkLen;\r\n                                        offset += 4; //crc\r\n                                    }\r\n                                    if (nEndPos >= 0) {\r\n                                        dpi = dpi / 0.0254;\r\n                                        const pixel_info = (dpi + 0.5) | 0; // round\r\n                                        const dst = new Uint8Array(data.length + 21 + (check_oz ? 0 : 28));\r\n                                        dst[\"set\"](data[\"subarray\"](0, nEndPos), 0);\r\n                                        let nLen_tEXt = 0;\r\n                                        if (!check_oz) {\r\n                                            _oz_Write_tEXt_Software(dst, nEndPos);\r\n                                            nLen_tEXt = 28;\r\n                                        }\r\n                                        _oz_Write_pHYs(dst, nEndPos + nLen_tEXt, pixel_info);\r\n                                        dst[\"set\"](data[\"subarray\"](nEndPos, data.length), nEndPos + nLen_tEXt + 21);\r\n                                        return dst;\r\n                                    }\r\n                                    return null;\r\n                                };\r\n\r\n                                const strValue = this.m_postprocessingImage;\r\n                                if(strValue.length >= 5 && strValue.substr(0, 5).toLowerCase() == \"data:\") {\r\n                                    nIndex = strValue.indexOf(\";base64,\");\r\n                                    if(nIndex < 0) {\r\n                                        nIndex = strValue.toLowerCase().indexOf(\";base64,\");\r\n                                    }\r\n                                    if(nIndex > 0) {\r\n                                        const data = _oz_base64Decoder(strValue.substring(nIndex+8));\r\n                                        const seal_dpi = resultMat[\"cols\"]* 2.54 / this.m_specBarcode[\"areaWidth\"];\r\n                                        const result = _oz_MakePNGWithDPI(data, seal_dpi);\r\n                                        if(result){\r\n                                            this.m_postprocessingImage = \"data:image/png;base64,\"+ _oz_base64Encode(result);\r\n                                        }\r\n                                    }\r\n                                }\r\n                                //////////////\r\n                            }\r\n                            resultMat.delete();\r\n                            resultMat = null;\r\n                            this.m_sealRecognizer.m_resultMat = null;\r\n                            this.m_sealRecognizer.dispose();\r\n                            this.m_sealRecognizer = null;\r\n\r\n                            result = 999;\r\n                        } // !this.m_sealRecognizer.getResult().empty()\r\n                    } // capture\r\n                } // findPatternArea\r\n            } catch (e) {\r\n                OZRecognitionPack.trace(e);\r\n                this.m_sealRecognizer.dispose();\r\n                this.m_sealRecognizer = null;\r\n                throw new Error(e);\r\n            }\r\n            return result;\r\n        } // ready\r\n    };\r\n\r\n    _this.dispose = function () {\r\n        if (this.m_cardRecognizer) {\r\n            this.m_cardRecognizer.dispose();\r\n            this.m_cardRecognizer = null;\r\n        }\r\n        if (this.m_sealRecognizer) {\r\n            this.m_sealRecognizer.dispose();\r\n            this.m_sealRecognizer = null;\r\n        }\r\n        this.m_preprocessingImage = null;\r\n        this.m_postprocessingImage = null;\r\n        this.m_specBarcode = null;\r\n        this.m_nSealSize = null;\r\n    };\r\n};\r\n\r\nOZRecognitionPack.trace = function (str) {\r\n    if (typeof window[\"__oz_recog_debug__\"] != \"undefined\" && window[\"__oz_recog_debug__\"]) {\r\n        const msg = \"[OZ TRACE] \" + str;\r\n        if ($(\"#oz_recog_debug\").length == 0) {\r\n            console.log(msg);\r\n        } else {\r\n            const log = $(\"#oz_recog_debug\").val();\r\n            if (log.length > 1000)\r\n                $(\"#oz_recog_debug\").val(msg);\r\n            else\r\n                $(\"#oz_recog_debug\").val(log + \"\\n\" + msg);\r\n        }\r\n    }\r\n};\r\n\r\nOZRecognitionPack.MODE_SEAL = 4;\r\nOZRecognitionPack.MODE_ID = 7;\nwindow[\"__oz_recog_debug__\"] = true;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvT1pSZWNvZ25pdGlvblBhY2suanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQiw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNEJBQTRCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsd0JBQXdCO0FBQ2hGLDREQUE0RCx3QkFBd0I7QUFDcEYsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsNERBQTRELFNBQVM7QUFDckU7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsNERBQTRELFNBQVM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxTQUFTO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsU0FBUztBQUM3RDtBQUNBLHdEQUF3RCxTQUFTO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRixtRkFBbUY7QUFDbkYsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUUsc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSkFBb0o7QUFDcEo7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vT1pTZWFsUmVjb2duaXRpb24vLi9zcmMvT1pSZWNvZ25pdGlvblBhY2suanM/OGY0YSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBPWlJlY29nbml0aW9uUGFjayA9IHdpbmRvd1tcIk9aUmVjb2duaXRpb25QYWNrXCJdID0gZnVuY3Rpb24obW9kZSkge1xyXG4gICAgY29uc3QgX3RoaXMgPSBPWlJlY29nbml0aW9uUGFjay5wcm90b3R5cGU7XHJcblxyXG4gICAgaWYgKG1vZGUgPT0gT1pSZWNvZ25pdGlvblBhY2suTU9ERV9JRClcclxuICAgICAgICB0aGlzLm1fY2FyZFJlY29nbml6ZXIgPSBuZXcgd2luZG93W1wiT1pDYXJkUmVjb2duaXplclwiXSgpO1xyXG4gICAgaWYgKG1vZGUgPT0gT1pSZWNvZ25pdGlvblBhY2suTU9ERV9TRUFMKVxyXG4gICAgICAgIHRoaXMubV9zZWFsUmVjb2duaXplciA9IG5ldyB3aW5kb3dbXCJPWlNlYWxSZWNvZ25pemVyXCJdKCk7XHJcblxyXG4gICAgdGhpcy5tX25GaW5kQ291bnQgPSAwO1xyXG4gICAgdGhpcy5tX3ByZXByb2Nlc3NpbmdJbWFnZSA9IFwiXCI7XHJcbiAgICB0aGlzLm1fcG9zdHByb2Nlc3NpbmdJbWFnZSA9IFwiXCI7XHJcbiAgICB0aGlzLm1fc3RyTWltZVR5cGUgPSBcIlwiO1xyXG5cclxuICAgIHRoaXMubV9zcGVjQmFyY29kZSA9IHt9O1xyXG4gICAgdGhpcy5tX25TZWFsU2l6ZSA9IDA7XHJcblxyXG4gICAgX3RoaXMuU2V0UmVzdWx0TWltZVR5cGUgPSBmdW5jdGlvbihzdHJNaW1lVHlwZSkge1xyXG4gICAgICAgIHRoaXMubV9zdHJNaW1lVHlwZSA9IHN0ck1pbWVUeXBlO1xyXG4gICAgfTtcclxuXHJcbiAgICBfdGhpcy5HZXRSZXN1bHRNaW1lVHlwZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm1fc3RyTWltZVR5cGUgPT0gXCJcIilcclxuICAgICAgICAgICAgcmV0dXJuIFwiaW1hZ2UvcG5nXCI7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLm1fc3RyTWltZVR5cGU7XHJcbiAgICB9O1xyXG5cclxuICAgIF90aGlzLmdldERhdGFGcm9tTWF0ID0gZnVuY3Rpb24gKG1hdCkgeyAvLyBpbWFnZURhdGEg7LaU7LacXHJcbiAgICAgICAgY29uc3QgcFRtcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgIHBUbXBDYW52YXMud2lkdGggPSBtYXRbXCJjb2xzXCJdO1xyXG4gICAgICAgIHBUbXBDYW52YXMuaGVpZ2h0ID0gbWF0W1wicm93c1wiXTtcclxuICAgICAgICBwVG1wQ2FudmFzLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiZGlzcGxheTpub25lO1wiKTtcclxuICAgICAgICBjdltcImltc2hvd1wiXShwVG1wQ2FudmFzLCBtYXQpO1xyXG5cclxuICAgICAgICBsZXQgZGF0YSA9IG51bGw7XHJcbiAgICAgICAgaWYgKHRoaXMubV9zdHJNaW1lVHlwZSA9PSBcIlwiKSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSBwVG1wQ2FudmFzLnRvRGF0YVVSTCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSBwVG1wQ2FudmFzLnRvRGF0YVVSTCh0aGlzLm1fc3RyTWltZVR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAkKHBUbXBDYW52YXMpLnJlbW92ZSgpO1xyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfTtcclxuXHJcbiAgICBfdGhpcy5HZXRQcmVwcm9jZXNzaW5nSW1hZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubV9wcmVwcm9jZXNzaW5nSW1hZ2U7XHJcbiAgICB9O1xyXG5cclxuICAgIF90aGlzLkdldFBvc3Rwcm9jZXNzaW5nSW1hZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubV9wb3N0cHJvY2Vzc2luZ0ltYWdlO1xyXG4gICAgfTtcclxuXHJcbiAgICBfdGhpcy5HZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tX2NhcmRSZWNvZ25pemVyLkdldFN0YXRlKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIF90aGlzLkdldFNlYWxTaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1fblNlYWxTaXplO1xyXG4gICAgfTtcclxuXHJcbiAgICBfdGhpcy5HZXRTcGVjQmFyY29kZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tX3NwZWNCYXJjb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICBfdGhpcy5Jc0ZvdW5kUGF0dGVybiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tX3NlYWxSZWNvZ25pemVyLklzRm91bmRQYXR0ZXJuKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIF90aGlzLklzRm91bmRSZWN0YW5nbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubV9zZWFsUmVjb2duaXplci5Jc0ZvdW5kUmVjdGFuZ2xlKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIF90aGlzLklzRm91bmRTcGVjQmFyY29kZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tX3NlYWxSZWNvZ25pemVyLklzRm91bmRTcGVjQmFyY29kZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfdGhpcy5maWxsTW9zYWljID0gZnVuY3Rpb24gKGltYWdlLCB4LCB5LCB3LCBoLCBtb3NhaWNTaXplKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoOyBpICs9IG1vc2FpY1NpemUpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3OyBqICs9IG1vc2FpY1NpemUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSB0aGlzLmdldFJhbmRvbUNvbG9yKGltYWdlLCB4ICsgaiwgeSArIGksIG1vc2FpY1NpemUgKiAzLCBtb3NhaWNTaXplICogMyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGxSZWN0KGltYWdlLCB4ICsgaiwgeSArIGksIG1vc2FpY1NpemUsIG1vc2FpY1NpemUsIGMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfdGhpcy5nZXRSYW5kb21Db2xvciA9IGZ1bmN0aW9uIChpbWFnZSwgeCwgeSwgdywgaCkge1xyXG4gICAgICAgIGlmICh4ICsgdyA+IGltYWdlLmNvbHMpIHtcclxuICAgICAgICAgICAgdyA9IGltYWdlLmNvbHMgLSB4IDw9IDAgPyAxIDogaW1hZ2UuY29scyAtIHg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh5ICsgaCA+IGltYWdlLnJvd3MpIHtcclxuICAgICAgICAgICAgaCA9IGltYWdlLnJvd3MgLSB5IDw9IDAgPyAxIDogaW1hZ2Uucm93cyAtIHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh4ID4gaW1hZ2UuY29scylcclxuICAgICAgICAgICAgeCA9IGltYWdlLmNvbHMgLSAxO1xyXG4gICAgICAgIGlmICh5ID4gaW1hZ2Uucm93cylcclxuICAgICAgICAgICAgeSA9IGltYWdlLnJvd3MgLSAxO1xyXG5cclxuICAgICAgICByZXR1cm4gaW1hZ2UudWNoYXJQdHIoeSArIChNYXRoLnJhbmRvbSgpICUgaCksIHggKyAoTWF0aC5yYW5kb20oKSAlIHcpKTtcclxuICAgIH07XHJcblxyXG4gICAgX3RoaXMuZmlsbFJlY3QgPSBmdW5jdGlvbiAoaW1hZ2UsIHgsIHksIHcsIGgsIGNvbG9yKSB7XHJcbiAgICAgICAgaWYgKHggKyB3ID4gaW1hZ2UuY29scykge1xyXG4gICAgICAgICAgICB3ID0gaW1hZ2UuY29scyAtIHg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh5ICsgaCA+IGltYWdlLnJvd3MpIHtcclxuICAgICAgICAgICAgaCA9IGltYWdlLnJvd3MgLSB5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3OyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGltYWdlLnVjaGFyUHRyKHkgKyBpLCB4ICsgailbMF0gPSBjb2xvclswXTtcclxuICAgICAgICAgICAgICAgIGltYWdlLnVjaGFyUHRyKHkgKyBpLCB4ICsgailbMV0gPSBjb2xvclsxXTtcclxuICAgICAgICAgICAgICAgIGltYWdlLnVjaGFyUHRyKHkgKyBpLCB4ICsgailbMl0gPSBjb2xvclsyXTtcclxuICAgICAgICAgICAgICAgIGltYWdlLnVjaGFyUHRyKHkgKyBpLCB4ICsgailbM10gPSBjb2xvclszXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgX3RoaXMuRmluZEFyZWEgPSBmdW5jdGlvbiAobkRQSSwgcEhpZGRlbkNhbnZhcywgdGFyZ2V0TWF0LCBwUGFwZXJJbmZvLCBwU2NhbkFyZWEsIHBTY2FuQXJlYUNlbnRlclBvaW50LCBuU2NhbldpZHRoLCBuU2NhbkhlaWdodCwgYklzUHJldmlldywgYklzRm9yY2VDYXB0dXJlKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IDk5ODtcclxuICAgICAgICBsZXQgcmVzdWx0TWF0ID0gbnVsbDtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tX2NhcmRSZWNvZ25pemVyLnJlYWR5KHBIaWRkZW5DYW52YXMsIHRhcmdldE1hdCwgcFNjYW5BcmVhLCBwU2NhbkFyZWFDZW50ZXJQb2ludCwgYklzUHJldmlldykpIHtcclxuICAgICAgICAgICAgICAgIGxldCByZXN1bHRNYXQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRXaWR0aCA9IHBQYXBlckluZm8uc2l6ZVdpZHRoO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0SGVpZ2h0ID0gcFBhcGVySW5mby5zaXplSGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChiSXNGb3JjZUNhcHR1cmUpIHsgLy/qsJXsoJzstKzsmIEg67CPIOyggOyepVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdE1hdCA9IHRoaXMubV9jYXJkUmVjb2duaXplci5mb3JjZUNhcHR1cmUodGFyZ2V0TWF0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1fY2FyZFJlY29nbml6ZXIuY20ycHgobkRQSSwgcmVzdWx0V2lkdGgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1fY2FyZFJlY29nbml6ZXIuY20ycHgobkRQSSwgcmVzdWx0SGVpZ2h0KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHVubWFza2VkIGltYWdlIOyggOyepVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubV9wcmVwcm9jZXNzaW5nSW1hZ2UgPSB0aGlzLmdldERhdGFGcm9tTWF0KHJlc3VsdE1hdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBtb3NhaWNTaXplID0gdGhpcy5tX2NhcmRSZWNvZ25pemVyLmNtMnB4KG5EUEksIDAuMDcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3NhaWNTaXplIDwgNikgbW9zYWljU2l6ZSA9IDY7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwUGFwZXJJbmZvLml0ZW0ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeCA9IHBhcnNlSW50KHRoaXMubV9jYXJkUmVjb2duaXplci5jbTJweChuRFBJLCBwUGFwZXJJbmZvLml0ZW1baV0ubGVmdCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB5ID0gcGFyc2VJbnQodGhpcy5tX2NhcmRSZWNvZ25pemVyLmNtMnB4KG5EUEksIHBQYXBlckluZm8uaXRlbVtpXS50b3ApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdyA9IHBhcnNlSW50KHRoaXMubV9jYXJkUmVjb2duaXplci5jbTJweChuRFBJLCBwUGFwZXJJbmZvLml0ZW1baV0ud2lkdGgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaCA9IHBhcnNlSW50KHRoaXMubV9jYXJkUmVjb2duaXplci5jbTJweChuRFBJLCBwUGFwZXJJbmZvLml0ZW1baV0uaGVpZ2h0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsbE1vc2FpYyhyZXN1bHRNYXQsIHgsIHksIHcsIGgsIG1vc2FpY1NpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFza2VkIGltYWdlIOyggOyepVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubV9wb3N0cHJvY2Vzc2luZ0ltYWdlID0gdGhpcy5nZXREYXRhRnJvbU1hdChyZXN1bHRNYXQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRNYXRbXCJkZWxldGVcIl0oKTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRNYXQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubV9jYXJkUmVjb2duaXplci5tX3Jlc3VsdE1hdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tX2NhcmRSZWNvZ25pemVyLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1fY2FyZFJlY29nbml6ZXIgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1fbkZpbmRDb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gOTk5O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tX2NhcmRSZWNvZ25pemVyLmZpbmQodGhpcy5tX25GaW5kQ291bnQrKykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g7Iug67aE7KadIOy1nOyGjCDsgqzsnbTspojripQgMzAl66GcIOqzoOyglVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuUHhSZXN1bHRXaWR0aCA9IHRoaXMubV9jYXJkUmVjb2duaXplci5jbTJweChuRFBJLCByZXN1bHRXaWR0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5QeFJlc3VsdEhlaWdodCA9IHRoaXMubV9jYXJkUmVjb2duaXplci5jbTJweChuRFBJLCByZXN1bHRIZWlnaHQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g7KeB7IKs6rCB7ZiV7J2YIOq8reyngOygkChtX2ZvdW5kUmVjdCnsnYQg7J207Jqp7ZW0IOydtOuvuOyngCDstpTstpwg7IucIO2FjOuRkOumrOqwgCDsnpjrpqzripQg7ZiE7IOB7J20IOyeiOyWtCBtYXJnaW4g6riw67O46rCS7JeQIDJtbeulvCDrjZTtlbQg67O07KCV7ZWoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtYXJnaW5MZWZ0ID0gdGhpcy5tX2NhcmRSZWNvZ25pemVyLmNtMnB4KG5EUEksIChwUGFwZXJJbmZvLnNpemVNYXJnaW4gKyAwLjIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWluV2lkdGggPSBuUHhSZXN1bHRXaWR0aCAqIDAuMztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmdpbkxlZnQgPiBtaW5XaWR0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbkxlZnQgPSBwYXJzZUludChtaW5XaWR0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hcmdpblRvcCA9IHBhcnNlSW50KG1hcmdpbkxlZnQgKiAoblNjYW5IZWlnaHQgLyBuU2NhbldpZHRoKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRNYXQgPSB0aGlzLm1fY2FyZFJlY29nbml6ZXIuY2FwdHVyZSh0YXJnZXRNYXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuUHhSZXN1bHRXaWR0aCwgblB4UmVzdWx0SGVpZ2h0LCBtYXJnaW5MZWZ0LCBtYXJnaW5Ub3ApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW5tYXNrZWQgaW1hZ2Ug7KCA7J6lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubV9wcmVwcm9jZXNzaW5nSW1hZ2UgPSB0aGlzLmdldERhdGFGcm9tTWF0KHJlc3VsdE1hdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzY2FsZVggPSAoblB4UmVzdWx0V2lkdGggLSBtYXJnaW5MZWZ0ICogMikgLyBuUHhSZXN1bHRXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NhbGVZID0gKG5QeFJlc3VsdEhlaWdodCAtIG1hcmdpblRvcCAqIDIpIC8gblB4UmVzdWx0SGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1vc2FpY1NpemUgPSB0aGlzLm1fY2FyZFJlY29nbml6ZXIuY20ycHgobkRQSSwgMC4wNyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb3NhaWNTaXplIDwgNikgbW9zYWljU2l6ZSA9IDY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcFBhcGVySW5mby5pdGVtLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB4ID0gdGhpcy5tX2NhcmRSZWNvZ25pemVyLmNtMnB4KG5EUEksIHBQYXBlckluZm8uaXRlbVtpXS5sZWZ0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHkgPSB0aGlzLm1fY2FyZFJlY29nbml6ZXIuY20ycHgobkRQSSwgcFBhcGVySW5mby5pdGVtW2ldLnRvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3ID0gdGhpcy5tX2NhcmRSZWNvZ25pemVyLmNtMnB4KG5EUEksIHBQYXBlckluZm8uaXRlbVtpXS53aWR0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoID0gdGhpcy5tX2NhcmRSZWNvZ25pemVyLmNtMnB4KG5EUEksIHBQYXBlckluZm8uaXRlbVtpXS5oZWlnaHQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IF94ID0gcGFyc2VJbnQoeCAqIHNjYWxlWCkgKyBtYXJnaW5MZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgX3kgPSBwYXJzZUludCh5ICogc2NhbGVZKSArIG1hcmdpblRvcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IF93ID0gcGFyc2VJbnQodyAqIHNjYWxlWCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBfaCA9IHBhcnNlSW50KGggKiBzY2FsZVkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maWxsTW9zYWljKHJlc3VsdE1hdCwgX3gsIF95LCBfdywgX2gsIG1vc2FpY1NpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXNrZWQgaW1hZ2Ug7KCA7J6lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubV9wb3N0cHJvY2Vzc2luZ0ltYWdlID0gdGhpcy5nZXREYXRhRnJvbU1hdChyZXN1bHRNYXQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0TWF0W1wiZGVsZXRlXCJdKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdE1hdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubV9jYXJkUmVjb2duaXplci5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubV9jYXJkUmVjb2duaXplciA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1fbkZpbmRDb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IDk5OTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIE9aUmVjb2duaXRpb25QYWNrLnRyYWNlKGUpO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0TWF0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdE1hdFtcImRlbGV0ZVwiXSgpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0TWF0ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm1fY2FyZFJlY29nbml6ZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLm1fY2FyZFJlY29nbml6ZXIgPSBudWxsO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF90aGlzLkZpbmRTZWFsID0gZnVuY3Rpb24gKG5EUEksIHBIaWRkZW5DYW52YXMsIHBIaWRkZW5NZXRhLCB0YXJnZXRNYXQsIHByb2Nlc3NUeXBlKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IDk5ODtcclxuICAgICAgICBpZiAodGhpcy5tX3NlYWxSZWNvZ25pemVyLnJlYWR5KG5EUEksIHBIaWRkZW5DYW52YXMsIHBIaWRkZW5NZXRhLCB0YXJnZXRNYXQpKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tX3NlYWxSZWNvZ25pemVyLmZpbmRQYXR0ZXJuQXJlYSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubV9zZWFsUmVjb2duaXplci5jYXB0dXJlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1fc2VhbFJlY29nbml6ZXIuZ2V0UmVzdWx0KCkuZW1wdHkoKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHRNYXQgPSB0aGlzLm1fc2VhbFJlY29nbml6ZXIuZ2V0UmVzdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwZWMgYmFyY29kZSDsoIDsnqVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubV9zcGVjQmFyY29kZSA9IHRoaXMubV9zZWFsUmVjb2duaXplci5nZXRTcGVjQmFyY29kZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXByb2Nlc3NpbmcgaW1hZ2Ug7KCA7J6lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1fcHJlcHJvY2Vzc2luZ0ltYWdlID0gdGhpcy5nZXREYXRhRnJvbU1hdChyZXN1bHRNYXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tX25TZWFsU2l6ZSA9IHJlc3VsdE1hdFtcImNvbHNcIl07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3NUeXBlICE9IE9aU2VhbFJlY29nbml6ZXIuTk9ORSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdyYXkgPSBuZXcgY3ZbXCJNYXRcIl0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdltcImN2dENvbG9yXCJdKHJlc3VsdE1hdCwgZ3JheSwgY3ZbXCJDT0xPUl9SR0IyR1JBWVwiXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpc0JOVyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpc05lZWRDaGFuZ2VQaXhlbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpc0FscGhhVHlwZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpc0dyYXkgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbG9yUiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbG9yRyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbG9yQiA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvY2Vzc1R5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBPWlNlYWxSZWNvZ25pemVyLkJMQUNLX0FORF9XSElURTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQk5XID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE9aU2VhbFJlY29nbml6ZXIuUkVEX0FORF9XSElURTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yUiA9IDI1NTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTmVlZENoYW5nZVBpeGVsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE9aU2VhbFJlY29nbml6ZXIuQkxBQ0tfQU5EX0JMQU5LOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNOZWVkQ2hhbmdlUGl4ZWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNBbHBoYVR5cGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgT1pTZWFsUmVjb2duaXplci5SRURfQU5EX0JMQU5LOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JSID0gMjU1O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNOZWVkQ2hhbmdlUGl4ZWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNBbHBoYVR5cGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgT1pTZWFsUmVjb2duaXplci5HUkFZU0NBTEU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0dyYXkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXNOZWVkQ2hhbmdlQ29sb3IgPSAoY29sb3JSICE9IDAgfHwgY29sb3JHICE9IDAgfHwgY29sb3JCICE9IDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNHcmF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN2W1wiYWRhcHRpdmVUaHJlc2hvbGRcIl0oZ3JheSwgcmVzdWx0TWF0LCAyNTUsIGN2W1wiQURBUFRJVkVfVEhSRVNIX01FQU5fQ1wiXSwgY3ZbXCJUSFJFU0hfQklOQVJZXCJdLCAyMDEsIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFja2dyb3VuZCA9IGN2W1wiTWF0XCJdW1wiemVyb3NcIl0ocmVzdWx0TWF0W1wicm93c1wiXSwgcmVzdWx0TWF0W1wiY29sc1wiXSwgY3ZbXCJDVl84VUMzXCJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3ZbXCJjdnRDb2xvclwiXShyZXN1bHRNYXQsIGJhY2tncm91bmQsIGN2W1wiQ09MT1JfR1JBWTJCR1JBXCJdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05lZWRDaGFuZ2VQaXhlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBiYWNrZ3JvdW5kW1wicm93c1wiXTsgKyt5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBiYWNrZ3JvdW5kW1wiY29sc1wiXTsgKyt4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsID0gYmFja2dyb3VuZFtcInVjaGFyUHRyXCJdKHksIHgpOyAvLyBjdjo6VmVjNGIgJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYkNoYW5nZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBbHBoYVR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHBpeGVsIGlzIHdoaXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGl4ZWxbMF0gPT0gMjU1ICYmIHBpeGVsWzFdID09IDI1NSAmJiBwaXhlbFsyXSA9PSAyNTUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgYWxwaGEgdG8gemVybzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaXhlbFszXSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYkNoYW5nZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmVlZENoYW5nZUNvbG9yICYmICFiQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGl4ZWxbMF0gPT0gMCAmJiBwaXhlbFsxXSA9PSAwICYmIHBpeGVsWzJdID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaXhlbFswXSA9IGNvbG9yUjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaXhlbFsxXSA9IGNvbG9yRztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaXhlbFsyXSA9IGNvbG9yQjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaXhlbFszXSA9IDI1NTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiQ2hhbmdlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRNYXQgPSBiYWNrZ3JvdW5kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdE1hdCA9IGdyYXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0JOVyB8fCBpc05lZWRDaGFuZ2VQaXhlbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3ZbXCJibHVyXCJdKHJlc3VsdE1hdCwgcmVzdWx0TWF0LCBuZXcgY3ZbXCJTaXplXCJdKDMsIDMpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcG9zdHByb2Nlc3NpbmcgaW1hZ2Ug7KCA7J6lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tX3Bvc3Rwcm9jZXNzaW5nSW1hZ2UgPSB0aGlzLmdldERhdGFGcm9tTWF0KHJlc3VsdE1hdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vIHN1cCA2OTYyIC0g7J246rCQIOyKpOy6lCDqsrDqs7zsl5Ag66mU7YOAIOuNsOydtO2EsCDstpTqsIAg6riw64qlIO2FjOyKpO2KuFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IF9vel9iYXNlNjRFbmNvZGUgPSBmdW5jdGlvbiAoc3JjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmluYXJ5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHNyYy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2h1bmtfc2l6ZSA9IDgxOTI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuIDw9IGNodW5rX3NpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5hcnkgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHNyYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNyYy5zbGljZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluYXJ5ID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gY2h1bmtfc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2h1bmsgPSBzcmMuc2xpY2UoaSwgaSArIGNodW5rX3NpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5hcnkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBjaHVuayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5hcnkgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmFyeSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHNyY1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5idG9hKGJpbmFyeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVlZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IF9vel9iYXNlNjREZWNvZGVyID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmluYXJ5X3N0cmluZyA9IHdpbmRvdy5hdG9iKHN0cik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW4gPSBiaW5hcnlfc3RyaW5nLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkc3QgPSBuZXcgVWludDhBcnJheShsZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRzdFtpXSA9IGJpbmFyeV9zdHJpbmcuY2hhckNvZGVBdChpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVlZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IF9vel9nZXRJbnRCaWdFbmRpYW4gPSBmdW5jdGlvbiAoZGF0YSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZGF0YVtvZmZzZXRdICYgMHhmZikgPDwgMjQgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRhdGFbb2Zmc2V0ICsgMV0gJiAweGZmKSA8PCAxNiB8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGF0YVtvZmZzZXQgKyAyXSAmIDB4ZmYpIDw8IDggfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyAzXSAmIDB4ZmY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBfb3pfc2V0SW50QmlnRW5kaWFuID0gZnVuY3Rpb24gKGRhdGEsIG9mZnNldCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAmIDB4RkZGRkZGRkY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgM10gPSAodmFsdWUpICYgMHhGRjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOCkgJiAweEZGO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNikgJiAweEZGO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW29mZnNldCArIDBdID0gKHZhbHVlID4+PiAyNCkgJiAweEZGO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgQ1JDMzJfbWFrZUNyY1RhYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjcmNUYWJsZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBuID0gMDsgbiA8IDI1NjsgbisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYyA9IG47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gODsgLS1rID49IDA7KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjICYgMSkgIT0gMCkgYyA9IDB4ZWRiODgzMjAgXiAoYyA+Pj4gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBjID0gYyA+Pj4gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyY1RhYmxlW25dID0gYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JjVGFibGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBDUkMzMl9jcmNUYWJsZSA9IENSQzMyX21ha2VDcmNUYWJsZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IF9vel9Xcml0ZV9wSFlzID0gZnVuY3Rpb24gKGRzdCwgb2Zmc2V0LCBwaXhlbF9pbmZvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9vel9zZXRJbnRCaWdFbmRpYW4oZHN0LCBvZmZzZXQsIDkpOyAvL2NodW5rTGVuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9vel9zZXRJbnRCaWdFbmRpYW4oZHN0LCBvZmZzZXQgKyA0LCAweDcwNDg1OTczKTsgLy9jaHVua1R5cGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNyYyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rRGF0YSA9IG5ldyBVaW50OEFycmF5KDkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfb3pfc2V0SW50QmlnRW5kaWFuKGNodW5rRGF0YSwgMCwgcGl4ZWxfaW5mbyk7IC8veFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfb3pfc2V0SW50QmlnRW5kaWFuKGNodW5rRGF0YSwgNCwgcGl4ZWxfaW5mbyk7IC8veVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVua0RhdGFbOF0gPSAxOyAvL3VuaXQgaXMgdGhlIG1ldGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjID0gfmNyYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsZW4gPSBjaHVua0RhdGEubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG9mZiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoLS1sZW4gPj0gMCkgYyA9IENSQzMyX2NyY1RhYmxlWyhjIF4gY2h1bmtEYXRhW29mZisrXSkgJiAweGZmXSBeIChjID4+PiA4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyYyA9IH5jO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JjID0gY3JjICYgMHhmZmZmZmZmZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkc3RbXCJzZXRcIl0oY2h1bmtEYXRhLCBvZmZzZXQgKyA4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX296X3NldEludEJpZ0VuZGlhbihkc3QsIG9mZnNldCArIDE3LCBjcmMpOyAvL2NyY1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgX296X1dyaXRlX3RFWHRfU29mdHdhcmUgPSBmdW5jdGlvbiAoZHN0LCBvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX296X3NldEludEJpZ0VuZGlhbihkc3QsIG9mZnNldCwgMTYpOyAvL2NodW5rTGVuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9vel9zZXRJbnRCaWdFbmRpYW4oZHN0LCBvZmZzZXQgKyA0LCAweDc0NDU1ODc0KTsgLy9jaHVua1R5cGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNyYyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rRGF0YSA9IG5ldyBVaW50OEFycmF5KDE2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX296X3NldEludEJpZ0VuZGlhbihjaHVua0RhdGEsIDAsIDB4NTM2RjY2NzQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfb3pfc2V0SW50QmlnRW5kaWFuKGNodW5rRGF0YSwgNCwgMHg3NzYxNzI2NSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9vel9zZXRJbnRCaWdFbmRpYW4oY2h1bmtEYXRhLCA4LCAweDAwNEY1QTUzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX296X3NldEludEJpZ0VuZGlhbihjaHVua0RhdGEsIDEyLCAweDY1NjE2QzMxKTsge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGMgPSB+Y3JjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxlbiA9IGNodW5rRGF0YS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgb2ZmID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgtLWxlbiA+PSAwKSBjID0gQ1JDMzJfY3JjVGFibGVbKGMgXiBjaHVua0RhdGFbb2ZmKytdKSAmIDB4ZmZdIF4gKGMgPj4+IDgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JjID0gfmM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmMgPSBjcmMgJiAweGZmZmZmZmZmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRzdFtcInNldFwiXShjaHVua0RhdGEsIG9mZnNldCArIDgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfb3pfc2V0SW50QmlnRW5kaWFuKGRzdCwgb2Zmc2V0ICsgMjQsIGNyYyk7IC8vY3JjXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBfb3pfTWFrZVBOR1dpdGhEUEkgPSBmdW5jdGlvbiAoZGF0YSwgZHBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG9mZnNldCArIDQpID4gZGF0YS5sZW5ndGgpIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYWdpYzEgPSBfb3pfZ2V0SW50QmlnRW5kaWFuKGRhdGEsIG9mZnNldCkgPj4+IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG9mZnNldCArIDQpID4gZGF0YS5sZW5ndGgpIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYWdpYzIgPSBfb3pfZ2V0SW50QmlnRW5kaWFuKGRhdGEsIG9mZnNldCkgPj4+IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtYWdpYzEgPT0gMHg4OTUwNGU0NyAmJiBtYWdpYzIgPT0gMHgwZDBhMWEwYSkpIHsgLy8gbWFnaWNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjaGVja19veiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbkVuZFBvcyA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChvZmZzZXQgKyA0KSA+IGRhdGEubGVuZ3RoKSBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rTGVuID0gX296X2dldEludEJpZ0VuZGlhbihkYXRhLCBvZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG9mZnNldCArIDQpID4gZGF0YS5sZW5ndGgpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmtUeXBlID0gX296X2dldEludEJpZ0VuZGlhbihkYXRhLCBvZmZzZXQpID4+PiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLzB4NDk0ODQ0NTIgICAvL0lIRFJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vMHg3MDQ4NTk3MyAgIC8vcEhZc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8weDQ5NDQ0MTU0ICAgLy9JREFUXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLzB4NDk0NTRFNDQgICAvL0lFTkRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vMHg3NDQ1NTg3NCAgIC8vdEVYdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rVHlwZSA9PSAweDcwNDg1OTczKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChvZmZzZXQgKyA0KSA+IGRhdGEubGVuZ3RoKSBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB4UGl4ZWwgPSBfb3pfZ2V0SW50QmlnRW5kaWFuKGRhdGEsIG9mZnNldCkgPj4+IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChvZmZzZXQgKyA0KSA+IGRhdGEubGVuZ3RoKSBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB5UGl4ZWwgPSBfb3pfZ2V0SW50QmlnRW5kaWFuKGRhdGEsIG9mZnNldCkgPj4+IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChvZmZzZXQgKyAxKSA+IGRhdGEubGVuZ3RoKSBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcGkgPSBkcGkgLyAwLjAyNTQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGl4ZWxfaW5mbyA9IChkcGkgKyAwLjUpIHwgMDsgLy8gcm91bmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKChkYXRhW29mZnNldF0gJiAweGZmKSA9PSAxKSAmJiAocGl4ZWxfaW5mbyA9PSB4UGl4ZWwpICYmIChwaXhlbF9pbmZvID09IHlQaXhlbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrX296KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgLT0gMTY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZHN0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggKyAoY2hlY2tfb3ogPyAwIDogMjgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkc3RbXCJzZXRcIl0oZGF0YVtcInN1YmFycmF5XCJdKDAsIG9mZnNldCksIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuTGVuX3RFWHQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2hlY2tfb3opIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX296X1dyaXRlX3RFWHRfU29mdHdhcmUoZHN0LCBvZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuTGVuX3RFWHQgPSAyODtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX296X1dyaXRlX3BIWXMoZHN0LCBvZmZzZXQgKyBuTGVuX3RFWHQsIHBpeGVsX2luZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRzdFtcInNldFwiXShkYXRhW1wic3ViYXJyYXlcIl0ob2Zmc2V0ICsgMjEsIGRhdGEubGVuZ3RoKSwgb2Zmc2V0ICsgbkxlbl90RVh0ICsgMjEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNodW5rVHlwZSA9PSAweDc0NDU1ODc0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rTGVuID09IDE2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgob2Zmc2V0ICsgMTYpID4gZGF0YS5sZW5ndGgpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eHQxID0gX296X2dldEludEJpZ0VuZGlhbihkYXRhLCBvZmZzZXQpID4+PiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHh0MiA9IF9vel9nZXRJbnRCaWdFbmRpYW4oZGF0YSwgb2Zmc2V0KSA+Pj4gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4dDMgPSBfb3pfZ2V0SW50QmlnRW5kaWFuKGRhdGEsIG9mZnNldCkgPj4+IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eHQ0ID0gX296X2dldEludEJpZ0VuZGlhbihkYXRhLCBvZmZzZXQpID4+PiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0eHQxID09IDB4NTM2RjY2NzQpICYmICh0eHQyID09IDB4Nzc2MTcyNjUpICYmICh0eHQzID09IDB4MDA0RjVBNTMpICYmICh0eHQ0ID09IDB4NjU2MTZDMzEpKSB7IC8vU29mdHdhcmVcXDBPWlNlYWwxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja19veiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0IC09IDE2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2h1bmtUeXBlID09IDB4NDk0NDQxNTQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuRW5kUG9zID0gb2Zmc2V0IC0gODtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2h1bmtUeXBlID09IDB4NDk0NTRFNDQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSBjaHVua0xlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSA0OyAvL2NyY1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuRW5kUG9zID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRwaSA9IGRwaSAvIDAuMDI1NDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsX2luZm8gPSAoZHBpICsgMC41KSB8IDA7IC8vIHJvdW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkc3QgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCArIDIxICsgKGNoZWNrX296ID8gMCA6IDI4KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkc3RbXCJzZXRcIl0oZGF0YVtcInN1YmFycmF5XCJdKDAsIG5FbmRQb3MpLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuTGVuX3RFWHQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGVja19veikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9vel9Xcml0ZV90RVh0X1NvZnR3YXJlKGRzdCwgbkVuZFBvcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbkxlbl90RVh0ID0gMjg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfb3pfV3JpdGVfcEhZcyhkc3QsIG5FbmRQb3MgKyBuTGVuX3RFWHQsIHBpeGVsX2luZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHN0W1wic2V0XCJdKGRhdGFbXCJzdWJhcnJheVwiXShuRW5kUG9zLCBkYXRhLmxlbmd0aCksIG5FbmRQb3MgKyBuTGVuX3RFWHQgKyAyMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHN0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0clZhbHVlID0gdGhpcy5tX3Bvc3Rwcm9jZXNzaW5nSW1hZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3RyVmFsdWUubGVuZ3RoID49IDUgJiYgc3RyVmFsdWUuc3Vic3RyKDAsIDUpLnRvTG93ZXJDYXNlKCkgPT0gXCJkYXRhOlwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5JbmRleCA9IHN0clZhbHVlLmluZGV4T2YoXCI7YmFzZTY0LFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYobkluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbkluZGV4ID0gc3RyVmFsdWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiO2Jhc2U2NCxcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYobkluZGV4ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IF9vel9iYXNlNjREZWNvZGVyKHN0clZhbHVlLnN1YnN0cmluZyhuSW5kZXgrOCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VhbF9kcGkgPSByZXN1bHRNYXRbXCJjb2xzXCJdKiAyLjU0IC8gdGhpcy5tX3NwZWNCYXJjb2RlW1wiYXJlYVdpZHRoXCJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gX296X01ha2VQTkdXaXRoRFBJKGRhdGEsIHNlYWxfZHBpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJlc3VsdCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tX3Bvc3Rwcm9jZXNzaW5nSW1hZ2UgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxcIisgX296X2Jhc2U2NEVuY29kZShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRNYXQuZGVsZXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRNYXQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tX3NlYWxSZWNvZ25pemVyLm1fcmVzdWx0TWF0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubV9zZWFsUmVjb2duaXplci5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1fc2VhbFJlY29nbml6ZXIgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IDk5OTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSAvLyAhdGhpcy5tX3NlYWxSZWNvZ25pemVyLmdldFJlc3VsdCgpLmVtcHR5KClcclxuICAgICAgICAgICAgICAgICAgICB9IC8vIGNhcHR1cmVcclxuICAgICAgICAgICAgICAgIH0gLy8gZmluZFBhdHRlcm5BcmVhXHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIE9aUmVjb2duaXRpb25QYWNrLnRyYWNlKGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tX3NlYWxSZWNvZ25pemVyLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubV9zZWFsUmVjb2duaXplciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9IC8vIHJlYWR5XHJcbiAgICB9O1xyXG5cclxuICAgIF90aGlzLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubV9jYXJkUmVjb2duaXplcikge1xyXG4gICAgICAgICAgICB0aGlzLm1fY2FyZFJlY29nbml6ZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLm1fY2FyZFJlY29nbml6ZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5tX3NlYWxSZWNvZ25pemVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMubV9zZWFsUmVjb2duaXplci5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIHRoaXMubV9zZWFsUmVjb2duaXplciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubV9wcmVwcm9jZXNzaW5nSW1hZ2UgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubV9wb3N0cHJvY2Vzc2luZ0ltYWdlID0gbnVsbDtcclxuICAgICAgICB0aGlzLm1fc3BlY0JhcmNvZGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubV9uU2VhbFNpemUgPSBudWxsO1xyXG4gICAgfTtcclxufTtcclxuXHJcbk9aUmVjb2duaXRpb25QYWNrLnRyYWNlID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3dbXCJfX296X3JlY29nX2RlYnVnX19cIl0gIT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3dbXCJfX296X3JlY29nX2RlYnVnX19cIl0pIHtcclxuICAgICAgICBjb25zdCBtc2cgPSBcIltPWiBUUkFDRV0gXCIgKyBzdHI7XHJcbiAgICAgICAgaWYgKCQoXCIjb3pfcmVjb2dfZGVidWdcIikubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2cobXNnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBsb2cgPSAkKFwiI296X3JlY29nX2RlYnVnXCIpLnZhbCgpO1xyXG4gICAgICAgICAgICBpZiAobG9nLmxlbmd0aCA+IDEwMDApXHJcbiAgICAgICAgICAgICAgICAkKFwiI296X3JlY29nX2RlYnVnXCIpLnZhbChtc2cpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAkKFwiI296X3JlY29nX2RlYnVnXCIpLnZhbChsb2cgKyBcIlxcblwiICsgbXNnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5PWlJlY29nbml0aW9uUGFjay5NT0RFX1NFQUwgPSA0O1xyXG5PWlJlY29nbml0aW9uUGFjay5NT0RFX0lEID0gNztcbndpbmRvd1tcIl9fb3pfcmVjb2dfZGVidWdfX1wiXSA9IHRydWU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/OZRecognitionPack.js\n");

/***/ }),

/***/ "./src/OZSealPreview.js":
/*!******************************!*\
  !*** ./src/OZSealPreview.js ***!
  \******************************/
/***/ (() => {

eval("const OZSealPreview = window[\"OZSealPreview\"] = function(nDPI, nProcessType) {\r\n    const _this = OZSealPreview.prototype;\r\n\r\n    this.m_myUI = null;\r\n    this.m_nDPI = nDPI;\r\n    this.m_nProcessType = nProcessType;\r\n    this.m_constraints = {};\r\n    this.m_videoTracks = null;\r\n    this.m_pCanvasUpdateFunc = null;\r\n    this.m_pRecognitionPack = null;\r\n    this.m_bFacingMode = false;\r\n    this.m_pVideo = null;\r\n    this.m_pTmpCanvas = null;\r\n    this.m_pTargetMat = null;\r\n    this.m_pEndCallback = null;\r\n    this.m_nContentsWidth = 0;\r\n    this.m_nContentsHeight = 0;\r\n    this.m_nVideoMinWidth = 1280;\r\n    this.m_nVideoMinHeight = 720;\r\n    this.m_pFile = null;\r\n    this.m_strMimeType = \"\";\r\n    \r\n    /**\r\n     * 메모리 해제용 함수\r\n     */\r\n    _this[\"Dispose\"] = function() {\r\n        this.stopPreview();\r\n\r\n        if (this.m_myUI) {\r\n            this.m_pVideo = null;\r\n            this.m_pTmpCanvas = null;\r\n            $(this.m_myUI).remove();\r\n            this.m_myUI = null;\r\n        }\r\n        if (this.m_pRecognitionPack) {\r\n            this.m_pRecognitionPack.dispose();\r\n            this.m_pRecognitionPack = null;\r\n        }\r\n        if (this.m_pTargetMat) {\r\n            this.m_pTargetMat[\"delete\"]();\r\n            this.m_pTargetMat = null;\r\n        }\r\n        this.m_nDPI = null;\r\n        this.m_nProcessType = null;\r\n        this.m_constraints = null;\r\n        this.m_pEndCallback = null;\r\n    };\r\n\r\n    _this.InitConstraints = function() {\r\n        const pConstraints = {};\r\n        pConstraints[\"audio\"] = false;\r\n        pConstraints[\"video\"] = {};\r\n\r\n        //var bFacingMode = document.getElementById(\"btn_facingmode\").checked;\r\n        //pConstraints[\"video\"][\"facingMode\"] = (this.m_bFacingMode ? { [\"exact\"]: \"user\" } : { [\"exact\"]: \"environment\" });\r\n        let facingMode = {};\r\n        facingMode[\"exact\"] = \"environment\";\r\n        if (this.m_bFacingMode) {\r\n            facingMode = \"user\";\r\n        }\r\n        pConstraints[\"video\"][\"facingMode\"] = facingMode;\r\n\r\n        let width = {};\r\n        let height = {};\r\n\r\n        width[\"min\"] = this.m_nVideoMinWidth;\r\n        height[\"min\"] = this.m_nVideoMinHeight;\r\n        \r\n        width[\"ideal\"] = this.m_nContentsWidth;\r\n        height[\"ideal\"] = this.m_nContentsHeight;\r\n\r\n        if (window.innerWidth > window.innerHeight) {\r\n            pConstraints[\"video\"].width = width;\r\n            pConstraints[\"video\"].height = height;\r\n        } else {\r\n            pConstraints[\"video\"].width = height;\r\n            pConstraints[\"video\"].height = width;\r\n        }\r\n\r\n        pConstraints[\"video\"][\"advanced\"] = [{ \"focusMode\": \"continuous\" }];\r\n        this.m_constraints = pConstraints;\r\n    };\r\n\r\n    _this.SetMediaStream = function() {\r\n        this.InitConstraints();\r\n\r\n        const oThis = this;\r\n        navigator.mediaDevices.getUserMedia(this.m_constraints)\r\n        .then(function(mediaStream) {\r\n            // Older browsers may not have srcObject\r\n            if (\"srcObject\" in oThis.m_pVideo) {\r\n                oThis.m_pVideo.srcObject = mediaStream;\r\n            } else {\r\n                var vendorURL = window.URL || window.webkitURL;\r\n                // Avoid using this in new browsers, as it is going away.\r\n                oThis.m_pVideo.src = vendorURL.createObjectURL(mediaStream);\r\n            }\r\n            oThis.m_videoTracks = mediaStream.getVideoTracks();\r\n            oThis.m_pVideo.onloadedmetadata = function(e) {\r\n                oThis.m_pVideo.play();\r\n                oThis.m_pVideo.width = oThis.m_pVideo.videoWidth;\r\n                oThis.m_pVideo.height = oThis.m_pVideo.videoHeight;\r\n                oThis.StartFindSeal();\r\n            };\r\n        }).catch(function(err) {\r\n            if (oThis.m_bFacingMode) {\r\n                OZRecognitionPack[\"trace\"](err.name + \": \" + err.message);\r\n                oThis[\"FindSealFromFile\"](oThis.m_pEndCallback);\r\n            } else {\r\n                oThis.m_bFacingMode = true;\r\n                oThis.SetMediaStream();\r\n            }\r\n        });\r\n    };\r\n\r\n    _this.StartFindSeal = function() {\r\n        this.showPreview(true);\r\n        if (this.m_videoTracks) {\r\n            var currentTrack = this.m_videoTracks[0];\r\n            if (currentTrack && currentTrack.applyConstraints) {\r\n                var bUpdate;\r\n                if (this.m_pVideo.paused || this.m_pVideo.ended) {\r\n                    // srcObject ? active state check\r\n                    bUpdate = false;\r\n                } else {\r\n                    bUpdate = true;\r\n                }\r\n                if (bUpdate) {\r\n                    const nFPS = 1200;\r\n                    const video = this.m_pVideo;\r\n                    const pHiddenCanvas = this.m_pTmpCanvas; //document.createElement(\"canvas\");\r\n                    const pCtx = this.m_pTmpCanvas.getContext(\"2d\");\r\n\r\n                    const pHiddenMeta = document.createElement('canvas');\r\n                    $(pHiddenMeta)[\"css\"](\"display\", \"none\");\r\n\r\n                    try {\r\n                        this.m_pRecognitionPack = new OZRecognitionPack(OZRecognitionPack.MODE_SEAL);\r\n                        this.m_pRecognitionPack.SetResultMimeType(this.m_strMimeType);\r\n\r\n                        const nDPI = this.m_nDPI;\r\n                        const processType = this.m_nProcessType;\r\n\r\n                        const tmpCanvasRect = this.getTmpCanvasRect(video.videoWidth, video.videoHeight);\r\n                        const sx = tmpCanvasRect.Left;\r\n                        const sy = tmpCanvasRect.Top;\r\n                        pHiddenCanvas.width = tmpCanvasRect.Width;\r\n                        pHiddenCanvas.height = tmpCanvasRect.Height;\r\n                        this.m_pTargetMat = new cv[\"Mat\"](pHiddenCanvas.height, pHiddenCanvas.width, cv[\"CV_8UC4\"]);\r\n\r\n\r\n                        const oThis = this;\r\n                        this.m_pCanvasUpdateFunc = setInterval(function() {\r\n                            //var nPrevTime = (new Date()).getTime();\r\n                            pCtx.drawImage(video, sx, sy, pHiddenCanvas.width, pHiddenCanvas.height,\r\n                                0, 0, pHiddenCanvas.width, pHiddenCanvas.height);\r\n                            \r\n                            oThis.m_pTargetMat.data.set(pCtx.getImageData(0, 0, pHiddenCanvas.width, pHiddenCanvas.height).data);\r\n                            try {\r\n                                if (oThis.m_pRecognitionPack.FindSeal(nDPI, pHiddenCanvas, pHiddenMeta, oThis.m_pTargetMat, processType) == 999) {\r\n                                    oThis.stopPreview();\r\n                                    oThis.showPreview(false);\r\n                                    // 인식 결과(가이드) 보여주기\r\n                                    cv[\"imshow\"](pHiddenCanvas, oThis.m_pTargetMat);\r\n    \r\n                                    oThis.m_pTargetMat[\"delete\"]();\r\n                                    oThis.m_pTargetMat = null;\r\n                                            \r\n                                    $(pHiddenMeta).remove();\r\n\r\n                                    // 촬영 후 1초 뒤 콜백함수 호출\r\n                                    setTimeout(function() {\r\n                                        $(oThis.m_myUI)[\"css\"](\"display\", \"none\");\r\n                                        if (typeof oThis.m_pEndCallback == \"function\") {\r\n                                            oThis.m_pEndCallback(true);\r\n                                        }\r\n                                    }, 1000);\r\n                                    //return;\r\n                                } else { // 인식 실패\r\n                                    if (oThis.m_pRecognitionPack.IsFoundPattern() || oThis.m_pRecognitionPack.IsFoundRectangle() || oThis.m_pRecognitionPack.IsFoundSpecBarcode()) {\r\n                                        cv[\"imshow\"](pHiddenCanvas, oThis.m_pTargetMat);\r\n                                        oThis.showPreview(false);\r\n                                        video.pause();\r\n    \r\n                                        setTimeout(function() {\r\n                                            oThis.showPreview(true);\r\n                                            video.play();\r\n                                        }, 200);\r\n                                    }\r\n                                }\r\n                            } catch (e) {\r\n                                oThis.stopPreview();\r\n                                OZRecognitionPack[\"trace\"](e.name + \": \" + e.message);\r\n                                if (this.m_pTargetMat) {\r\n                                    this.m_pTargetMat[\"delete\"]();\r\n                                    this.m_pTargetMat = null;\r\n                                }\r\n                                $(pHiddenMeta).remove();\r\n                            }\r\n                            //console.log( ((((new Date()).getTime()) - nPrevTime) / 1000).toFixed(3) + \"s\");\r\n                        }, nFPS); // setInterval\r\n                    } catch (err) {\r\n                        OZRecognitionPack[\"trace\"](err.name + \": \" + err.message);\r\n                        if (this.m_pTargetMat) {\r\n                            this.m_pTargetMat[\"delete\"]();\r\n                            this.m_pTargetMat = null;\r\n                        }\r\n                        $(pHiddenMeta).remove();\r\n                    } \r\n                }\r\n            }\r\n        } else {\r\n            OZRecognitionPack[\"trace\"](\"!videoTracks\");\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 미리보기를 시작시키는 함수(재시작할 때도 사용가능)\r\n     */\r\n    _this[\"StartCapture\"] = function() {\r\n        this.stopPreview();\r\n        this.showPreview(true);\r\n        this.SetMediaStream();\r\n    };\r\n    _this[\"StopCapture\"] = function() {\r\n        this.stopPreview();\r\n    };\r\n\r\n    _this.showPreview = function(b) {\r\n        if (b) {\r\n            $(this.m_pTmpCanvas)[\"css\"](\"display\",\"none\");\r\n            $(this.m_pVideo)[\"css\"](\"display\",\"block\");\r\n        } else {\r\n            $(this.m_pTmpCanvas)[\"css\"](\"display\",\"block\");\r\n            $(this.m_pVideo)[\"css\"](\"display\",\"none\");\r\n        }\r\n    };\r\n\r\n    _this.stopPreview = function() {\r\n        if (this.m_pCanvasUpdateFunc) {\r\n            clearInterval(this.m_pCanvasUpdateFunc);\r\n            this.m_pCanvasUpdateFunc = null;\r\n        }\r\n        if (this.m_videoTracks) {\r\n            this.m_videoTracks.forEach(function(track) { track.stop() });\r\n            this.m_videoTracks = null;\r\n        }\r\n        if (this.m_pVideo) {\r\n            if (\"srcObject\" in this.m_pVideo) {\r\n                this.m_pVideo.srcObject = null;\r\n            } else {\r\n                this.m_pVideo.src = null;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * SealPreviewDiv를 붙이는 함수\r\n     * @param target PreviewDiv가 붙을 엘리먼트\r\n     * @param nContentsWidth 미리보기 너비\r\n     * @param nContentsHeight 미리보기 높이\r\n     * @param pEndCallback 인감 스캔 후 호출될 콜백\r\n     * @return SealPreviewDiv 생성된 SealPreviewDiv\r\n     */\r\n    _this[\"ShowPreviewOn\"] = function(target, nContentsWidth, nContentsHeight, pEndCallback, bIgnore) {\r\n        this.m_pEndCallback = pEndCallback;\r\n        this.m_myUI = document.createElement(\"div\");\r\n        \r\n        $(this.m_myUI)[\"css\"](\"width\", nContentsWidth + \"px\");\r\n        $(this.m_myUI)[\"css\"](\"height\", nContentsHeight + \"px\");\r\n        $(this.m_myUI)[\"css\"](\"display\", \"flex\");\r\n\r\n        if(!bIgnore) {\r\n            let margin = 0;\r\n            if (nContentsWidth > nContentsHeight) {\r\n                margin = nContentsWidth * 0.05;\r\n            } else {\r\n                margin = nContentsHeight * 0.05;\r\n            }   \r\n            this.m_nContentsWidth = nContentsWidth - margin;\r\n            this.m_nContentsHeight = nContentsHeight - margin;\r\n        } else {\r\n            this.m_nContentsWidth = nContentsWidth;\r\n            this.m_nContentsHeight = nContentsHeight;\r\n        }\r\n        this.m_nContentsWidth = Math.round(this.m_nContentsWidth);\r\n        this.m_nContentsHeight = Math.round(this.m_nContentsHeight);\r\n\r\n        const pDivPreview = document.createElement(\"div\");\r\n        $(pDivPreview)[\"css\"](\"border\", \"1px solid black\")\r\n            [\"css\"](\"overflow\", \"hidden\")\r\n            [\"css\"](\"margin\", \"auto\")\r\n            [\"css\"](\"background-color\", \"black\");\r\n\r\n        const pVideoPreview = document.createElement(\"video\");\r\n        $(pVideoPreview).attr(\"playsinline\",  \"\");\r\n        $(pVideoPreview)[\"css\"](\"display\", \"block\")\r\n            [\"css\"](\"object-fit\", \"cover\")\r\n            [\"css\"](\"margin\", \"auto\")\r\n            [\"css\"](\"width\", this.m_nContentsWidth + \"px\")\r\n            [\"css\"](\"height\", this.m_nContentsHeight + \"px\");\r\n\r\n        this.m_pVideo = pVideoPreview;\r\n        const pCanvasOutput = document.createElement(\"canvas\");\r\n        $(pCanvasOutput)[\"css\"](\"display\", \"none\")\r\n            [\"css\"](\"margin\", \"auto\")\r\n            [\"css\"](\"width\", this.m_nContentsWidth + \"px\")\r\n            [\"css\"](\"height\", this.m_nContentsHeight + \"px\");\r\n\r\n        $(pDivPreview).append(pVideoPreview).append(pCanvasOutput);\r\n        $(this.m_myUI).append(pDivPreview);\r\n\r\n        this.m_pTmpCanvas = pCanvasOutput;\r\n        $(target).append(this.m_myUI);\r\n        return this.m_myUI;\r\n    };\r\n\r\n    _this.getTmpCanvasRect = function(videoWidth, videoHeight) {\r\n        const pRect = {};\r\n\t\tpRect.Left = 0;\r\n\t\tpRect.Top = 0;\r\n\t\tpRect.Width = videoWidth;\r\n\t\tpRect.Height = videoHeight;\r\n\t\tif (videoWidth / this.m_nContentsWidth > videoHeight / this.m_nContentsHeight) {\r\n\t\t\tpRect.Width = this.m_nContentsWidth * videoHeight / this.m_nContentsHeight;\r\n\t\t\tpRect.Left += (videoWidth - pRect.Width) / 2;\r\n\t\t} else {\r\n\t\t\tpRect.Height = this.m_nContentsHeight * videoWidth / this.m_nContentsWidth;\r\n\t\t\tpRect.Top += (videoHeight - pRect.Height) / 2;\r\n\t\t}\r\n\t\treturn pRect;\r\n    };\r\n\r\n    /**\r\n     * SealPreviewDiv여부를 반환\r\n     * @return SealPreviewDiv유무\r\n     */\r\n    _this[\"IsShown\"] = function() {\r\n        return (this.m_myUI != null);\r\n    };\r\n\r\n    /**\r\n     * 인감 프리뷰를 사용 못 할 때 카메라 촬영 또는 파일 탐색으로 인감 인식하는 함수\r\n     * capture=camera 속성을 지원하지 않으면 파일 탐색으로 동작\r\n     * @param pEndCallback 함수처리 후 호출될 콜백함수\r\n     */\r\n    _this[\"FindSealFromFile\"] = function(pEndCallback) {\r\n        if (!this.m_pFile) {\r\n            this.m_pFile = document.createElement(\"input\");\r\n            $(this.m_pFile).attr(\"type\", \"file\");\r\n            $(this.m_pFile).attr(\"accept\", \"image/*\");\r\n            $(this.m_pFile).attr(\"capture\", \"camera\");\r\n            $(this.m_pFile)[\"css\"](\"display\", \"none\");\r\n            const oThis = this;\r\n            $(this.m_pFile).on(\"change\", function() {\r\n                oThis[\"FindSealFromImage\"](URL.createObjectURL(this.files[0]), pEndCallback);\r\n                $(oThis.m_pFile).remove();\r\n                oThis.m_pFile = null;\r\n            });\r\n            $(document.body).append(this.m_pFile);\r\n        }\r\n        $(this.m_pFile).click();\r\n    };\r\n\r\n    /**\r\n     * 전달받은 이미지 데이터로 인감 인식하는 함수\r\n     * @param src 이미지 데이터\r\n     * @param pEndCallback 함수처리 후 호출될 콜백함수\r\n     */\r\n    _this[\"FindSealFromImage\"] = function(src, pEndCallback) {\r\n        this.m_pEndCallback = pEndCallback;\r\n        const selectedImg = new Image();\r\n        $(selectedImg)[\"css\"](\"display\", \"none\");\r\n        $(selectedImg).attr(\"src\", src);\r\n        const oThis = this;\r\n        $(selectedImg).on(\"load\", function() {\r\n            \r\n            // HD(1280*720)에 근접하게 이미지 사이즈 보정 (긴 면이 1280 사이즈로 설정되도록 함)\r\n            const bLandscape = selectedImg.width > selectedImg.height;\r\n            const nRatio = 1280 / (bLandscape ? selectedImg.width : selectedImg.height);\r\n            selectedImg.width *= nRatio;\r\n            selectedImg.height *= nRatio;\r\n            \r\n            let pHiddenCanvas = null;\r\n            let pHiddenMeta = null;\r\n            try {\r\n                const imgSeal = selectedImg;\r\n                const nDPI = oThis.m_nDPI;\r\n                const processType = oThis.m_nProcessType;\r\n                oThis.m_pTargetMat = cv[\"imread\"](imgSeal);\r\n                oThis.m_pRecognitionPack = new OZRecognitionPack(OZRecognitionPack.MODE_SEAL);\r\n                oThis.m_pRecognitionPack.SetResultMimeType(oThis.m_strMimeType);\r\n\r\n                pHiddenCanvas = document.createElement(\"canvas\");\r\n                pHiddenCanvas.width = imgSeal.width;\r\n                pHiddenCanvas.height = imgSeal.height;\r\n                const pCtx = pHiddenCanvas.getContext(\"2d\");\r\n                pHiddenMeta = document.createElement('canvas');\r\n                $(pHiddenMeta)[\"css\"](\"display\", \"none\");\r\n                \r\n                pCtx.drawImage(imgSeal, 0, 0, imgSeal.width, imgSeal.height);\r\n                oThis.m_pTargetMat.data.set(pCtx.getImageData(0, 0, imgSeal.width, imgSeal.height).data);\r\n                if (oThis.m_pRecognitionPack.FindSeal(nDPI, pHiddenCanvas, pHiddenMeta, oThis.m_pTargetMat, processType) == 999) {\r\n                    $(oThis.m_myUI)[\"css\"](\"display\", \"none\");\r\n                    oThis.m_pEndCallback(true);\r\n                } else {\r\n                    $(selectedImg)[\"css\"](\"display\", \"\");\r\n                    oThis.m_pEndCallback(false, selectedImg);\r\n                }\r\n            } catch (e) {\r\n                OZRecognitionPack[\"trace\"](e);\r\n                $(selectedImg)[\"css\"](\"display\", \"\");\r\n                oThis.m_pEndCallback(false, selectedImg);\r\n            } finally {\r\n                if (oThis.m_pTargetMat) {\r\n                    oThis.m_pTargetMat[\"delete\"]();\r\n                    oThis.m_pTargetMat = null;\r\n                }\r\n                $(pHiddenMeta).remove();\r\n                $(pHiddenCanvas).remove();\r\n                $(selectedImg).remove();\r\n            }\r\n        });\r\n        $(document.body).append(selectedImg);\r\n    };\r\n    /**\r\n     * Preview 크기를 재설정하는 함수\r\n     * @param nContentsWidth 너비\r\n     * @param nContentsHeight 높이\r\n     */\r\n    _this[\"UpdatePreviewSize\"] = function(nContentsWidth, nContentsHeight, bIgnore) {\r\n        $(this.m_myUI)[\"css\"](\"width\", nContentsWidth + \"px\");\r\n        $(this.m_myUI)[\"css\"](\"height\", nContentsHeight + \"px\");\r\n\r\n        if(!bIgnore) {\r\n            let margin = 0;\r\n            if (nContentsWidth > nContentsHeight) {\r\n                margin = nContentsWidth * 0.05;\r\n            } else {\r\n                margin = nContentsHeight * 0.05;\r\n            }\r\n            this.m_nContentsWidth = nContentsWidth - margin;\r\n            this.m_nContentsHeight = nContentsHeight - margin;\r\n        } else {\r\n            this.m_nContentsWidth = nContentsWidth;\r\n            this.m_nContentsHeight = nContentsHeight;\r\n        }\r\n      \r\n        const pSealPreviewWrappingDiv = $(this.m_myUI).children(\"div\");\r\n        pSealPreviewWrappingDiv[\"css\"](\"width\", (this.m_nContentsWidth) + \"px\");\r\n        pSealPreviewWrappingDiv[\"css\"](\"height\", (this.m_nContentsHeight) + \"px\");\r\n\r\n        this.m_nContentsWidth = Math.round(this.m_nContentsWidth);\r\n        this.m_nContentsHeight = Math.round(this.m_nContentsHeight);\r\n\r\n        $(this.m_pVideo)[\"css\"](\"width\", this.m_nContentsWidth + \"px\")\r\n            [\"css\"](\"height\", this.m_nContentsHeight + \"px\");\r\n        $(this.m_pTmpCanvas)[\"css\"](\"width\", this.m_nContentsWidth + \"px\")\r\n            [\"css\"](\"height\", this.m_nContentsHeight + \"px\");\r\n    };\r\n\r\n    /**\r\n     * 이미지 타입 처리 전 이미지 데이터 반환\r\n     */\r\n    _this[\"GetPreprocessingImage\"] = function() {\r\n        return this.m_pRecognitionPack.GetPreprocessingImage();\r\n    };\r\n    /**\r\n     * 이미지 타입 처리 후 이미지 데이터 반환\r\n     */\r\n    _this[\"GetPostprocessingImage\"] = function() {\r\n        return this.m_pRecognitionPack.GetPostprocessingImage();\r\n    };\r\n\r\n    /**\r\n     * 스캔 이미지 MIME 타입 설정\r\n     */\r\n    _this[\"SetResultMimeType\"] = function(strMimeType) {\r\n        this.m_strMimeType = strMimeType;\r\n    };\r\n\r\n    /**\r\n     * 스캔 이미지 MIME 타입 반환\r\n     */\r\n    _this[\"GetResultMimeType\"] = function() {\r\n        return this.m_pRecognitionPack.GetResultMimeType();\r\n    };\r\n\r\n    /**\r\n     * 인감 이미지의 너비 반환\r\n     * 인감 이미지는 정사각형으로 너비, 높이가 동일\r\n     * @return 인감 이미지 너비 (px)\r\n     */\r\n    _this[\"GetSealSize\"] = function() {\r\n        return this.m_pRecognitionPack.GetSealSize();\r\n    };\r\n\r\n    /**\r\n     * 메타정보 코드 객체(Object) 반환\r\n     * 속성 areaWidth - 스캔영역 너비 (cm)\r\n     * 속성 paperWidth - 인식패턴 영역 너비 (cm)\r\n     * @return 메타정보 코드 객체\r\n     */\r\n    _this[\"GetSpecBarcode\"] = function() {\r\n        return this.m_pRecognitionPack.GetSpecBarcode();\r\n    };\r\n\r\n    /**\r\n     * 프리뷰지원여부 체크하여 지원 시 pPreviewCallback을 호출하고 지원안하면 FindSealFromFile을 호출하는 함수\r\n     * @param pEndCallback 함수처리 후 호출될 콜백함수\r\n     * @param pPreviewCallback 미리보기 지원 시 호출할 콜백함수\r\n     */\r\n    _this[\"IsSupportPreview\"] = function(pEndCallback, pPreviewCallback) {\r\n        if (location.protocol !== \"https:\" || (typeof navigator.mediaDevices == \"undefined\")) {\r\n            OZRecognitionPack[\"trace\"](\"Current protocol : \" + location.protocol + \", navigator.mediaDevices : \" + navigator.mediaDevices);\r\n            // no preview\r\n            this[\"FindSealFromFile\"](pEndCallback);\r\n        } else {\r\n            // bug 25103, iOS Safari 12.0 이하 버전에서 미리보기는 제약사항\r\n            const bIsIOS = navigator.userAgent.indexOf(\"iPhone\") != -1 || navigator.userAgent.indexOf(\"iPad\") != -1 || navigator.userAgent.indexOf(\"iPod\") != -1;\r\n            if (bIsIOS && (navigator.userAgent.indexOf(\"Version/\") != -1)) {\r\n                const nSafariVersion = parseFloat(navigator.userAgent.substr(navigator.userAgent.indexOf(\"Version/\") + 8, 4));\r\n                if (nSafariVersion < 12.1) {\r\n                    this[\"FindSealFromFile\"](pEndCallback);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            const oThis = this;\r\n            navigator.mediaDevices.enumerateDevices()\r\n            .then(function(devices) {\r\n                let bEnablePreview = false;\r\n                devices.forEach(function(device) {\r\n                    if (device[\"kind\"][\"startsWith\"](\"video\")) {\r\n                        bEnablePreview = true;\r\n                        return;\r\n                    }\r\n                })\r\n                if (bEnablePreview) { // preview\r\n                    pPreviewCallback();\r\n                } else { // no preview\r\n                    oThis[\"FindSealFromFile\"](pEndCallback);\r\n                }\r\n            });\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 비디오 최소 해상도를 설정하는 함수\r\n     * @param width 최소 너비\r\n     * @param height 최소 높이\r\n     */\r\n    _this[\"SetVideoMinResolution\"] = function(width, height) {\r\n        if (isNaN(width) || isNaN(height)) {\r\n            OZRecognitionPack[\"trace\"](\"Invalid Resolution Value\");\r\n            throw new Error(\"Invalid Resolution Value\");\r\n        }\r\n        \r\n        this.m_nVideoMinWidth = width;\r\n        this.m_nVideoMinHeight = height;\r\n    };\r\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvT1pTZWFsUHJldmlldy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0Usb0JBQW9CLElBQUksMEJBQTBCO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDJCQUEyQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEMsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsY0FBYztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixzQ0FBc0M7QUFDdEM7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL09aU2VhbFJlY29nbml0aW9uLy4vc3JjL09aU2VhbFByZXZpZXcuanM/ODQ4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBPWlNlYWxQcmV2aWV3ID0gd2luZG93W1wiT1pTZWFsUHJldmlld1wiXSA9IGZ1bmN0aW9uKG5EUEksIG5Qcm9jZXNzVHlwZSkge1xyXG4gICAgY29uc3QgX3RoaXMgPSBPWlNlYWxQcmV2aWV3LnByb3RvdHlwZTtcclxuXHJcbiAgICB0aGlzLm1fbXlVSSA9IG51bGw7XHJcbiAgICB0aGlzLm1fbkRQSSA9IG5EUEk7XHJcbiAgICB0aGlzLm1fblByb2Nlc3NUeXBlID0gblByb2Nlc3NUeXBlO1xyXG4gICAgdGhpcy5tX2NvbnN0cmFpbnRzID0ge307XHJcbiAgICB0aGlzLm1fdmlkZW9UcmFja3MgPSBudWxsO1xyXG4gICAgdGhpcy5tX3BDYW52YXNVcGRhdGVGdW5jID0gbnVsbDtcclxuICAgIHRoaXMubV9wUmVjb2duaXRpb25QYWNrID0gbnVsbDtcclxuICAgIHRoaXMubV9iRmFjaW5nTW9kZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5tX3BWaWRlbyA9IG51bGw7XHJcbiAgICB0aGlzLm1fcFRtcENhbnZhcyA9IG51bGw7XHJcbiAgICB0aGlzLm1fcFRhcmdldE1hdCA9IG51bGw7XHJcbiAgICB0aGlzLm1fcEVuZENhbGxiYWNrID0gbnVsbDtcclxuICAgIHRoaXMubV9uQ29udGVudHNXaWR0aCA9IDA7XHJcbiAgICB0aGlzLm1fbkNvbnRlbnRzSGVpZ2h0ID0gMDtcclxuICAgIHRoaXMubV9uVmlkZW9NaW5XaWR0aCA9IDEyODA7XHJcbiAgICB0aGlzLm1fblZpZGVvTWluSGVpZ2h0ID0gNzIwO1xyXG4gICAgdGhpcy5tX3BGaWxlID0gbnVsbDtcclxuICAgIHRoaXMubV9zdHJNaW1lVHlwZSA9IFwiXCI7XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICog66mU66qo66asIO2VtOygnOyaqSDtlajsiJhcclxuICAgICAqL1xyXG4gICAgX3RoaXNbXCJEaXNwb3NlXCJdID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wUHJldmlldygpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5tX215VUkpIHtcclxuICAgICAgICAgICAgdGhpcy5tX3BWaWRlbyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMubV9wVG1wQ2FudmFzID0gbnVsbDtcclxuICAgICAgICAgICAgJCh0aGlzLm1fbXlVSSkucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIHRoaXMubV9teVVJID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubV9wUmVjb2duaXRpb25QYWNrKSB7XHJcbiAgICAgICAgICAgIHRoaXMubV9wUmVjb2duaXRpb25QYWNrLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5tX3BSZWNvZ25pdGlvblBhY2sgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5tX3BUYXJnZXRNYXQpIHtcclxuICAgICAgICAgICAgdGhpcy5tX3BUYXJnZXRNYXRbXCJkZWxldGVcIl0oKTtcclxuICAgICAgICAgICAgdGhpcy5tX3BUYXJnZXRNYXQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1fbkRQSSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tX25Qcm9jZXNzVHlwZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tX2NvbnN0cmFpbnRzID0gbnVsbDtcclxuICAgICAgICB0aGlzLm1fcEVuZENhbGxiYWNrID0gbnVsbDtcclxuICAgIH07XHJcblxyXG4gICAgX3RoaXMuSW5pdENvbnN0cmFpbnRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgY29uc3QgcENvbnN0cmFpbnRzID0ge307XHJcbiAgICAgICAgcENvbnN0cmFpbnRzW1wiYXVkaW9cIl0gPSBmYWxzZTtcclxuICAgICAgICBwQ29uc3RyYWludHNbXCJ2aWRlb1wiXSA9IHt9O1xyXG5cclxuICAgICAgICAvL3ZhciBiRmFjaW5nTW9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYnRuX2ZhY2luZ21vZGVcIikuY2hlY2tlZDtcclxuICAgICAgICAvL3BDb25zdHJhaW50c1tcInZpZGVvXCJdW1wiZmFjaW5nTW9kZVwiXSA9ICh0aGlzLm1fYkZhY2luZ01vZGUgPyB7IFtcImV4YWN0XCJdOiBcInVzZXJcIiB9IDogeyBbXCJleGFjdFwiXTogXCJlbnZpcm9ubWVudFwiIH0pO1xyXG4gICAgICAgIGxldCBmYWNpbmdNb2RlID0ge307XHJcbiAgICAgICAgZmFjaW5nTW9kZVtcImV4YWN0XCJdID0gXCJlbnZpcm9ubWVudFwiO1xyXG4gICAgICAgIGlmICh0aGlzLm1fYkZhY2luZ01vZGUpIHtcclxuICAgICAgICAgICAgZmFjaW5nTW9kZSA9IFwidXNlclwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwQ29uc3RyYWludHNbXCJ2aWRlb1wiXVtcImZhY2luZ01vZGVcIl0gPSBmYWNpbmdNb2RlO1xyXG5cclxuICAgICAgICBsZXQgd2lkdGggPSB7fTtcclxuICAgICAgICBsZXQgaGVpZ2h0ID0ge307XHJcblxyXG4gICAgICAgIHdpZHRoW1wibWluXCJdID0gdGhpcy5tX25WaWRlb01pbldpZHRoO1xyXG4gICAgICAgIGhlaWdodFtcIm1pblwiXSA9IHRoaXMubV9uVmlkZW9NaW5IZWlnaHQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgd2lkdGhbXCJpZGVhbFwiXSA9IHRoaXMubV9uQ29udGVudHNXaWR0aDtcclxuICAgICAgICBoZWlnaHRbXCJpZGVhbFwiXSA9IHRoaXMubV9uQ29udGVudHNIZWlnaHQ7XHJcblxyXG4gICAgICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA+IHdpbmRvdy5pbm5lckhlaWdodCkge1xyXG4gICAgICAgICAgICBwQ29uc3RyYWludHNbXCJ2aWRlb1wiXS53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgICBwQ29uc3RyYWludHNbXCJ2aWRlb1wiXS5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcENvbnN0cmFpbnRzW1widmlkZW9cIl0ud2lkdGggPSBoZWlnaHQ7XHJcbiAgICAgICAgICAgIHBDb25zdHJhaW50c1tcInZpZGVvXCJdLmhlaWdodCA9IHdpZHRoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcENvbnN0cmFpbnRzW1widmlkZW9cIl1bXCJhZHZhbmNlZFwiXSA9IFt7IFwiZm9jdXNNb2RlXCI6IFwiY29udGludW91c1wiIH1dO1xyXG4gICAgICAgIHRoaXMubV9jb25zdHJhaW50cyA9IHBDb25zdHJhaW50cztcclxuICAgIH07XHJcblxyXG4gICAgX3RoaXMuU2V0TWVkaWFTdHJlYW0gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLkluaXRDb25zdHJhaW50cygpO1xyXG5cclxuICAgICAgICBjb25zdCBvVGhpcyA9IHRoaXM7XHJcbiAgICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEodGhpcy5tX2NvbnN0cmFpbnRzKVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKG1lZGlhU3RyZWFtKSB7XHJcbiAgICAgICAgICAgIC8vIE9sZGVyIGJyb3dzZXJzIG1heSBub3QgaGF2ZSBzcmNPYmplY3RcclxuICAgICAgICAgICAgaWYgKFwic3JjT2JqZWN0XCIgaW4gb1RoaXMubV9wVmlkZW8pIHtcclxuICAgICAgICAgICAgICAgIG9UaGlzLm1fcFZpZGVvLnNyY09iamVjdCA9IG1lZGlhU3RyZWFtO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZlbmRvclVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTDtcclxuICAgICAgICAgICAgICAgIC8vIEF2b2lkIHVzaW5nIHRoaXMgaW4gbmV3IGJyb3dzZXJzLCBhcyBpdCBpcyBnb2luZyBhd2F5LlxyXG4gICAgICAgICAgICAgICAgb1RoaXMubV9wVmlkZW8uc3JjID0gdmVuZG9yVVJMLmNyZWF0ZU9iamVjdFVSTChtZWRpYVN0cmVhbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb1RoaXMubV92aWRlb1RyYWNrcyA9IG1lZGlhU3RyZWFtLmdldFZpZGVvVHJhY2tzKCk7XHJcbiAgICAgICAgICAgIG9UaGlzLm1fcFZpZGVvLm9ubG9hZGVkbWV0YWRhdGEgPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICBvVGhpcy5tX3BWaWRlby5wbGF5KCk7XHJcbiAgICAgICAgICAgICAgICBvVGhpcy5tX3BWaWRlby53aWR0aCA9IG9UaGlzLm1fcFZpZGVvLnZpZGVvV2lkdGg7XHJcbiAgICAgICAgICAgICAgICBvVGhpcy5tX3BWaWRlby5oZWlnaHQgPSBvVGhpcy5tX3BWaWRlby52aWRlb0hlaWdodDtcclxuICAgICAgICAgICAgICAgIG9UaGlzLlN0YXJ0RmluZFNlYWwoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgaWYgKG9UaGlzLm1fYkZhY2luZ01vZGUpIHtcclxuICAgICAgICAgICAgICAgIE9aUmVjb2duaXRpb25QYWNrW1widHJhY2VcIl0oZXJyLm5hbWUgKyBcIjogXCIgKyBlcnIubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICBvVGhpc1tcIkZpbmRTZWFsRnJvbUZpbGVcIl0ob1RoaXMubV9wRW5kQ2FsbGJhY2spO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb1RoaXMubV9iRmFjaW5nTW9kZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBvVGhpcy5TZXRNZWRpYVN0cmVhbSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF90aGlzLlN0YXJ0RmluZFNlYWwgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLnNob3dQcmV2aWV3KHRydWUpO1xyXG4gICAgICAgIGlmICh0aGlzLm1fdmlkZW9UcmFja3MpIHtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRUcmFjayA9IHRoaXMubV92aWRlb1RyYWNrc1swXTtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRUcmFjayAmJiBjdXJyZW50VHJhY2suYXBwbHlDb25zdHJhaW50cykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGJVcGRhdGU7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tX3BWaWRlby5wYXVzZWQgfHwgdGhpcy5tX3BWaWRlby5lbmRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNyY09iamVjdCA/IGFjdGl2ZSBzdGF0ZSBjaGVja1xyXG4gICAgICAgICAgICAgICAgICAgIGJVcGRhdGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYlVwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYlVwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5GUFMgPSAxMjAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZGVvID0gdGhpcy5tX3BWaWRlbztcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwSGlkZGVuQ2FudmFzID0gdGhpcy5tX3BUbXBDYW52YXM7IC8vZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwQ3R4ID0gdGhpcy5tX3BUbXBDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwSGlkZGVuTWV0YSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgICAgICAgICAgICQocEhpZGRlbk1ldGEpW1wiY3NzXCJdKFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubV9wUmVjb2duaXRpb25QYWNrID0gbmV3IE9aUmVjb2duaXRpb25QYWNrKE9aUmVjb2duaXRpb25QYWNrLk1PREVfU0VBTCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubV9wUmVjb2duaXRpb25QYWNrLlNldFJlc3VsdE1pbWVUeXBlKHRoaXMubV9zdHJNaW1lVHlwZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuRFBJID0gdGhpcy5tX25EUEk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NUeXBlID0gdGhpcy5tX25Qcm9jZXNzVHlwZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRtcENhbnZhc1JlY3QgPSB0aGlzLmdldFRtcENhbnZhc1JlY3QodmlkZW8udmlkZW9XaWR0aCwgdmlkZW8udmlkZW9IZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzeCA9IHRtcENhbnZhc1JlY3QuTGVmdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3kgPSB0bXBDYW52YXNSZWN0LlRvcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcEhpZGRlbkNhbnZhcy53aWR0aCA9IHRtcENhbnZhc1JlY3QuV2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBIaWRkZW5DYW52YXMuaGVpZ2h0ID0gdG1wQ2FudmFzUmVjdC5IZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubV9wVGFyZ2V0TWF0ID0gbmV3IGN2W1wiTWF0XCJdKHBIaWRkZW5DYW52YXMuaGVpZ2h0LCBwSGlkZGVuQ2FudmFzLndpZHRoLCBjdltcIkNWXzhVQzRcIl0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9UaGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tX3BDYW52YXNVcGRhdGVGdW5jID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3ZhciBuUHJldlRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcEN0eC5kcmF3SW1hZ2UodmlkZW8sIHN4LCBzeSwgcEhpZGRlbkNhbnZhcy53aWR0aCwgcEhpZGRlbkNhbnZhcy5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwgMCwgcEhpZGRlbkNhbnZhcy53aWR0aCwgcEhpZGRlbkNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvVGhpcy5tX3BUYXJnZXRNYXQuZGF0YS5zZXQocEN0eC5nZXRJbWFnZURhdGEoMCwgMCwgcEhpZGRlbkNhbnZhcy53aWR0aCwgcEhpZGRlbkNhbnZhcy5oZWlnaHQpLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob1RoaXMubV9wUmVjb2duaXRpb25QYWNrLkZpbmRTZWFsKG5EUEksIHBIaWRkZW5DYW52YXMsIHBIaWRkZW5NZXRhLCBvVGhpcy5tX3BUYXJnZXRNYXQsIHByb2Nlc3NUeXBlKSA9PSA5OTkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb1RoaXMuc3RvcFByZXZpZXcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb1RoaXMuc2hvd1ByZXZpZXcoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDsnbjsi50g6rKw6rO8KOqwgOydtOuTnCkg67O07Jes7KO86riwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN2W1wiaW1zaG93XCJdKHBIaWRkZW5DYW52YXMsIG9UaGlzLm1fcFRhcmdldE1hdCk7XHJcbiAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb1RoaXMubV9wVGFyZ2V0TWF0W1wiZGVsZXRlXCJdKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9UaGlzLm1fcFRhcmdldE1hdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQocEhpZGRlbk1ldGEpLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g7LSs7JiBIO2bhCAx7LSIIOuSpCDsvZzrsLHtlajsiJgg7Zi47LacXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKG9UaGlzLm1fbXlVSSlbXCJjc3NcIl0oXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb1RoaXMubV9wRW5kQ2FsbGJhY2sgPT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb1RoaXMubV9wRW5kQ2FsbGJhY2sodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDEwMDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3JldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyDsnbjsi50g7Iuk7YyoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvVGhpcy5tX3BSZWNvZ25pdGlvblBhY2suSXNGb3VuZFBhdHRlcm4oKSB8fCBvVGhpcy5tX3BSZWNvZ25pdGlvblBhY2suSXNGb3VuZFJlY3RhbmdsZSgpIHx8IG9UaGlzLm1fcFJlY29nbml0aW9uUGFjay5Jc0ZvdW5kU3BlY0JhcmNvZGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3ZbXCJpbXNob3dcIl0ocEhpZGRlbkNhbnZhcywgb1RoaXMubV9wVGFyZ2V0TWF0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9UaGlzLnNob3dQcmV2aWV3KGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvLnBhdXNlKCk7XHJcbiAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb1RoaXMuc2hvd1ByZXZpZXcodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW8ucGxheSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMjAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvVGhpcy5zdG9wUHJldmlldygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9aUmVjb2duaXRpb25QYWNrW1widHJhY2VcIl0oZS5uYW1lICsgXCI6IFwiICsgZS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tX3BUYXJnZXRNYXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tX3BUYXJnZXRNYXRbXCJkZWxldGVcIl0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tX3BUYXJnZXRNYXQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHBIaWRkZW5NZXRhKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coICgoKChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkpIC0gblByZXZUaW1lKSAvIDEwMDApLnRvRml4ZWQoMykgKyBcInNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIG5GUFMpOyAvLyBzZXRJbnRlcnZhbFxyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBPWlJlY29nbml0aW9uUGFja1tcInRyYWNlXCJdKGVyci5uYW1lICsgXCI6IFwiICsgZXJyLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tX3BUYXJnZXRNYXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubV9wVGFyZ2V0TWF0W1wiZGVsZXRlXCJdKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1fcFRhcmdldE1hdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgJChwSGlkZGVuTWV0YSkucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIE9aUmVjb2duaXRpb25QYWNrW1widHJhY2VcIl0oXCIhdmlkZW9UcmFja3NcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOuvuOumrOuztOq4sOulvCDsi5zsnpHsi5ztgqTripQg7ZWo7IiYKOyerOyLnOyeke2VoCDrlYzrj4Qg7IKs7Jqp6rCA64qlKVxyXG4gICAgICovXHJcbiAgICBfdGhpc1tcIlN0YXJ0Q2FwdHVyZVwiXSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuc3RvcFByZXZpZXcoKTtcclxuICAgICAgICB0aGlzLnNob3dQcmV2aWV3KHRydWUpO1xyXG4gICAgICAgIHRoaXMuU2V0TWVkaWFTdHJlYW0oKTtcclxuICAgIH07XHJcbiAgICBfdGhpc1tcIlN0b3BDYXB0dXJlXCJdID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wUHJldmlldygpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfdGhpcy5zaG93UHJldmlldyA9IGZ1bmN0aW9uKGIpIHtcclxuICAgICAgICBpZiAoYikge1xyXG4gICAgICAgICAgICAkKHRoaXMubV9wVG1wQ2FudmFzKVtcImNzc1wiXShcImRpc3BsYXlcIixcIm5vbmVcIik7XHJcbiAgICAgICAgICAgICQodGhpcy5tX3BWaWRlbylbXCJjc3NcIl0oXCJkaXNwbGF5XCIsXCJibG9ja1wiKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAkKHRoaXMubV9wVG1wQ2FudmFzKVtcImNzc1wiXShcImRpc3BsYXlcIixcImJsb2NrXCIpO1xyXG4gICAgICAgICAgICAkKHRoaXMubV9wVmlkZW8pW1wiY3NzXCJdKFwiZGlzcGxheVwiLFwibm9uZVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIF90aGlzLnN0b3BQcmV2aWV3ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubV9wQ2FudmFzVXBkYXRlRnVuYykge1xyXG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMubV9wQ2FudmFzVXBkYXRlRnVuYyk7XHJcbiAgICAgICAgICAgIHRoaXMubV9wQ2FudmFzVXBkYXRlRnVuYyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm1fdmlkZW9UcmFja3MpIHtcclxuICAgICAgICAgICAgdGhpcy5tX3ZpZGVvVHJhY2tzLmZvckVhY2goZnVuY3Rpb24odHJhY2spIHsgdHJhY2suc3RvcCgpIH0pO1xyXG4gICAgICAgICAgICB0aGlzLm1fdmlkZW9UcmFja3MgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5tX3BWaWRlbykge1xyXG4gICAgICAgICAgICBpZiAoXCJzcmNPYmplY3RcIiBpbiB0aGlzLm1fcFZpZGVvKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1fcFZpZGVvLnNyY09iamVjdCA9IG51bGw7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1fcFZpZGVvLnNyYyA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VhbFByZXZpZXdEaXbrpbwg67aZ7J2064qUIO2VqOyImFxyXG4gICAgICogQHBhcmFtIHRhcmdldCBQcmV2aWV3RGl26rCAIOu2meydhCDsl5jrpqzrqLztirhcclxuICAgICAqIEBwYXJhbSBuQ29udGVudHNXaWR0aCDrr7jrpqzrs7TquLAg64SI67mEXHJcbiAgICAgKiBAcGFyYW0gbkNvbnRlbnRzSGVpZ2h0IOuvuOumrOuztOq4sCDrhpLsnbRcclxuICAgICAqIEBwYXJhbSBwRW5kQ2FsbGJhY2sg7J246rCQIOyKpOy6lCDtm4Qg7Zi47Lac65CgIOy9nOuwsVxyXG4gICAgICogQHJldHVybiBTZWFsUHJldmlld0RpdiDsg53shLHrkJwgU2VhbFByZXZpZXdEaXZcclxuICAgICAqL1xyXG4gICAgX3RoaXNbXCJTaG93UHJldmlld09uXCJdID0gZnVuY3Rpb24odGFyZ2V0LCBuQ29udGVudHNXaWR0aCwgbkNvbnRlbnRzSGVpZ2h0LCBwRW5kQ2FsbGJhY2ssIGJJZ25vcmUpIHtcclxuICAgICAgICB0aGlzLm1fcEVuZENhbGxiYWNrID0gcEVuZENhbGxiYWNrO1xyXG4gICAgICAgIHRoaXMubV9teVVJID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICBcclxuICAgICAgICAkKHRoaXMubV9teVVJKVtcImNzc1wiXShcIndpZHRoXCIsIG5Db250ZW50c1dpZHRoICsgXCJweFwiKTtcclxuICAgICAgICAkKHRoaXMubV9teVVJKVtcImNzc1wiXShcImhlaWdodFwiLCBuQ29udGVudHNIZWlnaHQgKyBcInB4XCIpO1xyXG4gICAgICAgICQodGhpcy5tX215VUkpW1wiY3NzXCJdKFwiZGlzcGxheVwiLCBcImZsZXhcIik7XHJcblxyXG4gICAgICAgIGlmKCFiSWdub3JlKSB7XHJcbiAgICAgICAgICAgIGxldCBtYXJnaW4gPSAwO1xyXG4gICAgICAgICAgICBpZiAobkNvbnRlbnRzV2lkdGggPiBuQ29udGVudHNIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIG1hcmdpbiA9IG5Db250ZW50c1dpZHRoICogMC4wNTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1hcmdpbiA9IG5Db250ZW50c0hlaWdodCAqIDAuMDU7XHJcbiAgICAgICAgICAgIH0gICBcclxuICAgICAgICAgICAgdGhpcy5tX25Db250ZW50c1dpZHRoID0gbkNvbnRlbnRzV2lkdGggLSBtYXJnaW47XHJcbiAgICAgICAgICAgIHRoaXMubV9uQ29udGVudHNIZWlnaHQgPSBuQ29udGVudHNIZWlnaHQgLSBtYXJnaW47XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5tX25Db250ZW50c1dpZHRoID0gbkNvbnRlbnRzV2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMubV9uQ29udGVudHNIZWlnaHQgPSBuQ29udGVudHNIZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubV9uQ29udGVudHNXaWR0aCA9IE1hdGgucm91bmQodGhpcy5tX25Db250ZW50c1dpZHRoKTtcclxuICAgICAgICB0aGlzLm1fbkNvbnRlbnRzSGVpZ2h0ID0gTWF0aC5yb3VuZCh0aGlzLm1fbkNvbnRlbnRzSGVpZ2h0KTtcclxuXHJcbiAgICAgICAgY29uc3QgcERpdlByZXZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICQocERpdlByZXZpZXcpW1wiY3NzXCJdKFwiYm9yZGVyXCIsIFwiMXB4IHNvbGlkIGJsYWNrXCIpXHJcbiAgICAgICAgICAgIFtcImNzc1wiXShcIm92ZXJmbG93XCIsIFwiaGlkZGVuXCIpXHJcbiAgICAgICAgICAgIFtcImNzc1wiXShcIm1hcmdpblwiLCBcImF1dG9cIilcclxuICAgICAgICAgICAgW1wiY3NzXCJdKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcImJsYWNrXCIpO1xyXG5cclxuICAgICAgICBjb25zdCBwVmlkZW9QcmV2aWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInZpZGVvXCIpO1xyXG4gICAgICAgICQocFZpZGVvUHJldmlldykuYXR0cihcInBsYXlzaW5saW5lXCIsICBcIlwiKTtcclxuICAgICAgICAkKHBWaWRlb1ByZXZpZXcpW1wiY3NzXCJdKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpXHJcbiAgICAgICAgICAgIFtcImNzc1wiXShcIm9iamVjdC1maXRcIiwgXCJjb3ZlclwiKVxyXG4gICAgICAgICAgICBbXCJjc3NcIl0oXCJtYXJnaW5cIiwgXCJhdXRvXCIpXHJcbiAgICAgICAgICAgIFtcImNzc1wiXShcIndpZHRoXCIsIHRoaXMubV9uQ29udGVudHNXaWR0aCArIFwicHhcIilcclxuICAgICAgICAgICAgW1wiY3NzXCJdKFwiaGVpZ2h0XCIsIHRoaXMubV9uQ29udGVudHNIZWlnaHQgKyBcInB4XCIpO1xyXG5cclxuICAgICAgICB0aGlzLm1fcFZpZGVvID0gcFZpZGVvUHJldmlldztcclxuICAgICAgICBjb25zdCBwQ2FudmFzT3V0cHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuICAgICAgICAkKHBDYW52YXNPdXRwdXQpW1wiY3NzXCJdKFwiZGlzcGxheVwiLCBcIm5vbmVcIilcclxuICAgICAgICAgICAgW1wiY3NzXCJdKFwibWFyZ2luXCIsIFwiYXV0b1wiKVxyXG4gICAgICAgICAgICBbXCJjc3NcIl0oXCJ3aWR0aFwiLCB0aGlzLm1fbkNvbnRlbnRzV2lkdGggKyBcInB4XCIpXHJcbiAgICAgICAgICAgIFtcImNzc1wiXShcImhlaWdodFwiLCB0aGlzLm1fbkNvbnRlbnRzSGVpZ2h0ICsgXCJweFwiKTtcclxuXHJcbiAgICAgICAgJChwRGl2UHJldmlldykuYXBwZW5kKHBWaWRlb1ByZXZpZXcpLmFwcGVuZChwQ2FudmFzT3V0cHV0KTtcclxuICAgICAgICAkKHRoaXMubV9teVVJKS5hcHBlbmQocERpdlByZXZpZXcpO1xyXG5cclxuICAgICAgICB0aGlzLm1fcFRtcENhbnZhcyA9IHBDYW52YXNPdXRwdXQ7XHJcbiAgICAgICAgJCh0YXJnZXQpLmFwcGVuZCh0aGlzLm1fbXlVSSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubV9teVVJO1xyXG4gICAgfTtcclxuXHJcbiAgICBfdGhpcy5nZXRUbXBDYW52YXNSZWN0ID0gZnVuY3Rpb24odmlkZW9XaWR0aCwgdmlkZW9IZWlnaHQpIHtcclxuICAgICAgICBjb25zdCBwUmVjdCA9IHt9O1xyXG5cdFx0cFJlY3QuTGVmdCA9IDA7XHJcblx0XHRwUmVjdC5Ub3AgPSAwO1xyXG5cdFx0cFJlY3QuV2lkdGggPSB2aWRlb1dpZHRoO1xyXG5cdFx0cFJlY3QuSGVpZ2h0ID0gdmlkZW9IZWlnaHQ7XHJcblx0XHRpZiAodmlkZW9XaWR0aCAvIHRoaXMubV9uQ29udGVudHNXaWR0aCA+IHZpZGVvSGVpZ2h0IC8gdGhpcy5tX25Db250ZW50c0hlaWdodCkge1xyXG5cdFx0XHRwUmVjdC5XaWR0aCA9IHRoaXMubV9uQ29udGVudHNXaWR0aCAqIHZpZGVvSGVpZ2h0IC8gdGhpcy5tX25Db250ZW50c0hlaWdodDtcclxuXHRcdFx0cFJlY3QuTGVmdCArPSAodmlkZW9XaWR0aCAtIHBSZWN0LldpZHRoKSAvIDI7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRwUmVjdC5IZWlnaHQgPSB0aGlzLm1fbkNvbnRlbnRzSGVpZ2h0ICogdmlkZW9XaWR0aCAvIHRoaXMubV9uQ29udGVudHNXaWR0aDtcclxuXHRcdFx0cFJlY3QuVG9wICs9ICh2aWRlb0hlaWdodCAtIHBSZWN0LkhlaWdodCkgLyAyO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHBSZWN0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlYWxQcmV2aWV3RGl27Jes67aA66W8IOuwmO2ZmFxyXG4gICAgICogQHJldHVybiBTZWFsUHJldmlld0RpduycoOustFxyXG4gICAgICovXHJcbiAgICBfdGhpc1tcIklzU2hvd25cIl0gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMubV9teVVJICE9IG51bGwpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOyduOqwkCDtlITrpqzrt7Drpbwg7IKs7JqpIOuquyDtlaAg65WMIOy5tOuplOudvCDstKzsmIEg65iQ64qUIO2MjOydvCDtg5Dsg4nsnLzroZwg7J246rCQIOyduOyLne2VmOuKlCDtlajsiJhcclxuICAgICAqIGNhcHR1cmU9Y2FtZXJhIOyGjeyEseydhCDsp4Dsm5DtlZjsp4Ag7JWK7Jy866m0IO2MjOydvCDtg5Dsg4nsnLzroZwg64+Z7J6RXHJcbiAgICAgKiBAcGFyYW0gcEVuZENhbGxiYWNrIO2VqOyImOyymOumrCDtm4Qg7Zi47Lac65CgIOy9nOuwse2VqOyImFxyXG4gICAgICovXHJcbiAgICBfdGhpc1tcIkZpbmRTZWFsRnJvbUZpbGVcIl0gPSBmdW5jdGlvbihwRW5kQ2FsbGJhY2spIHtcclxuICAgICAgICBpZiAoIXRoaXMubV9wRmlsZSkge1xyXG4gICAgICAgICAgICB0aGlzLm1fcEZpbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XHJcbiAgICAgICAgICAgICQodGhpcy5tX3BGaWxlKS5hdHRyKFwidHlwZVwiLCBcImZpbGVcIik7XHJcbiAgICAgICAgICAgICQodGhpcy5tX3BGaWxlKS5hdHRyKFwiYWNjZXB0XCIsIFwiaW1hZ2UvKlwiKTtcclxuICAgICAgICAgICAgJCh0aGlzLm1fcEZpbGUpLmF0dHIoXCJjYXB0dXJlXCIsIFwiY2FtZXJhXCIpO1xyXG4gICAgICAgICAgICAkKHRoaXMubV9wRmlsZSlbXCJjc3NcIl0oXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcclxuICAgICAgICAgICAgY29uc3Qgb1RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAkKHRoaXMubV9wRmlsZSkub24oXCJjaGFuZ2VcIiwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBvVGhpc1tcIkZpbmRTZWFsRnJvbUltYWdlXCJdKFVSTC5jcmVhdGVPYmplY3RVUkwodGhpcy5maWxlc1swXSksIHBFbmRDYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICAkKG9UaGlzLm1fcEZpbGUpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgb1RoaXMubV9wRmlsZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAkKGRvY3VtZW50LmJvZHkpLmFwcGVuZCh0aGlzLm1fcEZpbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAkKHRoaXMubV9wRmlsZSkuY2xpY2soKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDsoITri6zrsJvsnYAg7J2066+47KeAIOuNsOydtO2EsOuhnCDsnbjqsJAg7J247Iud7ZWY64qUIO2VqOyImFxyXG4gICAgICogQHBhcmFtIHNyYyDsnbTrr7jsp4Ag642w7J207YSwXHJcbiAgICAgKiBAcGFyYW0gcEVuZENhbGxiYWNrIO2VqOyImOyymOumrCDtm4Qg7Zi47Lac65CgIOy9nOuwse2VqOyImFxyXG4gICAgICovXHJcbiAgICBfdGhpc1tcIkZpbmRTZWFsRnJvbUltYWdlXCJdID0gZnVuY3Rpb24oc3JjLCBwRW5kQ2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLm1fcEVuZENhbGxiYWNrID0gcEVuZENhbGxiYWNrO1xyXG4gICAgICAgIGNvbnN0IHNlbGVjdGVkSW1nID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgJChzZWxlY3RlZEltZylbXCJjc3NcIl0oXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcclxuICAgICAgICAkKHNlbGVjdGVkSW1nKS5hdHRyKFwic3JjXCIsIHNyYyk7XHJcbiAgICAgICAgY29uc3Qgb1RoaXMgPSB0aGlzO1xyXG4gICAgICAgICQoc2VsZWN0ZWRJbWcpLm9uKFwibG9hZFwiLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEhEKDEyODAqNzIwKeyXkCDqt7zsoJHtlZjqsowg7J2066+47KeAIOyCrOydtOymiCDrs7TsoJUgKOq4tCDrqbTsnbQgMTI4MCDsgqzsnbTspojroZwg7ISk7KCV65CY64+E66GdIO2VqClcclxuICAgICAgICAgICAgY29uc3QgYkxhbmRzY2FwZSA9IHNlbGVjdGVkSW1nLndpZHRoID4gc2VsZWN0ZWRJbWcuaGVpZ2h0O1xyXG4gICAgICAgICAgICBjb25zdCBuUmF0aW8gPSAxMjgwIC8gKGJMYW5kc2NhcGUgPyBzZWxlY3RlZEltZy53aWR0aCA6IHNlbGVjdGVkSW1nLmhlaWdodCk7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkSW1nLndpZHRoICo9IG5SYXRpbztcclxuICAgICAgICAgICAgc2VsZWN0ZWRJbWcuaGVpZ2h0ICo9IG5SYXRpbztcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGxldCBwSGlkZGVuQ2FudmFzID0gbnVsbDtcclxuICAgICAgICAgICAgbGV0IHBIaWRkZW5NZXRhID0gbnVsbDtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGltZ1NlYWwgPSBzZWxlY3RlZEltZztcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5EUEkgPSBvVGhpcy5tX25EUEk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9jZXNzVHlwZSA9IG9UaGlzLm1fblByb2Nlc3NUeXBlO1xyXG4gICAgICAgICAgICAgICAgb1RoaXMubV9wVGFyZ2V0TWF0ID0gY3ZbXCJpbXJlYWRcIl0oaW1nU2VhbCk7XHJcbiAgICAgICAgICAgICAgICBvVGhpcy5tX3BSZWNvZ25pdGlvblBhY2sgPSBuZXcgT1pSZWNvZ25pdGlvblBhY2soT1pSZWNvZ25pdGlvblBhY2suTU9ERV9TRUFMKTtcclxuICAgICAgICAgICAgICAgIG9UaGlzLm1fcFJlY29nbml0aW9uUGFjay5TZXRSZXN1bHRNaW1lVHlwZShvVGhpcy5tX3N0ck1pbWVUeXBlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBwSGlkZGVuQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuICAgICAgICAgICAgICAgIHBIaWRkZW5DYW52YXMud2lkdGggPSBpbWdTZWFsLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgcEhpZGRlbkNhbnZhcy5oZWlnaHQgPSBpbWdTZWFsLmhlaWdodDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBDdHggPSBwSGlkZGVuQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuICAgICAgICAgICAgICAgIHBIaWRkZW5NZXRhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgICAgICAkKHBIaWRkZW5NZXRhKVtcImNzc1wiXShcImRpc3BsYXlcIiwgXCJub25lXCIpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBwQ3R4LmRyYXdJbWFnZShpbWdTZWFsLCAwLCAwLCBpbWdTZWFsLndpZHRoLCBpbWdTZWFsLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBvVGhpcy5tX3BUYXJnZXRNYXQuZGF0YS5zZXQocEN0eC5nZXRJbWFnZURhdGEoMCwgMCwgaW1nU2VhbC53aWR0aCwgaW1nU2VhbC5oZWlnaHQpLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9UaGlzLm1fcFJlY29nbml0aW9uUGFjay5GaW5kU2VhbChuRFBJLCBwSGlkZGVuQ2FudmFzLCBwSGlkZGVuTWV0YSwgb1RoaXMubV9wVGFyZ2V0TWF0LCBwcm9jZXNzVHlwZSkgPT0gOTk5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJChvVGhpcy5tX215VUkpW1wiY3NzXCJdKFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgb1RoaXMubV9wRW5kQ2FsbGJhY2sodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICQoc2VsZWN0ZWRJbWcpW1wiY3NzXCJdKFwiZGlzcGxheVwiLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICBvVGhpcy5tX3BFbmRDYWxsYmFjayhmYWxzZSwgc2VsZWN0ZWRJbWcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBPWlJlY29nbml0aW9uUGFja1tcInRyYWNlXCJdKGUpO1xyXG4gICAgICAgICAgICAgICAgJChzZWxlY3RlZEltZylbXCJjc3NcIl0oXCJkaXNwbGF5XCIsIFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgb1RoaXMubV9wRW5kQ2FsbGJhY2soZmFsc2UsIHNlbGVjdGVkSW1nKTtcclxuICAgICAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIGlmIChvVGhpcy5tX3BUYXJnZXRNYXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBvVGhpcy5tX3BUYXJnZXRNYXRbXCJkZWxldGVcIl0oKTtcclxuICAgICAgICAgICAgICAgICAgICBvVGhpcy5tX3BUYXJnZXRNYXQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgJChwSGlkZGVuTWV0YSkucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICAkKHBIaWRkZW5DYW52YXMpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgJChzZWxlY3RlZEltZykucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAkKGRvY3VtZW50LmJvZHkpLmFwcGVuZChzZWxlY3RlZEltZyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBQcmV2aWV3IO2BrOq4sOulvCDsnqzshKTsoJXtlZjripQg7ZWo7IiYXHJcbiAgICAgKiBAcGFyYW0gbkNvbnRlbnRzV2lkdGgg64SI67mEXHJcbiAgICAgKiBAcGFyYW0gbkNvbnRlbnRzSGVpZ2h0IOuGkuydtFxyXG4gICAgICovXHJcbiAgICBfdGhpc1tcIlVwZGF0ZVByZXZpZXdTaXplXCJdID0gZnVuY3Rpb24obkNvbnRlbnRzV2lkdGgsIG5Db250ZW50c0hlaWdodCwgYklnbm9yZSkge1xyXG4gICAgICAgICQodGhpcy5tX215VUkpW1wiY3NzXCJdKFwid2lkdGhcIiwgbkNvbnRlbnRzV2lkdGggKyBcInB4XCIpO1xyXG4gICAgICAgICQodGhpcy5tX215VUkpW1wiY3NzXCJdKFwiaGVpZ2h0XCIsIG5Db250ZW50c0hlaWdodCArIFwicHhcIik7XHJcblxyXG4gICAgICAgIGlmKCFiSWdub3JlKSB7XHJcbiAgICAgICAgICAgIGxldCBtYXJnaW4gPSAwO1xyXG4gICAgICAgICAgICBpZiAobkNvbnRlbnRzV2lkdGggPiBuQ29udGVudHNIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIG1hcmdpbiA9IG5Db250ZW50c1dpZHRoICogMC4wNTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1hcmdpbiA9IG5Db250ZW50c0hlaWdodCAqIDAuMDU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5tX25Db250ZW50c1dpZHRoID0gbkNvbnRlbnRzV2lkdGggLSBtYXJnaW47XHJcbiAgICAgICAgICAgIHRoaXMubV9uQ29udGVudHNIZWlnaHQgPSBuQ29udGVudHNIZWlnaHQgLSBtYXJnaW47XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5tX25Db250ZW50c1dpZHRoID0gbkNvbnRlbnRzV2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMubV9uQ29udGVudHNIZWlnaHQgPSBuQ29udGVudHNIZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICBcclxuICAgICAgICBjb25zdCBwU2VhbFByZXZpZXdXcmFwcGluZ0RpdiA9ICQodGhpcy5tX215VUkpLmNoaWxkcmVuKFwiZGl2XCIpO1xyXG4gICAgICAgIHBTZWFsUHJldmlld1dyYXBwaW5nRGl2W1wiY3NzXCJdKFwid2lkdGhcIiwgKHRoaXMubV9uQ29udGVudHNXaWR0aCkgKyBcInB4XCIpO1xyXG4gICAgICAgIHBTZWFsUHJldmlld1dyYXBwaW5nRGl2W1wiY3NzXCJdKFwiaGVpZ2h0XCIsICh0aGlzLm1fbkNvbnRlbnRzSGVpZ2h0KSArIFwicHhcIik7XHJcblxyXG4gICAgICAgIHRoaXMubV9uQ29udGVudHNXaWR0aCA9IE1hdGgucm91bmQodGhpcy5tX25Db250ZW50c1dpZHRoKTtcclxuICAgICAgICB0aGlzLm1fbkNvbnRlbnRzSGVpZ2h0ID0gTWF0aC5yb3VuZCh0aGlzLm1fbkNvbnRlbnRzSGVpZ2h0KTtcclxuXHJcbiAgICAgICAgJCh0aGlzLm1fcFZpZGVvKVtcImNzc1wiXShcIndpZHRoXCIsIHRoaXMubV9uQ29udGVudHNXaWR0aCArIFwicHhcIilcclxuICAgICAgICAgICAgW1wiY3NzXCJdKFwiaGVpZ2h0XCIsIHRoaXMubV9uQ29udGVudHNIZWlnaHQgKyBcInB4XCIpO1xyXG4gICAgICAgICQodGhpcy5tX3BUbXBDYW52YXMpW1wiY3NzXCJdKFwid2lkdGhcIiwgdGhpcy5tX25Db250ZW50c1dpZHRoICsgXCJweFwiKVxyXG4gICAgICAgICAgICBbXCJjc3NcIl0oXCJoZWlnaHRcIiwgdGhpcy5tX25Db250ZW50c0hlaWdodCArIFwicHhcIik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog7J2066+47KeAIO2DgOyehSDsspjrpqwg7KCEIOydtOuvuOyngCDrjbDsnbTthLAg67CY7ZmYXHJcbiAgICAgKi9cclxuICAgIF90aGlzW1wiR2V0UHJlcHJvY2Vzc2luZ0ltYWdlXCJdID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubV9wUmVjb2duaXRpb25QYWNrLkdldFByZXByb2Nlc3NpbmdJbWFnZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog7J2066+47KeAIO2DgOyehSDsspjrpqwg7ZuEIOydtOuvuOyngCDrjbDsnbTthLAg67CY7ZmYXHJcbiAgICAgKi9cclxuICAgIF90aGlzW1wiR2V0UG9zdHByb2Nlc3NpbmdJbWFnZVwiXSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1fcFJlY29nbml0aW9uUGFjay5HZXRQb3N0cHJvY2Vzc2luZ0ltYWdlKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog7Iqk7LqUIOydtOuvuOyngCBNSU1FIO2DgOyehSDshKTsoJVcclxuICAgICAqL1xyXG4gICAgX3RoaXNbXCJTZXRSZXN1bHRNaW1lVHlwZVwiXSA9IGZ1bmN0aW9uKHN0ck1pbWVUeXBlKSB7XHJcbiAgICAgICAgdGhpcy5tX3N0ck1pbWVUeXBlID0gc3RyTWltZVR5cGU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog7Iqk7LqUIOydtOuvuOyngCBNSU1FIO2DgOyehSDrsJjtmZhcclxuICAgICAqL1xyXG4gICAgX3RoaXNbXCJHZXRSZXN1bHRNaW1lVHlwZVwiXSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1fcFJlY29nbml0aW9uUGFjay5HZXRSZXN1bHRNaW1lVHlwZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOyduOqwkCDsnbTrr7jsp4DsnZgg64SI67mEIOuwmO2ZmFxyXG4gICAgICog7J246rCQIOydtOuvuOyngOuKlCDsoJXsgqzqsIHtmJXsnLzroZwg64SI67mELCDrhpLsnbTqsIAg64+Z7J28XHJcbiAgICAgKiBAcmV0dXJuIOyduOqwkCDsnbTrr7jsp4Ag64SI67mEIChweClcclxuICAgICAqL1xyXG4gICAgX3RoaXNbXCJHZXRTZWFsU2l6ZVwiXSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1fcFJlY29nbml0aW9uUGFjay5HZXRTZWFsU2l6ZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOuplO2DgOygleuztCDsvZTrk5wg6rCd7LK0KE9iamVjdCkg67CY7ZmYXHJcbiAgICAgKiDsho3shLEgYXJlYVdpZHRoIC0g7Iqk7LqU7JiB7JetIOuEiOu5hCAoY20pXHJcbiAgICAgKiDsho3shLEgcGFwZXJXaWR0aCAtIOyduOyLne2MqO2EtCDsmIHsl60g64SI67mEIChjbSlcclxuICAgICAqIEByZXR1cm4g66mU7YOA7KCV67O0IOy9lOuTnCDqsJ3ssrRcclxuICAgICAqL1xyXG4gICAgX3RoaXNbXCJHZXRTcGVjQmFyY29kZVwiXSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1fcFJlY29nbml0aW9uUGFjay5HZXRTcGVjQmFyY29kZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIO2UhOumrOu3sOyngOybkOyXrOu2gCDssrTtgaztlZjsl6wg7KeA7JuQIOyLnCBwUHJldmlld0NhbGxiYWNr7J2EIO2YuOy2nO2VmOqzoCDsp4Dsm5DslYjtlZjrqbQgRmluZFNlYWxGcm9tRmlsZeydhCDtmLjstpztlZjripQg7ZWo7IiYXHJcbiAgICAgKiBAcGFyYW0gcEVuZENhbGxiYWNrIO2VqOyImOyymOumrCDtm4Qg7Zi47Lac65CgIOy9nOuwse2VqOyImFxyXG4gICAgICogQHBhcmFtIHBQcmV2aWV3Q2FsbGJhY2sg66+466as67O06riwIOyngOybkCDsi5wg7Zi47Lac7ZWgIOy9nOuwse2VqOyImFxyXG4gICAgICovXHJcbiAgICBfdGhpc1tcIklzU3VwcG9ydFByZXZpZXdcIl0gPSBmdW5jdGlvbihwRW5kQ2FsbGJhY2ssIHBQcmV2aWV3Q2FsbGJhY2spIHtcclxuICAgICAgICBpZiAobG9jYXRpb24ucHJvdG9jb2wgIT09IFwiaHR0cHM6XCIgfHwgKHR5cGVvZiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzID09IFwidW5kZWZpbmVkXCIpKSB7XHJcbiAgICAgICAgICAgIE9aUmVjb2duaXRpb25QYWNrW1widHJhY2VcIl0oXCJDdXJyZW50IHByb3RvY29sIDogXCIgKyBsb2NhdGlvbi5wcm90b2NvbCArIFwiLCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzIDogXCIgKyBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKTtcclxuICAgICAgICAgICAgLy8gbm8gcHJldmlld1xyXG4gICAgICAgICAgICB0aGlzW1wiRmluZFNlYWxGcm9tRmlsZVwiXShwRW5kQ2FsbGJhY2spO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGJ1ZyAyNTEwMywgaU9TIFNhZmFyaSAxMi4wIOydtO2VmCDrsoTsoITsl5DshJwg66+466as67O06riw64qUIOygnOyVveyCrO2VrVxyXG4gICAgICAgICAgICBjb25zdCBiSXNJT1MgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJpUGhvbmVcIikgIT0gLTEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiaVBhZFwiKSAhPSAtMSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJpUG9kXCIpICE9IC0xO1xyXG4gICAgICAgICAgICBpZiAoYklzSU9TICYmIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJWZXJzaW9uL1wiKSAhPSAtMSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5TYWZhcmlWZXJzaW9uID0gcGFyc2VGbG9hdChuYXZpZ2F0b3IudXNlckFnZW50LnN1YnN0cihuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJWZXJzaW9uL1wiKSArIDgsIDQpKTtcclxuICAgICAgICAgICAgICAgIGlmIChuU2FmYXJpVmVyc2lvbiA8IDEyLjEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzW1wiRmluZFNlYWxGcm9tRmlsZVwiXShwRW5kQ2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3Qgb1RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbihkZXZpY2VzKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgYkVuYWJsZVByZXZpZXcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGRldmljZXMuZm9yRWFjaChmdW5jdGlvbihkZXZpY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGV2aWNlW1wia2luZFwiXVtcInN0YXJ0c1dpdGhcIl0oXCJ2aWRlb1wiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiRW5hYmxlUHJldmlldyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgaWYgKGJFbmFibGVQcmV2aWV3KSB7IC8vIHByZXZpZXdcclxuICAgICAgICAgICAgICAgICAgICBwUHJldmlld0NhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBubyBwcmV2aWV3XHJcbiAgICAgICAgICAgICAgICAgICAgb1RoaXNbXCJGaW5kU2VhbEZyb21GaWxlXCJdKHBFbmRDYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDruYTrlJTsmKQg7LWc7IaMIO2VtOyDgeuPhOulvCDshKTsoJXtlZjripQg7ZWo7IiYXHJcbiAgICAgKiBAcGFyYW0gd2lkdGgg7LWc7IaMIOuEiOu5hFxyXG4gICAgICogQHBhcmFtIGhlaWdodCDstZzshowg64aS7J20XHJcbiAgICAgKi9cclxuICAgIF90aGlzW1wiU2V0VmlkZW9NaW5SZXNvbHV0aW9uXCJdID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIGlmIChpc05hTih3aWR0aCkgfHwgaXNOYU4oaGVpZ2h0KSkge1xyXG4gICAgICAgICAgICBPWlJlY29nbml0aW9uUGFja1tcInRyYWNlXCJdKFwiSW52YWxpZCBSZXNvbHV0aW9uIFZhbHVlXCIpO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFJlc29sdXRpb24gVmFsdWVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMubV9uVmlkZW9NaW5XaWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMubV9uVmlkZW9NaW5IZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICB9O1xyXG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/OZSealPreview.js\n");

/***/ }),

/***/ "./src/OZSealRecognition.js":
/*!**********************************!*\
  !*** ./src/OZSealRecognition.js ***!
  \**********************************/
/***/ ((module) => {

eval("(function webpackUniversalModuleDefinition(root, factory) {\r\n    if(true)\r\n        module.exports = factory();\r\n    else {}\r\n})(window, function() {\r\n    return /******/ (function(modules) { // webpackBootstrap\r\n        /******/ \t// The module cache\r\n        /******/ \tvar installedModules = {};\r\n        /******/\r\n        /******/ \t// The require function\r\n        /******/ \tfunction __nested_webpack_require_675__(moduleId) {\r\n            /******/\r\n            /******/ \t\t// Check if module is in cache\r\n            /******/ \t\tif(installedModules[moduleId]) {\r\n                /******/ \t\t\treturn installedModules[moduleId].exports;\r\n                /******/ \t\t}\r\n            /******/ \t\t// Create a new module (and put it into the cache)\r\n            /******/ \t\tvar module = installedModules[moduleId] = {\r\n                /******/ \t\t\ti: moduleId,\r\n                /******/ \t\t\tl: false,\r\n                /******/ \t\t\texports: {}\r\n                /******/ \t\t};\r\n            /******/\r\n            /******/ \t\t// Execute the module function\r\n            /******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_675__);\r\n            /******/\r\n            /******/ \t\t// Flag the module as loaded\r\n            /******/ \t\tmodule.l = true;\r\n            /******/\r\n            /******/ \t\t// Return the exports of the module\r\n            /******/ \t\treturn module.exports;\r\n            /******/ \t}\r\n        /******/\r\n        /******/\r\n        /******/ \t// expose the modules object (__webpack_modules__)\r\n        /******/ \t__nested_webpack_require_675__.m = modules;\r\n        /******/\r\n        /******/ \t// expose the module cache\r\n        /******/ \t__nested_webpack_require_675__.c = installedModules;\r\n        /******/\r\n        /******/ \t// define getter function for harmony exports\r\n        /******/ \t__nested_webpack_require_675__.d = function(exports, name, getter) {\r\n            /******/ \t\tif(!__nested_webpack_require_675__.o(exports, name)) {\r\n                /******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\r\n                /******/ \t\t}\r\n            /******/ \t};\r\n        /******/\r\n        /******/ \t// define __esModule on exports\r\n        /******/ \t__nested_webpack_require_675__.r = function(exports) {\r\n            /******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\r\n                /******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\r\n                /******/ \t\t}\r\n            /******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\r\n            /******/ \t};\r\n        /******/\r\n        /******/ \t// create a fake namespace object\r\n        /******/ \t// mode & 1: value is a module id, require it\r\n        /******/ \t// mode & 2: merge all properties of value into the ns\r\n        /******/ \t// mode & 4: return value when already ns object\r\n        /******/ \t// mode & 8|1: behave like require\r\n        /******/ \t__nested_webpack_require_675__.t = function(value, mode) {\r\n            /******/ \t\tif(mode & 1) value = __nested_webpack_require_675__(value);\r\n            /******/ \t\tif(mode & 8) return value;\r\n            /******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\r\n            /******/ \t\tvar ns = Object.create(null);\r\n            /******/ \t\t__nested_webpack_require_675__.r(ns);\r\n            /******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\r\n            /******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_675__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\r\n            /******/ \t\treturn ns;\r\n            /******/ \t};\r\n        /******/\r\n        /******/ \t// getDefaultExport function for compatibility with non-harmony modules\r\n        /******/ \t__nested_webpack_require_675__.n = function(module) {\r\n            /******/ \t\tvar getter = module && module.__esModule ?\r\n                /******/ \t\t\tfunction getDefault() { return module['default']; } :\r\n                /******/ \t\t\tfunction getModuleExports() { return module; };\r\n            /******/ \t\t__nested_webpack_require_675__.d(getter, 'a', getter);\r\n            /******/ \t\treturn getter;\r\n            /******/ \t};\r\n        /******/\r\n        /******/ \t// Object.prototype.hasOwnProperty.call\r\n        /******/ \t__nested_webpack_require_675__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\r\n        /******/\r\n        /******/ \t// __webpack_public_path__\r\n        /******/ \t__nested_webpack_require_675__.p = \"\";\r\n        /******/\r\n        /******/\r\n        /******/ \t// Load entry module and return exports\r\n        /******/ \treturn __nested_webpack_require_675__(__nested_webpack_require_675__.s = 0);\r\n        /******/ })\r\n        /************************************************************************/\r\n        /******/ ({\r\n\r\n            /***/ \"./node_modules/ts-custom-error/dist/custom-error.mjs\":\r\n            /*!************************************************************!*\\\r\n              !*** ./node_modules/ts-custom-error/dist/custom-error.mjs ***!\r\n              \\************************************************************/\r\n            /*! exports provided: CustomError, customErrorFactory */\r\n            /*! ModuleConcatenation bailout: Module is referenced from these modules with unsupported syntax: ./src/core/Exception.ts (referenced with cjs require) */\r\n            /***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {\r\n\r\n                \"use strict\";\r\n                eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CustomError\\\", function() { return CustomError; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"customErrorFactory\\\", function() { return customErrorFactory; });\\nfunction fixProto(target, prototype) {\\n  var setPrototypeOf = Object.setPrototypeOf;\\n  setPrototypeOf ? setPrototypeOf(target, prototype) : target.__proto__ = prototype;\\n}\\nfunction fixStack(target, fn) {\\n  if (fn === void 0) {\\n    fn = target.constructor;\\n  }\\n\\n  var captureStackTrace = Error.captureStackTrace;\\n  captureStackTrace && captureStackTrace(target, fn);\\n}\\n\\nvar __extends = undefined && undefined.__extends || function () {\\n  var _extendStatics = function extendStatics(d, b) {\\n    _extendStatics = Object.setPrototypeOf || {\\n      __proto__: []\\n    } instanceof Array && function (d, b) {\\n      d.__proto__ = b;\\n    } || function (d, b) {\\n      for (var p in b) {\\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\\n      }\\n    };\\n\\n    return _extendStatics(d, b);\\n  };\\n\\n  return function (d, b) {\\n    if (typeof b !== \\\"function\\\" && b !== null) throw new TypeError(\\\"Class extends value \\\" + String(b) + \\\" is not a constructor or null\\\");\\n\\n    _extendStatics(d, b);\\n\\n    function __() {\\n      this.constructor = d;\\n    }\\n\\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\\n  };\\n}();\\n\\nvar CustomError = function (_super) {\\n  __extends(CustomError, _super);\\n\\n  function CustomError(message, options) {\\n    var _newTarget = this.constructor;\\n\\n    var _this = _super.call(this, message, options) || this;\\n\\n    Object.defineProperty(_this, 'name', {\\n      value: _newTarget.name,\\n      enumerable: false,\\n      configurable: true\\n    });\\n    fixProto(_this, _newTarget.prototype);\\n    fixStack(_this);\\n    return _this;\\n  }\\n\\n  return CustomError;\\n}(Error);\\n\\nvar __spreadArray = undefined && undefined.__spreadArray || function (to, from, pack) {\\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\\n    if (ar || !(i in from)) {\\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\\n      ar[i] = from[i];\\n    }\\n  }\\n  return to.concat(ar || Array.prototype.slice.call(from));\\n};\\nfunction customErrorFactory(fn, parent) {\\n  if (parent === void 0) {\\n    parent = Error;\\n  }\\n\\n  function CustomError() {\\n    var args = [];\\n\\n    for (var _i = 0; _i < arguments.length; _i++) {\\n      args[_i] = arguments[_i];\\n    }\\n\\n    if (!(this instanceof CustomError)) return new (CustomError.bind.apply(CustomError, __spreadArray([void 0], args, false)))();\\n    parent.apply(this, args);\\n    Object.defineProperty(this, 'name', {\\n      value: fn.name || parent.name,\\n      enumerable: false,\\n      configurable: true\\n    });\\n    fn.apply(this, args);\\n    fixStack(this, CustomError);\\n  }\\n\\n  return Object.defineProperties(CustomError, {\\n    prototype: {\\n      value: Object.create(parent.prototype, {\\n        constructor: {\\n          value: CustomError,\\n          writable: true,\\n          configurable: true\\n        }\\n      })\\n    }\\n  });\\n}\\n\\n\\n//# sourceMappingURL=custom-error.mjs.map\\n\\n\\n//# sourceURL=webpack://OZSealRecognition/./node_modules/ts-custom-error/dist/custom-error.mjs?\");\r\n\r\n                /***/ }),\r\n\r\n            /***/ \"./src/core/DecodeHintType.ts\":\r\n            /*!************************************!*\\\r\n              !*** ./src/core/DecodeHintType.ts ***!\r\n              \\************************************/\r\n            /*! no static exports found */\r\n            /*! ModuleConcatenation bailout: Module is not an ECMAScript module */\r\n            /***/ (function(module, exports, __webpack_require__) {\r\n\r\n                \"use strict\";\r\n                eval(\"\\r\\n/*\\r\\n * Copyright 2009 ZXing authors\\r\\n *\\r\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\r\\n * you may not use this file except in compliance with the License.\\r\\n * You may obtain a copy of the License at\\r\\n *\\r\\n *      http://www.apache.org/licenses/LICENSE-2.0\\r\\n *\\r\\n * Unless required by applicable law or agreed to in writing, software\\r\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\r\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\r\\n * See the License for the specific language governing permissions and\\r\\n * limitations under the License.\\r\\n */\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\n/*namespace com.google.zxing {*/\\r\\n/**\\r\\n * Encapsulates a type of hint that a caller may pass to a barcode reader to help it\\r\\n * more quickly or accurately decode it. It is up to implementations to decide what,\\r\\n * if anything, to do with the information that is supplied.\\r\\n *\\r\\n * @author Sean Owen\\r\\n * @author dswitkin@google.com (Daniel Switkin)\\r\\n * @see Reader#decode(BinaryBitmap,java.util.Map)\\r\\n */\\r\\nvar DecodeHintType;\\r\\n(function (DecodeHintType) {\\r\\n    /**\\r\\n     * Unspecified, application-specific hint. Maps to an unspecified {@link Object}.\\r\\n     */\\r\\n    DecodeHintType[DecodeHintType[\\\"OTHER\\\"] = 0] = \\\"OTHER\\\"; /*(Object.class)*/\\r\\n    /**\\r\\n     * Image is a pure monochrome image of a barcode. Doesn't matter what it maps to;\\r\\n     * use {@link Boolean#TRUE}.\\r\\n     */\\r\\n    DecodeHintType[DecodeHintType[\\\"PURE_BARCODE\\\"] = 1] = \\\"PURE_BARCODE\\\"; /*(Void.class)*/\\r\\n    /**\\r\\n     * Image is known to be of one of a few possible formats.\\r\\n     * Maps to a {@link List} of {@link BarcodeFormat}s.\\r\\n     */\\r\\n    DecodeHintType[DecodeHintType[\\\"POSSIBLE_FORMATS\\\"] = 2] = \\\"POSSIBLE_FORMATS\\\"; /*(List.class)*/\\r\\n    /**\\r\\n     * Spend more time to try to find a barcode; optimize for accuracy, not speed.\\r\\n     * Doesn't matter what it maps to; use {@link Boolean#TRUE}.\\r\\n     */\\r\\n    DecodeHintType[DecodeHintType[\\\"TRY_HARDER\\\"] = 3] = \\\"TRY_HARDER\\\"; /*(Void.class)*/\\r\\n    /**\\r\\n     * Specifies what character encoding to use when decoding, where applicable (type String)\\r\\n     */\\r\\n    DecodeHintType[DecodeHintType[\\\"CHARACTER_SET\\\"] = 4] = \\\"CHARACTER_SET\\\"; /*(String.class)*/\\r\\n    /**\\r\\n     * Allowed lengths of encoded data -- reject anything else. Maps to an {@code Int32Array}.\\r\\n     */\\r\\n    DecodeHintType[DecodeHintType[\\\"ALLOWED_LENGTHS\\\"] = 5] = \\\"ALLOWED_LENGTHS\\\"; /*(Int32Array.class)*/\\r\\n    /**\\r\\n     * Assume Code 39 codes employ a check digit. Doesn't matter what it maps to;\\r\\n     * use {@link Boolean#TRUE}.\\r\\n     */\\r\\n    DecodeHintType[DecodeHintType[\\\"ASSUME_CODE_39_CHECK_DIGIT\\\"] = 6] = \\\"ASSUME_CODE_39_CHECK_DIGIT\\\"; /*(Void.class)*/\\r\\n    /**\\r\\n     * Assume the barcode is being processed as a GS1 barcode, and modify behavior as needed.\\r\\n     * For example this affects FNC1 handling for Code 128 (aka GS1-128). Doesn't matter what it maps to;\\r\\n     * use {@link Boolean#TRUE}.\\r\\n     */\\r\\n    DecodeHintType[DecodeHintType[\\\"ASSUME_GS1\\\"] = 7] = \\\"ASSUME_GS1\\\"; /*(Void.class)*/\\r\\n    /**\\r\\n     * If true, return the start and end digits in a Codabar barcode instead of stripping them. They\\r\\n     * are alpha, whereas the rest are numeric. By default, they are stripped, but this causes them\\r\\n     * to not be. Doesn't matter what it maps to; use {@link Boolean#TRUE}.\\r\\n     */\\r\\n    DecodeHintType[DecodeHintType[\\\"RETURN_CODABAR_START_END\\\"] = 8] = \\\"RETURN_CODABAR_START_END\\\"; /*(Void.class)*/\\r\\n    /**\\r\\n     * The caller needs to be notified via callback when a possible {@link ResultPoint}\\r\\n     * is found. Maps to a {@link ResultPointCallback}.\\r\\n     */\\r\\n    DecodeHintType[DecodeHintType[\\\"NEED_RESULT_POINT_CALLBACK\\\"] = 9] = \\\"NEED_RESULT_POINT_CALLBACK\\\"; /*(ResultPointCallback.class)*/\\r\\n    /**\\r\\n     * Allowed extension lengths for EAN or UPC barcodes. Other formats will ignore this.\\r\\n     * Maps to an {@code Int32Array} of the allowed extension lengths, for example [2], [5], or [2, 5].\\r\\n     * If it is optional to have an extension, do not set this hint. If this is set,\\r\\n     * and a UPC or EAN barcode is found but an extension is not, then no result will be returned\\r\\n     * at all.\\r\\n     */\\r\\n    DecodeHintType[DecodeHintType[\\\"ALLOWED_EAN_EXTENSIONS\\\"] = 10] = \\\"ALLOWED_EAN_EXTENSIONS\\\"; /*(Int32Array.class)*/\\r\\n    // End of enumeration values.\\r\\n    /**\\r\\n     * Data type the hint is expecting.\\r\\n     * Among the possible values the {@link Void} stands out as being used for\\r\\n     * hints that do not expect a value to be supplied (flag hints). Such hints\\r\\n     * will possibly have their value ignored, or replaced by a\\r\\n     * {@link Boolean#TRUE}. Hint suppliers should probably use\\r\\n     * {@link Boolean#TRUE} as directed by the actual hint documentation.\\r\\n     */\\r\\n    // private valueType: Class<?>\\r\\n    // DecodeHintType(valueType: Class<?>) {\\r\\n    //   this.valueType = valueType\\r\\n    // }\\r\\n    // public getValueType(): Class<?> {\\r\\n    //   return valueType\\r\\n    // }\\r\\n})(DecodeHintType || (DecodeHintType = {}));\\r\\nexports.default = DecodeHintType;\\r\\n\\n\\n//# sourceURL=webpack://OZSealRecognition/./src/core/DecodeHintType.ts?\");\r\n\r\n                /***/ }),\r\n\r\n            /***/ \"./src/core/Exception.ts\":\r\n            /*!*******************************!*\\\r\n              !*** ./src/core/Exception.ts ***!\r\n              \\*******************************/\r\n            /*! no static exports found */\r\n            /*! ModuleConcatenation bailout: Module is not an ECMAScript module */\r\n            /***/ (function(module, exports, __webpack_require__) {\r\n\r\n                \"use strict\";\r\n                eval(\"\\r\\nvar __extends = (this && this.__extends) || (function () {\\r\\n    var extendStatics = function (d, b) {\\r\\n        extendStatics = Object.setPrototypeOf ||\\r\\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\\r\\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\\r\\n        return extendStatics(d, b);\\r\\n    };\\r\\n    return function (d, b) {\\r\\n        extendStatics(d, b);\\r\\n        function __() { this.constructor = d; }\\r\\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\\r\\n    };\\r\\n})();\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\nvar ts_custom_error_1 = __webpack_require__(/*! ts-custom-error */ \\\"./node_modules/ts-custom-error/dist/custom-error.mjs\\\");\\r\\n/**\\r\\n * Custom Error class of type Exception.\\r\\n */\\r\\nvar Exception = /** @class */ (function (_super) {\\r\\n    __extends(Exception, _super);\\r\\n    /**\\r\\n     * Allows Exception to be constructed directly\\r\\n     * with some message and prototype definition.\\r\\n     */\\r\\n    function Exception(message) {\\r\\n        if (message === void 0) { message = undefined; }\\r\\n        var _this = _super.call(this, message) || this;\\r\\n        _this.message = message;\\r\\n        return _this;\\r\\n    }\\r\\n    return Exception;\\r\\n}(ts_custom_error_1.CustomError));\\r\\nexports.default = Exception;\\r\\n\\n\\n//# sourceURL=webpack://OZSealRecognition/./src/core/Exception.ts?\");\r\n\r\n                /***/ }),\r\n\r\n            /***/ \"./src/core/FormatException.ts\":\r\n            /*!*************************************!*\\\r\n              !*** ./src/core/FormatException.ts ***!\r\n              \\*************************************/\r\n            /*! no static exports found */\r\n            /*! ModuleConcatenation bailout: Module is not an ECMAScript module */\r\n            /***/ (function(module, exports, __webpack_require__) {\r\n\r\n                \"use strict\";\r\n                eval(\"\\r\\nvar __extends = (this && this.__extends) || (function () {\\r\\n    var extendStatics = function (d, b) {\\r\\n        extendStatics = Object.setPrototypeOf ||\\r\\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\\r\\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\\r\\n        return extendStatics(d, b);\\r\\n    };\\r\\n    return function (d, b) {\\r\\n        extendStatics(d, b);\\r\\n        function __() { this.constructor = d; }\\r\\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\\r\\n    };\\r\\n})();\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\nvar Exception_1 = __webpack_require__(/*! ./Exception */ \\\"./src/core/Exception.ts\\\");\\r\\n/**\\r\\n * Custom Error class of type Exception.\\r\\n */\\r\\nvar FormatException = /** @class */ (function (_super) {\\r\\n    __extends(FormatException, _super);\\r\\n    function FormatException() {\\r\\n        return _super !== null && _super.apply(this, arguments) || this;\\r\\n    }\\r\\n    FormatException.getFormatInstance = function () {\\r\\n        return new FormatException();\\r\\n    };\\r\\n    return FormatException;\\r\\n}(Exception_1.default));\\r\\nexports.default = FormatException;\\r\\n\\n\\n//# sourceURL=webpack://OZSealRecognition/./src/core/FormatException.ts?\");\r\n\r\n                /***/ }),\r\n\r\n            /***/ \"./src/core/NotFoundException.ts\":\r\n            /*!***************************************!*\\\r\n              !*** ./src/core/NotFoundException.ts ***!\r\n              \\***************************************/\r\n            /*! no static exports found */\r\n            /*! ModuleConcatenation bailout: Module is not an ECMAScript module */\r\n            /***/ (function(module, exports, __webpack_require__) {\r\n\r\n                \"use strict\";\r\n                eval(\"\\r\\nvar __extends = (this && this.__extends) || (function () {\\r\\n    var extendStatics = function (d, b) {\\r\\n        extendStatics = Object.setPrototypeOf ||\\r\\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\\r\\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\\r\\n        return extendStatics(d, b);\\r\\n    };\\r\\n    return function (d, b) {\\r\\n        extendStatics(d, b);\\r\\n        function __() { this.constructor = d; }\\r\\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\\r\\n    };\\r\\n})();\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\nvar Exception_1 = __webpack_require__(/*! ./Exception */ \\\"./src/core/Exception.ts\\\");\\r\\n/**\\r\\n * Custom Error class of type Exception.\\r\\n */\\r\\nvar NotFoundException = /** @class */ (function (_super) {\\r\\n    __extends(NotFoundException, _super);\\r\\n    function NotFoundException() {\\r\\n        return _super !== null && _super.apply(this, arguments) || this;\\r\\n    }\\r\\n    NotFoundException.getNotFoundInstance = function () {\\r\\n        return new NotFoundException();\\r\\n    };\\r\\n    return NotFoundException;\\r\\n}(Exception_1.default));\\r\\nexports.default = NotFoundException;\\r\\n\\n\\n//# sourceURL=webpack://OZSealRecognition/./src/core/NotFoundException.ts?\");\r\n\r\n                /***/ }),\r\n\r\n            /***/ \"./src/core/ResultPoint.ts\":\r\n            /*!*********************************!*\\\r\n              !*** ./src/core/ResultPoint.ts ***!\r\n              \\*********************************/\r\n            /*! no static exports found */\r\n            /*! ModuleConcatenation bailout: Module is not an ECMAScript module */\r\n            /***/ (function(module, exports, __webpack_require__) {\r\n\r\n                \"use strict\";\r\n                eval(\"\\r\\n/*\\r\\n * Copyright 2007 ZXing authors\\r\\n *\\r\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\r\\n * you may not use this file except in compliance with the License.\\r\\n * You may obtain a copy of the License at\\r\\n *\\r\\n *      http://www.apache.org/licenses/LICENSE-2.0\\r\\n *\\r\\n * Unless required by applicable law or agreed to in writing, software\\r\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\r\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\r\\n * See the License for the specific language governing permissions and\\r\\n * limitations under the License.\\r\\n */\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\n/*namespace com.google.zxing {*/\\r\\nvar MathUtils_1 = __webpack_require__(/*! ./common/detector/MathUtils */ \\\"./src/core/common/detector/MathUtils.ts\\\");\\r\\nvar Float_1 = __webpack_require__(/*! ./util/Float */ \\\"./src/core/util/Float.ts\\\");\\r\\n/**\\r\\n * <p>Encapsulates a point of interest in an image containing a barcode. Typically, this\\r\\n * would be the location of a finder pattern or the corner of the barcode, for example.</p>\\r\\n *\\r\\n * @author Sean Owen\\r\\n */\\r\\nvar ResultPoint = /** @class */ (function () {\\r\\n    function ResultPoint(x, y) {\\r\\n        this.x = x;\\r\\n        this.y = y;\\r\\n    }\\r\\n    ResultPoint.prototype.getX = function () {\\r\\n        return this.x;\\r\\n    };\\r\\n    ResultPoint.prototype.getY = function () {\\r\\n        return this.y;\\r\\n    };\\r\\n    /*@Override*/\\r\\n    ResultPoint.prototype.equals = function (other) {\\r\\n        if (other instanceof ResultPoint) {\\r\\n            var otherPoint = other;\\r\\n            return this.x === otherPoint.x && this.y === otherPoint.y;\\r\\n        }\\r\\n        return false;\\r\\n    };\\r\\n    /*@Override*/\\r\\n    ResultPoint.prototype.hashCode = function () {\\r\\n        return 31 * Float_1.default.floatToIntBits(this.x) + Float_1.default.floatToIntBits(this.y);\\r\\n    };\\r\\n    /*@Override*/\\r\\n    ResultPoint.prototype.toString = function () {\\r\\n        return '(' + this.x + ',' + this.y + ')';\\r\\n    };\\r\\n    /**\\r\\n     * Orders an array of three ResultPoints in an order [A,B,C] such that AB is less than AC\\r\\n     * and BC is less than AC, and the angle between BC and BA is less than 180 degrees.\\r\\n     *\\r\\n     * @param patterns array of three {@code ResultPoint} to order\\r\\n     */\\r\\n    ResultPoint.orderBestPatterns = function (patterns) {\\r\\n        // Find distances between pattern centers\\r\\n        var zeroOneDistance = this.distance(patterns[0], patterns[1]);\\r\\n        var oneTwoDistance = this.distance(patterns[1], patterns[2]);\\r\\n        var zeroTwoDistance = this.distance(patterns[0], patterns[2]);\\r\\n        var pointA;\\r\\n        var pointB;\\r\\n        var pointC;\\r\\n        // Assume one closest to other two is B; A and C will just be guesses at first\\r\\n        if (oneTwoDistance >= zeroOneDistance && oneTwoDistance >= zeroTwoDistance) {\\r\\n            pointB = patterns[0];\\r\\n            pointA = patterns[1];\\r\\n            pointC = patterns[2];\\r\\n        }\\r\\n        else if (zeroTwoDistance >= oneTwoDistance && zeroTwoDistance >= zeroOneDistance) {\\r\\n            pointB = patterns[1];\\r\\n            pointA = patterns[0];\\r\\n            pointC = patterns[2];\\r\\n        }\\r\\n        else {\\r\\n            pointB = patterns[2];\\r\\n            pointA = patterns[0];\\r\\n            pointC = patterns[1];\\r\\n        }\\r\\n        // Use cross product to figure out whether A and C are correct or flipped.\\r\\n        // This asks whether BC x BA has a positive z component, which is the arrangement\\r\\n        // we want for A, B, C. If it's negative, then we've got it flipped around and\\r\\n        // should swap A and C.\\r\\n        if (this.crossProductZ(pointA, pointB, pointC) < 0.0) {\\r\\n            var temp = pointA;\\r\\n            pointA = pointC;\\r\\n            pointC = temp;\\r\\n        }\\r\\n        patterns[0] = pointA;\\r\\n        patterns[1] = pointB;\\r\\n        patterns[2] = pointC;\\r\\n    };\\r\\n    /**\\r\\n     * @param pattern1 first pattern\\r\\n     * @param pattern2 second pattern\\r\\n     * @return distance between two points\\r\\n     */\\r\\n    ResultPoint.distance = function (pattern1, pattern2) {\\r\\n        return MathUtils_1.default.distance(pattern1.x, pattern1.y, pattern2.x, pattern2.y);\\r\\n    };\\r\\n    /**\\r\\n     * Returns the z component of the cross product between vectors BC and BA.\\r\\n     */\\r\\n    ResultPoint.crossProductZ = function (pointA, pointB, pointC) {\\r\\n        var bX = pointB.x;\\r\\n        var bY = pointB.y;\\r\\n        return ((pointC.x - bX) * (pointA.y - bY)) - ((pointC.y - bY) * (pointA.x - bX));\\r\\n    };\\r\\n    return ResultPoint;\\r\\n}());\\r\\nexports.default = ResultPoint;\\r\\n\\n\\n//# sourceURL=webpack://OZSealRecognition/./src/core/ResultPoint.ts?\");\r\n\r\n                /***/ }),\r\n\r\n            /***/ \"./src/core/UnsupportedOperationException.ts\":\r\n            /*!***************************************************!*\\\r\n              !*** ./src/core/UnsupportedOperationException.ts ***!\r\n              \\***************************************************/\r\n            /*! no static exports found */\r\n            /*! ModuleConcatenation bailout: Module is not an ECMAScript module */\r\n            /***/ (function(module, exports, __webpack_require__) {\r\n\r\n                \"use strict\";\r\n                eval(\"\\r\\nvar __extends = (this && this.__extends) || (function () {\\r\\n    var extendStatics = function (d, b) {\\r\\n        extendStatics = Object.setPrototypeOf ||\\r\\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\\r\\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\\r\\n        return extendStatics(d, b);\\r\\n    };\\r\\n    return function (d, b) {\\r\\n        extendStatics(d, b);\\r\\n        function __() { this.constructor = d; }\\r\\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\\r\\n    };\\r\\n})();\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\nvar Exception_1 = __webpack_require__(/*! ./Exception */ \\\"./src/core/Exception.ts\\\");\\r\\n/**\\r\\n * Custom Error class of type Exception.\\r\\n */\\r\\nvar UnsupportedOperationException = /** @class */ (function (_super) {\\r\\n    __extends(UnsupportedOperationException, _super);\\r\\n    function UnsupportedOperationException() {\\r\\n        return _super !== null && _super.apply(this, arguments) || this;\\r\\n    }\\r\\n    return UnsupportedOperationException;\\r\\n}(Exception_1.default));\\r\\nexports.default = UnsupportedOperationException;\\r\\n\\n\\n//# sourceURL=webpack://OZSealRecognition/./src/core/UnsupportedOperationException.ts?\");\r\n\r\n                /***/ }),\r\n\r\n            /***/ \"./src/core/common/CharacterSetECI.ts\":\r\n            /*!********************************************!*\\\r\n              !*** ./src/core/common/CharacterSetECI.ts ***!\r\n              \\********************************************/\r\n            /*! no static exports found */\r\n            /*! ModuleConcatenation bailout: Module is not an ECMAScript module */\r\n            /***/ (function(module, exports, __webpack_require__) {\r\n\r\n                \"use strict\";\r\n                eval(\"\\r\\n/*\\r\\n * Copyright 2008 ZXing authors\\r\\n *\\r\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\r\\n * you may not use this file except in compliance with the License.\\r\\n * You may obtain a copy of the License at\\r\\n *\\r\\n *      http://www.apache.org/licenses/LICENSE-2.0\\r\\n *\\r\\n * Unless required by applicable law or agreed to in writing, software\\r\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\r\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\r\\n * See the License for the specific language governing permissions and\\r\\n * limitations under the License.\\r\\n */\\r\\nvar __values = (this && this.__values) || function(o) {\\r\\n    var s = typeof Symbol === \\\"function\\\" && Symbol.iterator, m = s && o[s], i = 0;\\r\\n    if (m) return m.call(o);\\r\\n    if (o && typeof o.length === \\\"number\\\") return {\\r\\n        next: function () {\\r\\n            if (o && i >= o.length) o = void 0;\\r\\n            return { value: o && o[i++], done: !o };\\r\\n        }\\r\\n    };\\r\\n    throw new TypeError(s ? \\\"Object is not iterable.\\\" : \\\"Symbol.iterator is not defined.\\\");\\r\\n};\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\nexports.CharacterSetValueIdentifiers = void 0;\\r\\n/*namespace com.google.zxing.common {*/\\r\\nvar FormatException_1 = __webpack_require__(/*! ../FormatException */ \\\"./src/core/FormatException.ts\\\");\\r\\n/*import java.util.HashMap;*/\\r\\n/*import java.util.Map;*/\\r\\nvar CharacterSetValueIdentifiers;\\r\\n(function (CharacterSetValueIdentifiers) {\\r\\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\\\"Cp437\\\"] = 0] = \\\"Cp437\\\";\\r\\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\\\"ISO8859_1\\\"] = 1] = \\\"ISO8859_1\\\";\\r\\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\\\"ISO8859_2\\\"] = 2] = \\\"ISO8859_2\\\";\\r\\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\\\"ISO8859_3\\\"] = 3] = \\\"ISO8859_3\\\";\\r\\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\\\"ISO8859_4\\\"] = 4] = \\\"ISO8859_4\\\";\\r\\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\\\"ISO8859_5\\\"] = 5] = \\\"ISO8859_5\\\";\\r\\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\\\"ISO8859_6\\\"] = 6] = \\\"ISO8859_6\\\";\\r\\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\\\"ISO8859_7\\\"] = 7] = \\\"ISO8859_7\\\";\\r\\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\\\"ISO8859_8\\\"] = 8] = \\\"ISO8859_8\\\";\\r\\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\\\"ISO8859_9\\\"] = 9] = \\\"ISO8859_9\\\";\\r\\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\\\"ISO8859_10\\\"] = 10] = \\\"ISO8859_10\\\";\\r\\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\\\"ISO8859_11\\\"] = 11] = \\\"ISO8859_11\\\";\\r\\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\\\"ISO8859_13\\\"] = 12] = \\\"ISO8859_13\\\";\\r\\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\\\"ISO8859_14\\\"] = 13] = \\\"ISO8859_14\\\";\\r\\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\\\"ISO8859_15\\\"] = 14] = \\\"ISO8859_15\\\";\\r\\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\\\"ISO8859_16\\\"] = 15] = \\\"ISO8859_16\\\";\\r\\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\\\"SJIS\\\"] = 16] = \\\"SJIS\\\";\\r\\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\\\"Cp1250\\\"] = 17] = \\\"Cp1250\\\";\\r\\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\\\"Cp1251\\\"] = 18] = \\\"Cp1251\\\";\\r\\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\\\"Cp1252\\\"] = 19] = \\\"Cp1252\\\";\\r\\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\\\"Cp1256\\\"] = 20] = \\\"Cp1256\\\";\\r\\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\\\"UnicodeBigUnmarked\\\"] = 21] = \\\"UnicodeBigUnmarked\\\";\\r\\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\\\"UTF8\\\"] = 22] = \\\"UTF8\\\";\\r\\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\\\"ASCII\\\"] = 23] = \\\"ASCII\\\";\\r\\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\\\"Big5\\\"] = 24] = \\\"Big5\\\";\\r\\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\\\"GB18030\\\"] = 25] = \\\"GB18030\\\";\\r\\n    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\\\"EUC_KR\\\"] = 26] = \\\"EUC_KR\\\";\\r\\n})(CharacterSetValueIdentifiers = exports.CharacterSetValueIdentifiers || (exports.CharacterSetValueIdentifiers = {}));\\r\\n/**\\r\\n * Encapsulates a Character Set ECI, according to \\\"Extended Channel Interpretations\\\" 5.3.1.1\\r\\n * of ISO 18004.\\r\\n *\\r\\n * @author Sean Owen\\r\\n */\\r\\nvar CharacterSetECI = /** @class */ (function () {\\r\\n    function CharacterSetECI(valueIdentifier, valuesParam, name) {\\r\\n        var e_1, _a;\\r\\n        var otherEncodingNames = [];\\r\\n        for (var _i = 3; _i < arguments.length; _i++) {\\r\\n            otherEncodingNames[_i - 3] = arguments[_i];\\r\\n        }\\r\\n        this.valueIdentifier = valueIdentifier;\\r\\n        this.name = name;\\r\\n        if (typeof valuesParam === 'number') {\\r\\n            this.values = Int32Array.from([valuesParam]);\\r\\n        }\\r\\n        else {\\r\\n            this.values = valuesParam;\\r\\n        }\\r\\n        this.otherEncodingNames = otherEncodingNames;\\r\\n        CharacterSetECI.VALUE_IDENTIFIER_TO_ECI.set(valueIdentifier, this);\\r\\n        CharacterSetECI.NAME_TO_ECI.set(name, this);\\r\\n        var values = this.values;\\r\\n        for (var i = 0, length_1 = values.length; i !== length_1; i++) {\\r\\n            var v = values[i];\\r\\n            CharacterSetECI.VALUES_TO_ECI.set(v, this);\\r\\n        }\\r\\n        try {\\r\\n            for (var otherEncodingNames_1 = __values(otherEncodingNames), otherEncodingNames_1_1 = otherEncodingNames_1.next(); !otherEncodingNames_1_1.done; otherEncodingNames_1_1 = otherEncodingNames_1.next()) {\\r\\n                var otherName = otherEncodingNames_1_1.value;\\r\\n                CharacterSetECI.NAME_TO_ECI.set(otherName, this);\\r\\n            }\\r\\n        }\\r\\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\\r\\n        finally {\\r\\n            try {\\r\\n                if (otherEncodingNames_1_1 && !otherEncodingNames_1_1.done && (_a = otherEncodingNames_1.return)) _a.call(otherEncodingNames_1);\\r\\n            }\\r\\n            finally { if (e_1) throw e_1.error; }\\r\\n        }\\r\\n    }\\r\\n    // CharacterSetECI(value: number /*int*/) {\\r\\n    //   this(new Int32Array {value})\\r\\n    // }\\r\\n    // CharacterSetECI(value: number /*int*/, String... otherEncodingNames) {\\r\\n    //   this.values = new Int32Array {value}\\r\\n    //   this.otherEncodingNames = otherEncodingNames\\r\\n    // }\\r\\n    // CharacterSetECI(values: Int32Array, String... otherEncodingNames) {\\r\\n    //   this.values = values\\r\\n    //   this.otherEncodingNames = otherEncodingNames\\r\\n    // }\\r\\n    CharacterSetECI.prototype.getValueIdentifier = function () {\\r\\n        return this.valueIdentifier;\\r\\n    };\\r\\n    CharacterSetECI.prototype.getName = function () {\\r\\n        return this.name;\\r\\n    };\\r\\n    CharacterSetECI.prototype.getValue = function () {\\r\\n        return this.values[0];\\r\\n    };\\r\\n    /**\\r\\n     * @param value character set ECI value\\r\\n     * @return {@code CharacterSetECI} representing ECI of given value, or null if it is legal but\\r\\n     *   unsupported\\r\\n     * @throws FormatException if ECI value is invalid\\r\\n     */\\r\\n    CharacterSetECI.getCharacterSetECIByValue = function (value /*int*/) {\\r\\n        if (value < 0 || value >= 900) {\\r\\n            throw new FormatException_1.default('incorect value');\\r\\n        }\\r\\n        var characterSet = CharacterSetECI.VALUES_TO_ECI.get(value);\\r\\n        if (undefined === characterSet) {\\r\\n            throw new FormatException_1.default('incorect value');\\r\\n        }\\r\\n        return characterSet;\\r\\n    };\\r\\n    /**\\r\\n     * @param name character set ECI encoding name\\r\\n     * @return CharacterSetECI representing ECI for character encoding, or null if it is legal\\r\\n     *   but unsupported\\r\\n     */\\r\\n    CharacterSetECI.getCharacterSetECIByName = function (name) {\\r\\n        var characterSet = CharacterSetECI.NAME_TO_ECI.get(name);\\r\\n        if (undefined === characterSet) {\\r\\n            throw new FormatException_1.default('incorect value');\\r\\n        }\\r\\n        return characterSet;\\r\\n    };\\r\\n    CharacterSetECI.prototype.equals = function (o) {\\r\\n        if (!(o instanceof CharacterSetECI)) {\\r\\n            return false;\\r\\n        }\\r\\n        var other = o;\\r\\n        return this.getName() === other.getName();\\r\\n    };\\r\\n    CharacterSetECI.VALUE_IDENTIFIER_TO_ECI = new Map();\\r\\n    CharacterSetECI.VALUES_TO_ECI = new Map();\\r\\n    CharacterSetECI.NAME_TO_ECI = new Map();\\r\\n    // Enum name is a Java encoding valid for java.lang and java.io\\r\\n    // TYPESCRIPTPORT: changed the main label for ISO as the TextEncoder did not recognized them in the form from java\\r\\n    // (eg ISO8859_1 must be ISO88591 or ISO8859-1 or ISO-8859-1)\\r\\n    // later on: well, except 16 wich does not work with ISO885916 so used ISO-8859-1 form for default\\r\\n    CharacterSetECI.Cp437 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp437, Int32Array.from([0, 2]), 'Cp437');\\r\\n    CharacterSetECI.ISO8859_1 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_1, Int32Array.from([1, 3]), 'ISO-8859-1', 'ISO88591', 'ISO8859_1');\\r\\n    CharacterSetECI.ISO8859_2 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_2, 4, 'ISO-8859-2', 'ISO88592', 'ISO8859_2');\\r\\n    CharacterSetECI.ISO8859_3 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_3, 5, 'ISO-8859-3', 'ISO88593', 'ISO8859_3');\\r\\n    CharacterSetECI.ISO8859_4 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_4, 6, 'ISO-8859-4', 'ISO88594', 'ISO8859_4');\\r\\n    CharacterSetECI.ISO8859_5 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_5, 7, 'ISO-8859-5', 'ISO88595', 'ISO8859_5');\\r\\n    CharacterSetECI.ISO8859_6 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_6, 8, 'ISO-8859-6', 'ISO88596', 'ISO8859_6');\\r\\n    CharacterSetECI.ISO8859_7 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_7, 9, 'ISO-8859-7', 'ISO88597', 'ISO8859_7');\\r\\n    CharacterSetECI.ISO8859_8 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_8, 10, 'ISO-8859-8', 'ISO88598', 'ISO8859_8');\\r\\n    CharacterSetECI.ISO8859_9 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_9, 11, 'ISO-8859-9', 'ISO88599', 'ISO8859_9');\\r\\n    CharacterSetECI.ISO8859_10 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_10, 12, 'ISO-8859-10', 'ISO885910', 'ISO8859_10');\\r\\n    CharacterSetECI.ISO8859_11 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_11, 13, 'ISO-8859-11', 'ISO885911', 'ISO8859_11');\\r\\n    CharacterSetECI.ISO8859_13 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_13, 15, 'ISO-8859-13', 'ISO885913', 'ISO8859_13');\\r\\n    CharacterSetECI.ISO8859_14 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_14, 16, 'ISO-8859-14', 'ISO885914', 'ISO8859_14');\\r\\n    CharacterSetECI.ISO8859_15 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_15, 17, 'ISO-8859-15', 'ISO885915', 'ISO8859_15');\\r\\n    CharacterSetECI.ISO8859_16 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_16, 18, 'ISO-8859-16', 'ISO885916', 'ISO8859_16');\\r\\n    CharacterSetECI.SJIS = new CharacterSetECI(CharacterSetValueIdentifiers.SJIS, 20, 'SJIS', 'Shift_JIS');\\r\\n    CharacterSetECI.Cp1250 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1250, 21, 'Cp1250', 'windows-1250');\\r\\n    CharacterSetECI.Cp1251 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1251, 22, 'Cp1251', 'windows-1251');\\r\\n    CharacterSetECI.Cp1252 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1252, 23, 'Cp1252', 'windows-1252');\\r\\n    CharacterSetECI.Cp1256 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1256, 24, 'Cp1256', 'windows-1256');\\r\\n    CharacterSetECI.UnicodeBigUnmarked = new CharacterSetECI(CharacterSetValueIdentifiers.UnicodeBigUnmarked, 25, 'UnicodeBigUnmarked', 'UTF-16BE', 'UnicodeBig');\\r\\n    CharacterSetECI.UTF8 = new CharacterSetECI(CharacterSetValueIdentifiers.UTF8, 26, 'UTF8', 'UTF-8');\\r\\n    CharacterSetECI.ASCII = new CharacterSetECI(CharacterSetValueIdentifiers.ASCII, Int32Array.from([27, 170]), 'ASCII', 'US-ASCII');\\r\\n    CharacterSetECI.Big5 = new CharacterSetECI(CharacterSetValueIdentifiers.Big5, 28, 'Big5');\\r\\n    CharacterSetECI.GB18030 = new CharacterSetECI(CharacterSetValueIdentifiers.GB18030, 29, 'GB18030', 'GB2312', 'EUC_CN', 'GBK');\\r\\n    CharacterSetECI.EUC_KR = new CharacterSetECI(CharacterSetValueIdentifiers.EUC_KR, 30, 'EUC_KR', 'EUC-KR');\\r\\n    return CharacterSetECI;\\r\\n}());\\r\\nexports.default = CharacterSetECI;\\r\\n\\n\\n//# sourceURL=webpack://OZSealRecognition/./src/core/common/CharacterSetECI.ts?\");\r\n\r\n                /***/ }),\r\n\r\n            /***/ \"./src/core/common/StringUtils.ts\":\r\n            /*!****************************************!*\\\r\n              !*** ./src/core/common/StringUtils.ts ***!\r\n              \\****************************************/\r\n            /*! no static exports found */\r\n            /*! ModuleConcatenation bailout: Module is not an ECMAScript module */\r\n            /***/ (function(module, exports, __webpack_require__) {\r\n\r\n                \"use strict\";\r\n                eval(\"\\r\\n/*\\r\\n * Copyright (C) 2010 ZXing authors\\r\\n *\\r\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\r\\n * you may not use this file except in compliance with the License.\\r\\n * You may obtain a copy of the License at\\r\\n *\\r\\n *      http://www.apache.org/licenses/LICENSE-2.0\\r\\n *\\r\\n * Unless required by applicable law or agreed to in writing, software\\r\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\r\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\r\\n * See the License for the specific language governing permissions and\\r\\n * limitations under the License.\\r\\n */\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\n/*namespace com.google.zxing.common {*/\\r\\n/*import java.nio.charset.Charset;*/\\r\\n/*import java.util.Map;*/\\r\\nvar DecodeHintType_1 = __webpack_require__(/*! ../DecodeHintType */ \\\"./src/core/DecodeHintType.ts\\\");\\r\\nvar CharacterSetECI_1 = __webpack_require__(/*! ./CharacterSetECI */ \\\"./src/core/common/CharacterSetECI.ts\\\");\\r\\nvar StringEncoding_1 = __webpack_require__(/*! ../util/StringEncoding */ \\\"./src/core/util/StringEncoding.ts\\\");\\r\\n/**\\r\\n * Common string-related functions.\\r\\n *\\r\\n * @author Sean Owen\\r\\n * @author Alex Dupre\\r\\n */\\r\\nvar StringUtils = /** @class */ (function () {\\r\\n    function StringUtils() {\\r\\n    }\\r\\n    // SHIFT_JIS.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING) ||\\r\\n    // EUC_JP.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING);\\r\\n    StringUtils.castAsNonUtf8Char = function (code, encoding) {\\r\\n        if (encoding === void 0) { encoding = null; }\\r\\n        // ISO 8859-1 is the Java default as UTF-8 is JavaScripts\\r\\n        // you can see this method as a Java version of String.fromCharCode\\r\\n        var e = encoding ? encoding.getName() : this.ISO88591;\\r\\n        // use passed format (fromCharCode will return UTF8 encoding)\\r\\n        return StringEncoding_1.default.decode(new Uint8Array([code]), e);\\r\\n    };\\r\\n    /**\\r\\n     * @param bytes bytes encoding a string, whose encoding should be guessed\\r\\n     * @param hints decode hints if applicable\\r\\n     * @return name of guessed encoding; at the moment will only guess one of:\\r\\n     *  {@link #SHIFT_JIS}, {@link #UTF8}, {@link #ISO88591}, or the platform\\r\\n     *  default encoding if none of these can possibly be correct\\r\\n     */\\r\\n    StringUtils.guessEncoding = function (bytes, hints) {\\r\\n        if (hints !== null && hints !== undefined && undefined !== hints.get(DecodeHintType_1.default.CHARACTER_SET)) {\\r\\n            return hints.get(DecodeHintType_1.default.CHARACTER_SET).toString();\\r\\n        }\\r\\n        // For now, merely tries to distinguish ISO-8859-1, UTF-8 and Shift_JIS,\\r\\n        // which should be by far the most common encodings.\\r\\n        var length = bytes.length;\\r\\n        var canBeISO88591 = true;\\r\\n        var canBeShiftJIS = true;\\r\\n        var canBeUTF8 = true;\\r\\n        var utf8BytesLeft = 0;\\r\\n        // int utf8LowChars = 0\\r\\n        var utf2BytesChars = 0;\\r\\n        var utf3BytesChars = 0;\\r\\n        var utf4BytesChars = 0;\\r\\n        var sjisBytesLeft = 0;\\r\\n        // int sjisLowChars = 0\\r\\n        var sjisKatakanaChars = 0;\\r\\n        // int sjisDoubleBytesChars = 0\\r\\n        var sjisCurKatakanaWordLength = 0;\\r\\n        var sjisCurDoubleBytesWordLength = 0;\\r\\n        var sjisMaxKatakanaWordLength = 0;\\r\\n        var sjisMaxDoubleBytesWordLength = 0;\\r\\n        // int isoLowChars = 0\\r\\n        // int isoHighChars = 0\\r\\n        var isoHighOther = 0;\\r\\n        var utf8bom = bytes.length > 3 &&\\r\\n            bytes[0] === /*(byte) */ 0xEF &&\\r\\n            bytes[1] === /*(byte) */ 0xBB &&\\r\\n            bytes[2] === /*(byte) */ 0xBF;\\r\\n        for (var i = 0; i < length && (canBeISO88591 || canBeShiftJIS || canBeUTF8); i++) {\\r\\n            var value = bytes[i] & 0xFF;\\r\\n            // UTF-8 stuff\\r\\n            if (canBeUTF8) {\\r\\n                if (utf8BytesLeft > 0) {\\r\\n                    if ((value & 0x80) === 0) {\\r\\n                        canBeUTF8 = false;\\r\\n                    }\\r\\n                    else {\\r\\n                        utf8BytesLeft--;\\r\\n                    }\\r\\n                }\\r\\n                else if ((value & 0x80) !== 0) {\\r\\n                    if ((value & 0x40) === 0) {\\r\\n                        canBeUTF8 = false;\\r\\n                    }\\r\\n                    else {\\r\\n                        utf8BytesLeft++;\\r\\n                        if ((value & 0x20) === 0) {\\r\\n                            utf2BytesChars++;\\r\\n                        }\\r\\n                        else {\\r\\n                            utf8BytesLeft++;\\r\\n                            if ((value & 0x10) === 0) {\\r\\n                                utf3BytesChars++;\\r\\n                            }\\r\\n                            else {\\r\\n                                utf8BytesLeft++;\\r\\n                                if ((value & 0x08) === 0) {\\r\\n                                    utf4BytesChars++;\\r\\n                                }\\r\\n                                else {\\r\\n                                    canBeUTF8 = false;\\r\\n                                }\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                } // else {\\r\\n                // utf8LowChars++\\r\\n                // }\\r\\n            }\\r\\n            // ISO-8859-1 stuff\\r\\n            if (canBeISO88591) {\\r\\n                if (value > 0x7F && value < 0xA0) {\\r\\n                    canBeISO88591 = false;\\r\\n                }\\r\\n                else if (value > 0x9F) {\\r\\n                    if (value < 0xC0 || value === 0xD7 || value === 0xF7) {\\r\\n                        isoHighOther++;\\r\\n                    } // else {\\r\\n                    // isoHighChars++\\r\\n                    // }\\r\\n                } // else {\\r\\n                // isoLowChars++\\r\\n                // }\\r\\n            }\\r\\n            // Shift_JIS stuff\\r\\n            if (canBeShiftJIS) {\\r\\n                if (sjisBytesLeft > 0) {\\r\\n                    if (value < 0x40 || value === 0x7F || value > 0xFC) {\\r\\n                        canBeShiftJIS = false;\\r\\n                    }\\r\\n                    else {\\r\\n                        sjisBytesLeft--;\\r\\n                    }\\r\\n                }\\r\\n                else if (value === 0x80 || value === 0xA0 || value > 0xEF) {\\r\\n                    canBeShiftJIS = false;\\r\\n                }\\r\\n                else if (value > 0xA0 && value < 0xE0) {\\r\\n                    sjisKatakanaChars++;\\r\\n                    sjisCurDoubleBytesWordLength = 0;\\r\\n                    sjisCurKatakanaWordLength++;\\r\\n                    if (sjisCurKatakanaWordLength > sjisMaxKatakanaWordLength) {\\r\\n                        sjisMaxKatakanaWordLength = sjisCurKatakanaWordLength;\\r\\n                    }\\r\\n                }\\r\\n                else if (value > 0x7F) {\\r\\n                    sjisBytesLeft++;\\r\\n                    // sjisDoubleBytesChars++\\r\\n                    sjisCurKatakanaWordLength = 0;\\r\\n                    sjisCurDoubleBytesWordLength++;\\r\\n                    if (sjisCurDoubleBytesWordLength > sjisMaxDoubleBytesWordLength) {\\r\\n                        sjisMaxDoubleBytesWordLength = sjisCurDoubleBytesWordLength;\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    // sjisLowChars++\\r\\n                    sjisCurKatakanaWordLength = 0;\\r\\n                    sjisCurDoubleBytesWordLength = 0;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        if (canBeUTF8 && utf8BytesLeft > 0) {\\r\\n            canBeUTF8 = false;\\r\\n        }\\r\\n        if (canBeShiftJIS && sjisBytesLeft > 0) {\\r\\n            canBeShiftJIS = false;\\r\\n        }\\r\\n        // Easy -- if there is BOM or at least 1 valid not-single byte character (and no evidence it can't be UTF-8), done\\r\\n        if (canBeUTF8 && (utf8bom || utf2BytesChars + utf3BytesChars + utf4BytesChars > 0)) {\\r\\n            return StringUtils.UTF8;\\r\\n        }\\r\\n        // Easy -- if assuming Shift_JIS or at least 3 valid consecutive not-ascii characters (and no evidence it can't be), done\\r\\n        if (canBeShiftJIS && (StringUtils.ASSUME_SHIFT_JIS || sjisMaxKatakanaWordLength >= 3 || sjisMaxDoubleBytesWordLength >= 3)) {\\r\\n            return StringUtils.SHIFT_JIS;\\r\\n        }\\r\\n        // Distinguishing Shift_JIS and ISO-8859-1 can be a little tough for short words. The crude heuristic is:\\r\\n        // - If we saw\\r\\n        //   - only two consecutive katakana chars in the whole text, or\\r\\n        //   - at least 10% of bytes that could be \\\"upper\\\" not-alphanumeric Latin1,\\r\\n        // - then we conclude Shift_JIS, else ISO-8859-1\\r\\n        if (canBeISO88591 && canBeShiftJIS) {\\r\\n            return (sjisMaxKatakanaWordLength === 2 && sjisKatakanaChars === 2) || isoHighOther * 10 >= length\\r\\n                ? StringUtils.SHIFT_JIS : StringUtils.ISO88591;\\r\\n        }\\r\\n        // Otherwise, try in order ISO-8859-1, Shift JIS, UTF-8 and fall back to default platform encoding\\r\\n        if (canBeISO88591) {\\r\\n            return StringUtils.ISO88591;\\r\\n        }\\r\\n        if (canBeShiftJIS) {\\r\\n            return StringUtils.SHIFT_JIS;\\r\\n        }\\r\\n        if (canBeUTF8) {\\r\\n            return StringUtils.UTF8;\\r\\n        }\\r\\n        // Otherwise, we take a wild guess with platform encoding\\r\\n        return StringUtils.PLATFORM_DEFAULT_ENCODING;\\r\\n    };\\r\\n    /**\\r\\n     *\\r\\n     * @see https://stackoverflow.com/a/13439711/4367683\\r\\n     *\\r\\n     * @param append The new string to append.\\r\\n     * @param args Argumets values to be formated.\\r\\n     */\\r\\n    StringUtils.format = function (append) {\\r\\n        var args = [];\\r\\n        for (var _i = 1; _i < arguments.length; _i++) {\\r\\n            args[_i - 1] = arguments[_i];\\r\\n        }\\r\\n        var i = -1;\\r\\n        function callback(exp, p0, p1, p2, p3, p4) {\\r\\n            if (exp === '%%')\\r\\n                return '%';\\r\\n            if (args[++i] === undefined)\\r\\n                return undefined;\\r\\n            exp = p2 ? parseInt(p2.substr(1)) : undefined;\\r\\n            var base = p3 ? parseInt(p3.substr(1)) : undefined;\\r\\n            var val;\\r\\n            switch (p4) {\\r\\n                case 's':\\r\\n                    val = args[i];\\r\\n                    break;\\r\\n                case 'c':\\r\\n                    val = args[i][0];\\r\\n                    break;\\r\\n                case 'f':\\r\\n                    val = parseFloat(args[i]).toFixed(exp);\\r\\n                    break;\\r\\n                case 'p':\\r\\n                    val = parseFloat(args[i]).toPrecision(exp);\\r\\n                    break;\\r\\n                case 'e':\\r\\n                    val = parseFloat(args[i]).toExponential(exp);\\r\\n                    break;\\r\\n                case 'x':\\r\\n                    val = parseInt(args[i]).toString(base ? base : 16);\\r\\n                    break;\\r\\n                case 'd':\\r\\n                    val = parseFloat(parseInt(args[i], base ? base : 10).toPrecision(exp)).toFixed(0);\\r\\n                    break;\\r\\n            }\\r\\n            val = typeof val === 'object' ? JSON.stringify(val) : (+val).toString(base);\\r\\n            var size = parseInt(p1); /* padding size */\\r\\n            var ch = p1 && (p1[0] + '') === '0' ? '0' : ' '; /* isnull? */\\r\\n            while (val.length < size)\\r\\n                val = p0 !== undefined ? val + ch : ch + val; /* isminus? */\\r\\n            return val;\\r\\n        }\\r\\n        var regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;\\r\\n        return append.replace(regex, callback);\\r\\n    };\\r\\n    /**\\r\\n     *\\r\\n     */\\r\\n    StringUtils.getBytes = function (str, encoding) {\\r\\n        return StringEncoding_1.default.encode(str, encoding);\\r\\n    };\\r\\n    /**\\r\\n     * Returns the charcode at the specified index or at index zero.\\r\\n     */\\r\\n    StringUtils.getCharCode = function (str, index) {\\r\\n        if (index === void 0) { index = 0; }\\r\\n        return str.charCodeAt(index);\\r\\n    };\\r\\n    /**\\r\\n     * Returns char for given charcode\\r\\n     */\\r\\n    StringUtils.getCharAt = function (charCode) {\\r\\n        return String.fromCharCode(charCode);\\r\\n    };\\r\\n    StringUtils.SHIFT_JIS = CharacterSetECI_1.default.SJIS.getName(); // \\\"SJIS\\\"\\r\\n    StringUtils.GB2312 = 'GB2312';\\r\\n    StringUtils.ISO88591 = CharacterSetECI_1.default.ISO8859_1.getName(); // \\\"ISO8859_1\\\"\\r\\n    StringUtils.EUC_JP = 'EUC_JP';\\r\\n    StringUtils.UTF8 = CharacterSetECI_1.default.UTF8.getName(); // \\\"UTF8\\\"\\r\\n    StringUtils.PLATFORM_DEFAULT_ENCODING = StringUtils.UTF8; // \\\"UTF8\\\"//Charset.defaultCharset().name()\\r\\n    StringUtils.ASSUME_SHIFT_JIS = false;\\r\\n    return StringUtils;\\r\\n}());\\r\\nexports.default = StringUtils;\\r\\n\\n\\n//# sourceURL=webpack://OZSealRecognition/./src/core/common/StringUtils.ts?\");\r\n\r\n                /***/ }),\r\n\r\n            /***/ \"./src/core/common/detector/MathUtils.ts\":\r\n            /*!***********************************************!*\\\r\n              !*** ./src/core/common/detector/MathUtils.ts ***!\r\n              \\***********************************************/\r\n            /*! no static exports found */\r\n            /*! ModuleConcatenation bailout: Module is not an ECMAScript module */\r\n            /***/ (function(module, exports, __webpack_require__) {\r\n\r\n                \"use strict\";\r\n                eval(\"\\r\\n/*\\r\\n * Copyright 2012 ZXing authors\\r\\n *\\r\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\r\\n * you may not use this file except in compliance with the License.\\r\\n * You may obtain a copy of the License at\\r\\n *\\r\\n *      http://www.apache.org/licenses/LICENSE-2.0\\r\\n *\\r\\n * Unless required by applicable law or agreed to in writing, software\\r\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\r\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\r\\n * See the License for the specific language governing permissions and\\r\\n * limitations under the License.\\r\\n */\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\n/*namespace com.google.zxing.common.detector {*/\\r\\n/**\\r\\n * General math-related and numeric utility functions.\\r\\n */\\r\\nvar MathUtils = /** @class */ (function () {\\r\\n    function MathUtils() {\\r\\n    }\\r\\n    MathUtils.prototype.MathUtils = function () {\\r\\n    };\\r\\n    /**\\r\\n     * Ends up being a bit faster than {@link Math#round(float)}. This merely rounds its\\r\\n     * argument to the nearest int, where x.5 rounds up to x+1. Semantics of this shortcut\\r\\n     * differ slightly from {@link Math#round(float)} in that half rounds down for negative\\r\\n     * values. -2.5 rounds to -3, not -2. For purposes here it makes no difference.\\r\\n     *\\r\\n     * @param d real value to round\\r\\n     * @return nearest {@code int}\\r\\n     */\\r\\n    MathUtils.round = function (d /*float*/) {\\r\\n        if (NaN === d)\\r\\n            return 0;\\r\\n        if (d <= Number.MIN_SAFE_INTEGER)\\r\\n            return Number.MIN_SAFE_INTEGER;\\r\\n        if (d >= Number.MAX_SAFE_INTEGER)\\r\\n            return Number.MAX_SAFE_INTEGER;\\r\\n        return /*(int) */ (d + (d < 0.0 ? -0.5 : 0.5)) | 0;\\r\\n    };\\r\\n    // TYPESCRIPTPORT: maybe remove round method and call directly Math.round, it looks like it doesn't make sense for js\\r\\n    /**\\r\\n     * @param aX point A x coordinate\\r\\n     * @param aY point A y coordinate\\r\\n     * @param bX point B x coordinate\\r\\n     * @param bY point B y coordinate\\r\\n     * @return Euclidean distance between points A and B\\r\\n     */\\r\\n    MathUtils.distance = function (aX /*float|int*/, aY /*float|int*/, bX /*float|int*/, bY /*float|int*/) {\\r\\n        var xDiff = aX - bX;\\r\\n        var yDiff = aY - bY;\\r\\n        return /*(float) */ Math.sqrt(xDiff * xDiff + yDiff * yDiff);\\r\\n    };\\r\\n    /**\\r\\n     * @param aX point A x coordinate\\r\\n     * @param aY point A y coordinate\\r\\n     * @param bX point B x coordinate\\r\\n     * @param bY point B y coordinate\\r\\n     * @return Euclidean distance between points A and B\\r\\n     */\\r\\n    // public static distance(aX: number /*int*/, aY: number /*int*/, bX: number /*int*/, bY: number /*int*/): float {\\r\\n    //   const xDiff = aX - bX\\r\\n    //   const yDiff = aY - bY\\r\\n    //   return (float) Math.sqrt(xDiff * xDiff + yDiff * yDiff);\\r\\n    // }\\r\\n    /**\\r\\n     * @param array values to sum\\r\\n     * @return sum of values in array\\r\\n     */\\r\\n    MathUtils.sum = function (array) {\\r\\n        var count = 0;\\r\\n        for (var i = 0, length_1 = array.length; i !== length_1; i++) {\\r\\n            var a = array[i];\\r\\n            count += a;\\r\\n        }\\r\\n        return count;\\r\\n    };\\r\\n    return MathUtils;\\r\\n}());\\r\\nexports.default = MathUtils;\\r\\n\\n\\n//# sourceURL=webpack://OZSealRecognition/./src/core/common/detector/MathUtils.ts?\");\r\n\r\n                /***/ }),\r\n\r\n            /***/ \"./src/core/qrcode/detector/OZSealFinderPattern.ts\":\r\n            /*!*********************************************************!*\\\r\n              !*** ./src/core/qrcode/detector/OZSealFinderPattern.ts ***!\r\n              \\*********************************************************/\r\n            /*! no static exports found */\r\n            /*! ModuleConcatenation bailout: Module is not an ECMAScript module */\r\n            /***/ (function(module, exports, __webpack_require__) {\r\n\r\n                \"use strict\";\r\n                eval(\"\\r\\n/*\\r\\n * Copyright 2007 ZXing authors\\r\\n *\\r\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\r\\n * you may not use this file except in compliance with the License.\\r\\n * You may obtain a copy of the License at\\r\\n *\\r\\n *      http://www.apache.org/licenses/LICENSE-2.0\\r\\n *\\r\\n * Unless required by applicable law or agreed to in writing, software\\r\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\r\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\r\\n * See the License for the specific language governing permissions and\\r\\n * limitations under the License.\\r\\n */\\r\\nvar __extends = (this && this.__extends) || (function () {\\r\\n    var extendStatics = function (d, b) {\\r\\n        extendStatics = Object.setPrototypeOf ||\\r\\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\\r\\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\\r\\n        return extendStatics(d, b);\\r\\n    };\\r\\n    return function (d, b) {\\r\\n        extendStatics(d, b);\\r\\n        function __() { this.constructor = d; }\\r\\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\\r\\n    };\\r\\n})();\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\n/*namespace com.google.zxing.qrcode.detector {*/\\r\\nvar ResultPoint_1 = __webpack_require__(/*! ../../ResultPoint */ \\\"./src/core/ResultPoint.ts\\\");\\r\\n/**\\r\\n * <p>Encapsulates a finder pattern, which are the three square patterns found in\\r\\n * the corners of QR Codes. It also encapsulates a count of similar finder patterns,\\r\\n * as a convenience to the finder's bookkeeping.</p>\\r\\n *\\r\\n * @author Sean Owen\\r\\n */\\r\\nvar OZSealFinderPattern = /** @class */ (function (_super) {\\r\\n    __extends(OZSealFinderPattern, _super);\\r\\n    // OZSealFinderPattern(posX: number/*float*/, posY: number/*float*/, estimatedModuleSize: number/*float*/) {\\r\\n    //   this(posX, posY, estimatedModuleSize, 1)\\r\\n    // }\\r\\n    function OZSealFinderPattern(posX /*float*/, posY /*float*/, estimatedModuleSize /*float*/, count /*int*/) {\\r\\n        var _this = _super.call(this, posX, posY) || this;\\r\\n        _this.estimatedModuleSize = estimatedModuleSize;\\r\\n        _this.count = count;\\r\\n        if (undefined === count) {\\r\\n            _this.count = 1;\\r\\n        }\\r\\n        return _this;\\r\\n    }\\r\\n    OZSealFinderPattern.prototype.getEstimatedModuleSize = function () {\\r\\n        return this.estimatedModuleSize;\\r\\n    };\\r\\n    OZSealFinderPattern.prototype.getCount = function () {\\r\\n        return this.count;\\r\\n    };\\r\\n    /*\\r\\n    void incrementCount() {\\r\\n      this.count++\\r\\n    }\\r\\n     */\\r\\n    /**\\r\\n     * <p>Determines if this finder pattern \\\"about equals\\\" a finder pattern at the stated\\r\\n     * position and size -- meaning, it is at nearly the same center with nearly the same size.</p>\\r\\n     */\\r\\n    OZSealFinderPattern.prototype.aboutEquals = function (moduleSize /*float*/, i /*float*/, j /*float*/) {\\r\\n        if (Math.abs(i - this.getY()) <= moduleSize && Math.abs(j - this.getX()) <= moduleSize) {\\r\\n            var moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);\\r\\n            return moduleSizeDiff <= 1.0 || moduleSizeDiff <= this.estimatedModuleSize;\\r\\n        }\\r\\n        return false;\\r\\n    };\\r\\n    /**\\r\\n     * Combines this object's current estimate of a finder pattern position and module size\\r\\n     * with a new estimate. It returns a new {@code OZSealFinderPattern} containing a weighted average\\r\\n     * based on count.\\r\\n     */\\r\\n    OZSealFinderPattern.prototype.combineEstimate = function (i /*float*/, j /*float*/, newModuleSize /*float*/) {\\r\\n        var combinedCount = this.count + 1;\\r\\n        var combinedX = (this.count * this.getX() + j) / combinedCount;\\r\\n        var combinedY = (this.count * this.getY() + i) / combinedCount;\\r\\n        var combinedModuleSize = (this.count * this.estimatedModuleSize + newModuleSize) / combinedCount;\\r\\n        return new OZSealFinderPattern(combinedX, combinedY, combinedModuleSize, combinedCount);\\r\\n    };\\r\\n    return OZSealFinderPattern;\\r\\n}(ResultPoint_1.default));\\r\\nexports.default = OZSealFinderPattern;\\r\\n\\n\\n//# sourceURL=webpack://OZSealRecognition/./src/core/qrcode/detector/OZSealFinderPattern.ts?\");\r\n\r\n                /***/ }),\r\n\r\n            /***/ \"./src/core/qrcode/detector/OZSealFinderPatternFinder.ts\":\r\n            /*!***************************************************************!*\\\r\n              !*** ./src/core/qrcode/detector/OZSealFinderPatternFinder.ts ***!\r\n              \\***************************************************************/\r\n            /*! no static exports found */\r\n            /*! ModuleConcatenation bailout: Module is not an ECMAScript module */\r\n            /***/ (function(module, exports, __webpack_require__) {\r\n\r\n                \"use strict\";\r\n                eval(\"\\r\\n/*\\r\\n * Copyright 2007 ZXing authors\\r\\n *\\r\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\r\\n * you may not use this file except in compliance with the License.\\r\\n * You may obtain a copy of the License at\\r\\n *\\r\\n *      http://www.apache.org/licenses/LICENSE-2.0\\r\\n *\\r\\n * Unless required by applicable law or agreed to in writing, software\\r\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\r\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\r\\n * See the License for the specific language governing permissions and\\r\\n * limitations under the License.\\r\\n */\\r\\nvar __values = (this && this.__values) || function(o) {\\r\\n    var s = typeof Symbol === \\\"function\\\" && Symbol.iterator, m = s && o[s], i = 0;\\r\\n    if (m) return m.call(o);\\r\\n    if (o && typeof o.length === \\\"number\\\") return {\\r\\n        next: function () {\\r\\n            if (o && i >= o.length) o = void 0;\\r\\n            return { value: o && o[i++], done: !o };\\r\\n        }\\r\\n    };\\r\\n    throw new TypeError(s ? \\\"Object is not iterable.\\\" : \\\"Symbol.iterator is not defined.\\\");\\r\\n};\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\nvar OZSealFinderPattern_1 = __webpack_require__(/*! ./OZSealFinderPattern */ \\\"./src/core/qrcode/detector/OZSealFinderPattern.ts\\\");\\r\\nvar NotFoundException_1 = __webpack_require__(/*! ../../NotFoundException */ \\\"./src/core/NotFoundException.ts\\\");\\r\\n/*import java.io.Serializable;*/\\r\\n/*import java.util.ArrayList;*/\\r\\n/*import java.util.Collections;*/\\r\\n/*import java.util.Comparator;*/\\r\\n/*import java.util.List;*/\\r\\n/*import java.util.Map;*/\\r\\n/**\\r\\n * <p>This class attempts to find finder patterns in a QR Code. Finder patterns are the square\\r\\n * markers at three corners of a QR Code.</p>\\r\\n *\\r\\n * <p>This class is thread-safe but not reentrant. Each thread must allocate its own object.\\r\\n *\\r\\n * @author Sean Owen\\r\\n */\\r\\nvar OZSealFinderPatternFinder = /** @class */ (function () {\\r\\n    /**\\r\\n     * <p>Creates a finder that will search the image for three finder patterns.</p>\\r\\n     *\\r\\n     * @param image image to search\\r\\n     */\\r\\n    // public constructor(image: BitMatrix) {\\r\\n    //   this(image, null)\\r\\n    // }\\r\\n    function OZSealFinderPatternFinder(image) {\\r\\n        this.image = image;\\r\\n        this.possibleCenters = [];\\r\\n        this.crossCheckStateCount = new Int32Array(5);\\r\\n    }\\r\\n    OZSealFinderPatternFinder.prototype.getImage = function () {\\r\\n        return this.image;\\r\\n    };\\r\\n    OZSealFinderPatternFinder.prototype.getPossibleCenters = function () {\\r\\n        return this.possibleCenters;\\r\\n    };\\r\\n    OZSealFinderPatternFinder.prototype.find = function (patterns) {\\r\\n        var tryHarder = false;\\r\\n        var image = this.image;\\r\\n        var maxI = image.getHeight();\\r\\n        var maxJ = image.getWidth();\\r\\n        // We are looking for black/white/black/white/black modules in\\r\\n        // 1:1:3:1:1 ratio; this tracks the number of such modules seen so far\\r\\n        // Let's assume that the maximum version QR Code we support takes up 1/4 the height of the\\r\\n        // image, and then account for the center being 3 modules in size. This gives the smallest\\r\\n        // number of pixels the center could be, so skip this often. When trying harder, look for all\\r\\n        // QR versions regardless of how dense they are.\\r\\n        var iSkip = Math.floor((3 * maxI) / (4 * OZSealFinderPatternFinder.MAX_MODULES));\\r\\n        if (iSkip < OZSealFinderPatternFinder.MIN_SKIP || tryHarder) {\\r\\n            iSkip = OZSealFinderPatternFinder.MIN_SKIP;\\r\\n        }\\r\\n        var done = false;\\r\\n        var stateCount = new Int32Array(5);\\r\\n        for (var i = iSkip - 1; i < maxI && !done; i += iSkip) {\\r\\n            // Get a row of black/white values\\r\\n            stateCount[0] = 0;\\r\\n            stateCount[1] = 0;\\r\\n            stateCount[2] = 0;\\r\\n            stateCount[3] = 0;\\r\\n            stateCount[4] = 0;\\r\\n            var currentState = 0;\\r\\n            for (var j = 0; j < maxJ; j++) {\\r\\n                if (image.get(j, i)) {\\r\\n                    // Black pixel\\r\\n                    if ((currentState & 1) === 1) { // Counting white pixels\\r\\n                        currentState++;\\r\\n                    }\\r\\n                    stateCount[currentState]++;\\r\\n                }\\r\\n                else { // White pixel\\r\\n                    if ((currentState & 1) === 0) { // Counting black pixels\\r\\n                        if (currentState === 4) { // A winner?\\r\\n                            if (OZSealFinderPatternFinder.foundPatternCross(stateCount)) { // Yes\\r\\n                                var confirmed = this.handlePossibleCenter(stateCount, i, j);\\r\\n                                if (confirmed === true) {\\r\\n                                    // Start examining every other line. Checking each line turned out to be too\\r\\n                                    // expensive and didn't improve performance.\\r\\n                                    iSkip = 2;\\r\\n                                    if (this.hasSkipped === true) {\\r\\n                                        //done = this.haveMultiplyConfirmedCenters();\\r\\n                                    }\\r\\n                                    else {\\r\\n                                        //const rowSkip = this.findRowSkip();\\r\\n                                        //if (rowSkip > stateCount[2]) {\\r\\n                                        // Skip rows between row of lower confirmed center\\r\\n                                        // and top of presumed third confirmed center\\r\\n                                        // but back up a bit to get a full chance of detecting\\r\\n                                        // it, entire width of center of finder pattern\\r\\n                                        // Skip by rowSkip, but back off by stateCount[2] (size of last center\\r\\n                                        // of pattern we saw) to be conservative, and also back off by iSkip which\\r\\n                                        // is about to be re-added\\r\\n                                        //i += rowSkip - stateCount[2] - iSkip;\\r\\n                                        //j = maxJ - 1;\\r\\n                                        //}\\r\\n                                    }\\r\\n                                }\\r\\n                                else {\\r\\n                                    stateCount[0] = stateCount[2];\\r\\n                                    stateCount[1] = stateCount[3];\\r\\n                                    stateCount[2] = stateCount[4];\\r\\n                                    stateCount[3] = 1;\\r\\n                                    stateCount[4] = 0;\\r\\n                                    currentState = 3;\\r\\n                                    continue;\\r\\n                                }\\r\\n                                // Clear state to start looking again\\r\\n                                currentState = 0;\\r\\n                                stateCount[0] = 0;\\r\\n                                stateCount[1] = 0;\\r\\n                                stateCount[2] = 0;\\r\\n                                stateCount[3] = 0;\\r\\n                                stateCount[4] = 0;\\r\\n                            }\\r\\n                            else { // No, shift counts back by two\\r\\n                                stateCount[0] = stateCount[2];\\r\\n                                stateCount[1] = stateCount[3];\\r\\n                                stateCount[2] = stateCount[4];\\r\\n                                stateCount[3] = 1;\\r\\n                                stateCount[4] = 0;\\r\\n                                currentState = 3;\\r\\n                            }\\r\\n                        }\\r\\n                        else {\\r\\n                            stateCount[++currentState]++;\\r\\n                        }\\r\\n                    }\\r\\n                    else { // Counting white pixels\\r\\n                        stateCount[currentState]++;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            if (OZSealFinderPatternFinder.foundPatternCross(stateCount)) {\\r\\n                var confirmed = this.handlePossibleCenter(stateCount, i, maxJ);\\r\\n                if (confirmed === true) {\\r\\n                    iSkip = stateCount[0];\\r\\n                    if (this.hasSkipped) {\\r\\n                        // Found a third one\\r\\n                        //done = this.haveMultiplyConfirmedCenters();\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        if (this.possibleCenters.length > 0) {\\r\\n            for (var i = 0; i < this.possibleCenters.length; i++) {\\r\\n                patterns.push(this.possibleCenters[i]);\\r\\n            }\\r\\n        }\\r\\n        //const patternInfo: FinderPattern[] = this.selectBestPatterns();\\r\\n        //ResultPoint.orderBestPatterns(patternInfo);\\r\\n        return patterns.length > 0;\\r\\n    };\\r\\n    /**\\r\\n     * Given a count of black/white/black/white/black pixels just seen and an end position,\\r\\n     * figures the location of the center of this run.\\r\\n     */\\r\\n    OZSealFinderPatternFinder.centerFromEnd = function (stateCount, end /*int*/) {\\r\\n        return (end - stateCount[4] - stateCount[3]) - stateCount[2] / 2.0;\\r\\n    };\\r\\n    /**\\r\\n     * @param stateCount count of black/white/black/white/black pixels just read\\r\\n     * @return true iff the proportions of the counts is close enough to the 1/1/3/1/1 ratios\\r\\n     *         used by finder patterns to be considered a match\\r\\n     */\\r\\n    OZSealFinderPatternFinder.foundPatternCross = function (stateCount) {\\r\\n        var totalModuleSize = 0;\\r\\n        for (var i = 0; i < 5; i++) {\\r\\n            var count = stateCount[i];\\r\\n            if (count === 0) {\\r\\n                return false;\\r\\n            }\\r\\n            totalModuleSize += count;\\r\\n        }\\r\\n        if (totalModuleSize < 7) {\\r\\n            return false;\\r\\n        }\\r\\n        var moduleSize = totalModuleSize / 7.0;\\r\\n        var maxVariance = moduleSize / 2.0;\\r\\n        // Allow less than 50% variance from 1-1-3-1-1 proportions\\r\\n        return Math.abs(moduleSize - stateCount[0]) < maxVariance &&\\r\\n            Math.abs(moduleSize - stateCount[1]) < maxVariance &&\\r\\n            Math.abs(3.0 * moduleSize - stateCount[2]) < 3 * maxVariance &&\\r\\n            Math.abs(moduleSize - stateCount[3]) < maxVariance &&\\r\\n            Math.abs(moduleSize - stateCount[4]) < maxVariance;\\r\\n    };\\r\\n    OZSealFinderPatternFinder.prototype.getCrossCheckStateCount = function () {\\r\\n        var crossCheckStateCount = this.crossCheckStateCount;\\r\\n        crossCheckStateCount[0] = 0;\\r\\n        crossCheckStateCount[1] = 0;\\r\\n        crossCheckStateCount[2] = 0;\\r\\n        crossCheckStateCount[3] = 0;\\r\\n        crossCheckStateCount[4] = 0;\\r\\n        return crossCheckStateCount;\\r\\n    };\\r\\n    /**\\r\\n     * After a vertical and horizontal scan finds a potential finder pattern, this method\\r\\n     * \\\"cross-cross-cross-checks\\\" by scanning down diagonally through the center of the possible\\r\\n     * finder pattern to see if the same proportion is detected.\\r\\n     *\\r\\n     * @param startI row where a finder pattern was detected\\r\\n     * @param centerJ center of the section that appears to cross a finder pattern\\r\\n     * @param maxCount maximum reasonable number of modules that should be\\r\\n     *  observed in any reading state, based on the results of the horizontal scan\\r\\n     * @param originalStateCountTotal The original state count total.\\r\\n     * @return true if proportions are withing expected limits\\r\\n     */\\r\\n    OZSealFinderPatternFinder.prototype.crossCheckDiagonal = function (startI /*int*/, centerJ /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {\\r\\n        var stateCount = this.getCrossCheckStateCount();\\r\\n        // Start counting up, left from center finding black center mass\\r\\n        var i = 0;\\r\\n        var image = this.image;\\r\\n        while (startI >= i && centerJ >= i && image.get(centerJ - i, startI - i)) {\\r\\n            stateCount[2]++;\\r\\n            i++;\\r\\n        }\\r\\n        if (startI < i || centerJ < i) {\\r\\n            return false;\\r\\n        }\\r\\n        // Continue up, left finding white space\\r\\n        while (startI >= i && centerJ >= i && !image.get(centerJ - i, startI - i) &&\\r\\n            stateCount[1] <= maxCount) {\\r\\n            stateCount[1]++;\\r\\n            i++;\\r\\n        }\\r\\n        // If already too many modules in this state or ran off the edge:\\r\\n        if (startI < i || centerJ < i || stateCount[1] > maxCount) {\\r\\n            return false;\\r\\n        }\\r\\n        // Continue up, left finding black border\\r\\n        while (startI >= i && centerJ >= i && image.get(centerJ - i, startI - i) &&\\r\\n            stateCount[0] <= maxCount) {\\r\\n            stateCount[0]++;\\r\\n            i++;\\r\\n        }\\r\\n        if (stateCount[0] > maxCount) {\\r\\n            return false;\\r\\n        }\\r\\n        var maxI = image.getHeight();\\r\\n        var maxJ = image.getWidth();\\r\\n        // Now also count down, right from center\\r\\n        i = 1;\\r\\n        while (startI + i < maxI && centerJ + i < maxJ && image.get(centerJ + i, startI + i)) {\\r\\n            stateCount[2]++;\\r\\n            i++;\\r\\n        }\\r\\n        // Ran off the edge?\\r\\n        if (startI + i >= maxI || centerJ + i >= maxJ) {\\r\\n            return false;\\r\\n        }\\r\\n        while (startI + i < maxI && centerJ + i < maxJ && !image.get(centerJ + i, startI + i) &&\\r\\n            stateCount[3] < maxCount) {\\r\\n            stateCount[3]++;\\r\\n            i++;\\r\\n        }\\r\\n        if (startI + i >= maxI || centerJ + i >= maxJ || stateCount[3] >= maxCount) {\\r\\n            return false;\\r\\n        }\\r\\n        while (startI + i < maxI && centerJ + i < maxJ && image.get(centerJ + i, startI + i) &&\\r\\n            stateCount[4] < maxCount) {\\r\\n            stateCount[4]++;\\r\\n            i++;\\r\\n        }\\r\\n        if (stateCount[4] >= maxCount) {\\r\\n            return false;\\r\\n        }\\r\\n        // If we found a finder-pattern-like section, but its size is more than 100% different than\\r\\n        // the original, assume it's a false positive\\r\\n        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];\\r\\n        return Math.abs(stateCountTotal - originalStateCountTotal) < 2 * originalStateCountTotal &&\\r\\n            OZSealFinderPatternFinder.foundPatternCross(stateCount);\\r\\n    };\\r\\n    /**\\r\\n     * <p>After a horizontal scan finds a potential finder pattern, this method\\r\\n     * \\\"cross-checks\\\" by scanning down vertically through the center of the possible\\r\\n     * finder pattern to see if the same proportion is detected.</p>\\r\\n     *\\r\\n     * @param startI row where a finder pattern was detected\\r\\n     * @param centerJ center of the section that appears to cross a finder pattern\\r\\n     * @param maxCount maximum reasonable number of modules that should be\\r\\n     * observed in any reading state, based on the results of the horizontal scan\\r\\n     * @return vertical center of finder pattern, or {@link Float#NaN} if not found\\r\\n     */\\r\\n    OZSealFinderPatternFinder.prototype.crossCheckVertical = function (startI /*int*/, centerJ /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {\\r\\n        var image = this.image;\\r\\n        var maxI = image.getHeight();\\r\\n        var stateCount = this.getCrossCheckStateCount();\\r\\n        // Start counting up from center\\r\\n        var i = startI;\\r\\n        while (i >= 0 && image.get(centerJ, i)) {\\r\\n            stateCount[2]++;\\r\\n            i--;\\r\\n        }\\r\\n        if (i < 0) {\\r\\n            return NaN;\\r\\n        }\\r\\n        while (i >= 0 && !image.get(centerJ, i) && stateCount[1] <= maxCount) {\\r\\n            stateCount[1]++;\\r\\n            i--;\\r\\n        }\\r\\n        // If already too many modules in this state or ran off the edge:\\r\\n        if (i < 0 || stateCount[1] > maxCount) {\\r\\n            return NaN;\\r\\n        }\\r\\n        while (i >= 0 && image.get(centerJ, i) && stateCount[0] <= maxCount) {\\r\\n            stateCount[0]++;\\r\\n            i--;\\r\\n        }\\r\\n        if (stateCount[0] > maxCount) {\\r\\n            return NaN;\\r\\n        }\\r\\n        // Now also count down from center\\r\\n        i = startI + 1;\\r\\n        while (i < maxI && image.get(centerJ, i)) {\\r\\n            stateCount[2]++;\\r\\n            i++;\\r\\n        }\\r\\n        if (i === maxI) {\\r\\n            return NaN;\\r\\n        }\\r\\n        while (i < maxI && !image.get(centerJ, i) && stateCount[3] < maxCount) {\\r\\n            stateCount[3]++;\\r\\n            i++;\\r\\n        }\\r\\n        if (i === maxI || stateCount[3] >= maxCount) {\\r\\n            return NaN;\\r\\n        }\\r\\n        while (i < maxI && image.get(centerJ, i) && stateCount[4] < maxCount) {\\r\\n            stateCount[4]++;\\r\\n            i++;\\r\\n        }\\r\\n        if (stateCount[4] >= maxCount) {\\r\\n            return NaN;\\r\\n        }\\r\\n        // If we found a finder-pattern-like section, but its size is more than 40% different than\\r\\n        // the original, assume it's a false positive\\r\\n        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] +\\r\\n            stateCount[4];\\r\\n        if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {\\r\\n            return NaN;\\r\\n        }\\r\\n        return OZSealFinderPatternFinder.foundPatternCross(stateCount) ? OZSealFinderPatternFinder.centerFromEnd(stateCount, i) : NaN;\\r\\n    };\\r\\n    /**\\r\\n     * <p>Like {@link #crossCheckVertical(int, int, int, int)}, and in fact is basically identical,\\r\\n     * except it reads horizontally instead of vertically. This is used to cross-cross\\r\\n     * check a vertical cross check and locate the real center of the alignment pattern.</p>\\r\\n     */\\r\\n    OZSealFinderPatternFinder.prototype.crossCheckHorizontal = function (startJ /*int*/, centerI /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {\\r\\n        var image = this.image;\\r\\n        var maxJ = image.getWidth();\\r\\n        var stateCount = this.getCrossCheckStateCount();\\r\\n        var j = startJ;\\r\\n        while (j >= 0 && image.get(j, centerI)) {\\r\\n            stateCount[2]++;\\r\\n            j--;\\r\\n        }\\r\\n        if (j < 0) {\\r\\n            return NaN;\\r\\n        }\\r\\n        while (j >= 0 && !image.get(j, centerI) && stateCount[1] <= maxCount) {\\r\\n            stateCount[1]++;\\r\\n            j--;\\r\\n        }\\r\\n        if (j < 0 || stateCount[1] > maxCount) {\\r\\n            return NaN;\\r\\n        }\\r\\n        while (j >= 0 && image.get(j, centerI) && stateCount[0] <= maxCount) {\\r\\n            stateCount[0]++;\\r\\n            j--;\\r\\n        }\\r\\n        if (stateCount[0] > maxCount) {\\r\\n            return NaN;\\r\\n        }\\r\\n        j = startJ + 1;\\r\\n        while (j < maxJ && image.get(j, centerI)) {\\r\\n            stateCount[2]++;\\r\\n            j++;\\r\\n        }\\r\\n        if (j === maxJ) {\\r\\n            return NaN;\\r\\n        }\\r\\n        while (j < maxJ && !image.get(j, centerI) && stateCount[3] < maxCount) {\\r\\n            stateCount[3]++;\\r\\n            j++;\\r\\n        }\\r\\n        if (j === maxJ || stateCount[3] >= maxCount) {\\r\\n            return NaN;\\r\\n        }\\r\\n        while (j < maxJ && image.get(j, centerI) && stateCount[4] < maxCount) {\\r\\n            stateCount[4]++;\\r\\n            j++;\\r\\n        }\\r\\n        if (stateCount[4] >= maxCount) {\\r\\n            return NaN;\\r\\n        }\\r\\n        // If we found a finder-pattern-like section, but its size is significantly different than\\r\\n        // the original, assume it's a false positive\\r\\n        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] +\\r\\n            stateCount[4];\\r\\n        if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= originalStateCountTotal) {\\r\\n            return NaN;\\r\\n        }\\r\\n        return OZSealFinderPatternFinder.foundPatternCross(stateCount) ? OZSealFinderPatternFinder.centerFromEnd(stateCount, j) : NaN;\\r\\n    };\\r\\n    /**\\r\\n     * <p>This is called when a horizontal scan finds a possible alignment pattern. It will\\r\\n     * cross check with a vertical scan, and if successful, will, ah, cross-cross-check\\r\\n     * with another horizontal scan. This is needed primarily to locate the real horizontal\\r\\n     * center of the pattern in cases of extreme skew.\\r\\n     * And then we cross-cross-cross check with another diagonal scan.</p>\\r\\n     *\\r\\n     * <p>If that succeeds the finder pattern location is added to a list that tracks\\r\\n     * the number of times each location has been nearly-matched as a finder pattern.\\r\\n     * Each additional find is more evidence that the location is in fact a finder\\r\\n     * pattern center\\r\\n     *\\r\\n     * @param stateCount reading state module counts from horizontal scan\\r\\n     * @param i row where finder pattern may be found\\r\\n     * @param j end of possible finder pattern in row\\r\\n     * @param pureBarcode true if in \\\"pure barcode\\\" mode\\r\\n     * @return true if a finder pattern candidate was found this time\\r\\n     */\\r\\n    OZSealFinderPatternFinder.prototype.handlePossibleCenter = function (stateCount, i /*int*/, j /*int*/) {\\r\\n        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] +\\r\\n            stateCount[4];\\r\\n        var centerJ = OZSealFinderPatternFinder.centerFromEnd(stateCount, j);\\r\\n        var centerI = this.crossCheckVertical(i, /*(int) */ Math.floor(centerJ), stateCount[2], stateCountTotal);\\r\\n        if (!isNaN(centerI)) {\\r\\n            // Re-cross check\\r\\n            centerJ = this.crossCheckHorizontal(/*(int) */ Math.floor(centerJ), /*(int) */ Math.floor(centerI), stateCount[2], stateCountTotal);\\r\\n            if (!isNaN(centerJ) &&\\r\\n                (this.crossCheckDiagonal(/*(int) */ Math.floor(centerI), /*(int) */ Math.floor(centerJ), stateCount[2], stateCountTotal))) {\\r\\n                var estimatedModuleSize = stateCountTotal / 7.0;\\r\\n                var found = false;\\r\\n                var possibleCenters = this.possibleCenters;\\r\\n                for (var index = 0, length_1 = possibleCenters.length; index < length_1; index++) {\\r\\n                    var center = possibleCenters[index];\\r\\n                    // Look for about the same center and module size:\\r\\n                    if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {\\r\\n                        possibleCenters[index] = center.combineEstimate(centerI, centerJ, estimatedModuleSize);\\r\\n                        found = true;\\r\\n                        break;\\r\\n                    }\\r\\n                }\\r\\n                if (!found) {\\r\\n                    var point = new OZSealFinderPattern_1.default(centerJ, centerI, estimatedModuleSize);\\r\\n                    possibleCenters.push(point);\\r\\n                }\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    };\\r\\n    /**\\r\\n     * @return number of rows we could safely skip during scanning, based on the first\\r\\n     *         two finder patterns that have been located. In some cases their position will\\r\\n     *         allow us to infer that the third pattern must lie below a certain point farther\\r\\n     *         down in the image.\\r\\n     */\\r\\n    OZSealFinderPatternFinder.prototype.findRowSkip = function () {\\r\\n        var e_1, _a;\\r\\n        var max = this.possibleCenters.length;\\r\\n        if (max <= 1) {\\r\\n            return 0;\\r\\n        }\\r\\n        var firstConfirmedCenter = null;\\r\\n        try {\\r\\n            for (var _b = __values(this.possibleCenters), _c = _b.next(); !_c.done; _c = _b.next()) {\\r\\n                var center = _c.value;\\r\\n                if (center.getCount() >= OZSealFinderPatternFinder.CENTER_QUORUM) {\\r\\n                    if (firstConfirmedCenter == null) {\\r\\n                        firstConfirmedCenter = center;\\r\\n                    }\\r\\n                    else {\\r\\n                        // We have two confirmed centers\\r\\n                        // How far down can we skip before resuming looking for the next\\r\\n                        // pattern? In the worst case, only the difference between the\\r\\n                        // difference in the x / y coordinates of the two centers.\\r\\n                        // This is the case where you find top left last.\\r\\n                        this.hasSkipped = true;\\r\\n                        return /*(int) */ Math.floor((Math.abs(firstConfirmedCenter.getX() - center.getX()) -\\r\\n                            Math.abs(firstConfirmedCenter.getY() - center.getY())) / 2);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\\r\\n        finally {\\r\\n            try {\\r\\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\\r\\n            }\\r\\n            finally { if (e_1) throw e_1.error; }\\r\\n        }\\r\\n        return 0;\\r\\n    };\\r\\n    /**\\r\\n     * @return true iff we have found at least 3 finder patterns that have been detected\\r\\n     *         at least {@link #CENTER_QUORUM} times each, and, the estimated module size of the\\r\\n     *         candidates is \\\"pretty similar\\\"\\r\\n     */\\r\\n    OZSealFinderPatternFinder.prototype.haveMultiplyConfirmedCenters = function () {\\r\\n        var e_2, _a, e_3, _b;\\r\\n        var confirmedCount = 0;\\r\\n        var totalModuleSize = 0.0;\\r\\n        var max = this.possibleCenters.length;\\r\\n        try {\\r\\n            for (var _c = __values(this.possibleCenters), _d = _c.next(); !_d.done; _d = _c.next()) {\\r\\n                var pattern = _d.value;\\r\\n                if (pattern.getCount() >= OZSealFinderPatternFinder.CENTER_QUORUM) {\\r\\n                    confirmedCount++;\\r\\n                    totalModuleSize += pattern.getEstimatedModuleSize();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\\r\\n        finally {\\r\\n            try {\\r\\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\\r\\n            }\\r\\n            finally { if (e_2) throw e_2.error; }\\r\\n        }\\r\\n        if (confirmedCount < 3) {\\r\\n            return false;\\r\\n        }\\r\\n        // OK, we have at least 3 confirmed centers, but, it's possible that one is a \\\"false positive\\\"\\r\\n        // and that we need to keep looking. We detect this by asking if the estimated module sizes\\r\\n        // vary too much. We arbitrarily say that when the total deviation from average exceeds\\r\\n        // 5% of the total module size estimates, it's too much.\\r\\n        var average = totalModuleSize / max;\\r\\n        var totalDeviation = 0.0;\\r\\n        try {\\r\\n            for (var _e = __values(this.possibleCenters), _f = _e.next(); !_f.done; _f = _e.next()) {\\r\\n                var pattern = _f.value;\\r\\n                totalDeviation += Math.abs(pattern.getEstimatedModuleSize() - average);\\r\\n            }\\r\\n        }\\r\\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\\r\\n        finally {\\r\\n            try {\\r\\n                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\\r\\n            }\\r\\n            finally { if (e_3) throw e_3.error; }\\r\\n        }\\r\\n        return totalDeviation <= 0.05 * totalModuleSize;\\r\\n    };\\r\\n    /**\\r\\n     * @return the 3 best {@link FinderPattern}s from our list of candidates. The \\\"best\\\" are\\r\\n     *         those that have been detected at least {@link #CENTER_QUORUM} times, and whose module\\r\\n     *         size differs from the average among those patterns the least\\r\\n     * @throws NotFoundException if 3 such finder patterns do not exist\\r\\n     */\\r\\n    OZSealFinderPatternFinder.prototype.selectBestPatterns = function () {\\r\\n        var e_4, _a, e_5, _b;\\r\\n        var startSize = this.possibleCenters.length;\\r\\n        if (startSize < 3) {\\r\\n            // Couldn't find enough finder patterns\\r\\n            throw new NotFoundException_1.default();\\r\\n        }\\r\\n        var possibleCenters = this.possibleCenters;\\r\\n        var average;\\r\\n        // Filter outlier possibilities whose module size is too different\\r\\n        if (startSize > 3) {\\r\\n            // But we can only afford to do so if we have at least 4 possibilities to choose from\\r\\n            var totalModuleSize = 0.0;\\r\\n            var square = 0.0;\\r\\n            try {\\r\\n                for (var _c = __values(this.possibleCenters), _d = _c.next(); !_d.done; _d = _c.next()) {\\r\\n                    var center = _d.value;\\r\\n                    var size = center.getEstimatedModuleSize();\\r\\n                    totalModuleSize += size;\\r\\n                    square += size * size;\\r\\n                }\\r\\n            }\\r\\n            catch (e_4_1) { e_4 = { error: e_4_1 }; }\\r\\n            finally {\\r\\n                try {\\r\\n                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\\r\\n                }\\r\\n                finally { if (e_4) throw e_4.error; }\\r\\n            }\\r\\n            average = totalModuleSize / startSize;\\r\\n            var stdDev = Math.sqrt(square / startSize - average * average);\\r\\n            possibleCenters.sort(\\r\\n            /**\\r\\n             * <p>Orders by furthest from average</p>\\r\\n             */\\r\\n            // FurthestFromAverageComparator implements Comparator<FinderPattern>\\r\\n            function (center1, center2) {\\r\\n                var dA = Math.abs(center2.getEstimatedModuleSize() - average);\\r\\n                var dB = Math.abs(center1.getEstimatedModuleSize() - average);\\r\\n                return dA < dB ? -1 : dA > dB ? 1 : 0;\\r\\n            });\\r\\n            var limit = Math.max(0.2 * average, stdDev);\\r\\n            for (var i = 0; i < possibleCenters.length && possibleCenters.length > 3; i++) {\\r\\n                var pattern = possibleCenters[i];\\r\\n                if (Math.abs(pattern.getEstimatedModuleSize() - average) > limit) {\\r\\n                    possibleCenters.splice(i, 1);\\r\\n                    i--;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        if (possibleCenters.length > 3) {\\r\\n            // Throw away all but those first size candidate points we found.\\r\\n            var totalModuleSize = 0.0;\\r\\n            try {\\r\\n                for (var possibleCenters_1 = __values(possibleCenters), possibleCenters_1_1 = possibleCenters_1.next(); !possibleCenters_1_1.done; possibleCenters_1_1 = possibleCenters_1.next()) {\\r\\n                    var possibleCenter = possibleCenters_1_1.value;\\r\\n                    totalModuleSize += possibleCenter.getEstimatedModuleSize();\\r\\n                }\\r\\n            }\\r\\n            catch (e_5_1) { e_5 = { error: e_5_1 }; }\\r\\n            finally {\\r\\n                try {\\r\\n                    if (possibleCenters_1_1 && !possibleCenters_1_1.done && (_b = possibleCenters_1.return)) _b.call(possibleCenters_1);\\r\\n                }\\r\\n                finally { if (e_5) throw e_5.error; }\\r\\n            }\\r\\n            average = totalModuleSize / possibleCenters.length;\\r\\n            possibleCenters.sort(\\r\\n            /**\\r\\n             * <p>Orders by {@link FinderPattern#getCount()}, descending.</p>\\r\\n             */\\r\\n            // CenterComparator implements Comparator<FinderPattern>\\r\\n            function (center1, center2) {\\r\\n                if (center2.getCount() === center1.getCount()) {\\r\\n                    var dA = Math.abs(center2.getEstimatedModuleSize() - average);\\r\\n                    var dB = Math.abs(center1.getEstimatedModuleSize() - average);\\r\\n                    return dA < dB ? 1 : dA > dB ? -1 : 0;\\r\\n                }\\r\\n                else {\\r\\n                    return center2.getCount() - center1.getCount();\\r\\n                }\\r\\n            });\\r\\n            possibleCenters.splice(3); // this is not realy necessary as we only return first 3 anyway\\r\\n        }\\r\\n        return [\\r\\n            possibleCenters[0],\\r\\n            possibleCenters[1],\\r\\n            possibleCenters[2]\\r\\n        ];\\r\\n    };\\r\\n    OZSealFinderPatternFinder.CENTER_QUORUM = 2;\\r\\n    OZSealFinderPatternFinder.MIN_SKIP = 3; // 1 pixel/module times 3 modules/center\\r\\n    OZSealFinderPatternFinder.MAX_MODULES = 57; // support up to version 10 for mobile clients\\r\\n    return OZSealFinderPatternFinder;\\r\\n}());\\r\\nexports.default = OZSealFinderPatternFinder;\\r\\n\\n\\n//# sourceURL=webpack://OZSealRecognition/./src/core/qrcode/detector/OZSealFinderPatternFinder.ts?\");\r\n\r\n                /***/ }),\r\n\r\n            /***/ \"./src/core/util/Float.ts\":\r\n            /*!********************************!*\\\r\n              !*** ./src/core/util/Float.ts ***!\r\n              \\********************************/\r\n            /*! no static exports found */\r\n            /*! ModuleConcatenation bailout: Module is not an ECMAScript module */\r\n            /***/ (function(module, exports, __webpack_require__) {\r\n\r\n                \"use strict\";\r\n                eval(\"\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\n/**\\r\\n * Ponyfill for Java's Float class.\\r\\n */\\r\\nvar Float = /** @class */ (function () {\\r\\n    function Float() {\\r\\n    }\\r\\n    /**\\r\\n     * SincTS has no difference between int and float, there's all numbers,\\r\\n     * this is used only to polyfill Java code.\\r\\n     */\\r\\n    Float.floatToIntBits = function (f) {\\r\\n        return f;\\r\\n    };\\r\\n    /**\\r\\n     * The float max value in JS is the number max value.\\r\\n     */\\r\\n    Float.MAX_VALUE = Number.MAX_SAFE_INTEGER;\\r\\n    return Float;\\r\\n}());\\r\\nexports.default = Float;\\r\\n\\n\\n//# sourceURL=webpack://OZSealRecognition/./src/core/util/Float.ts?\");\r\n\r\n                /***/ }),\r\n\r\n            /***/ \"./src/core/util/StringEncoding.ts\":\r\n            /*!*****************************************!*\\\r\n              !*** ./src/core/util/StringEncoding.ts ***!\r\n              \\*****************************************/\r\n            /*! no static exports found */\r\n            /*! ModuleConcatenation bailout: Module is not an ECMAScript module */\r\n            /***/ (function(module, exports, __webpack_require__) {\r\n\r\n                \"use strict\";\r\n                eval(\"\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\nvar UnsupportedOperationException_1 = __webpack_require__(/*! ../UnsupportedOperationException */ \\\"./src/core/UnsupportedOperationException.ts\\\");\\r\\nvar CharacterSetECI_1 = __webpack_require__(/*! ../common/CharacterSetECI */ \\\"./src/core/common/CharacterSetECI.ts\\\");\\r\\n/**\\r\\n * Responsible for en/decoding strings.\\r\\n */\\r\\nvar StringEncoding = /** @class */ (function () {\\r\\n    function StringEncoding() {\\r\\n    }\\r\\n    /**\\r\\n     * Decodes some Uint8Array to a string format.\\r\\n     */\\r\\n    StringEncoding.decode = function (bytes, encoding) {\\r\\n        var encodingName = this.encodingName(encoding);\\r\\n        if (this.customDecoder) {\\r\\n            return this.customDecoder(bytes, encodingName);\\r\\n        }\\r\\n        // Increases browser support.\\r\\n        if (typeof TextDecoder === 'undefined' || this.shouldDecodeOnFallback(encodingName)) {\\r\\n            return this.decodeFallback(bytes, encodingName);\\r\\n        }\\r\\n        return new TextDecoder(encodingName).decode(bytes);\\r\\n    };\\r\\n    /**\\r\\n     * Checks if the decoding method should use the fallback for decoding\\r\\n     * once Node TextDecoder doesn't support all encoding formats.\\r\\n     *\\r\\n     * @param encodingName\\r\\n     */\\r\\n    StringEncoding.shouldDecodeOnFallback = function (encodingName) {\\r\\n        return !StringEncoding.isBrowser() && encodingName === 'ISO-8859-1';\\r\\n    };\\r\\n    /**\\r\\n     * Encodes some string into a Uint8Array.\\r\\n     */\\r\\n    StringEncoding.encode = function (s, encoding) {\\r\\n        var encodingName = this.encodingName(encoding);\\r\\n        if (this.customEncoder) {\\r\\n            return this.customEncoder(s, encodingName);\\r\\n        }\\r\\n        // Increases browser support.\\r\\n        if (typeof TextEncoder === 'undefined') {\\r\\n            return this.encodeFallback(s);\\r\\n        }\\r\\n        // TextEncoder only encodes to UTF8 by default as specified by encoding.spec.whatwg.org\\r\\n        return new TextEncoder().encode(s);\\r\\n    };\\r\\n    StringEncoding.isBrowser = function () {\\r\\n        return (typeof window !== 'undefined' && {}.toString.call(window) === '[object Window]');\\r\\n    };\\r\\n    /**\\r\\n     * Returns the string value from some encoding character set.\\r\\n     */\\r\\n    StringEncoding.encodingName = function (encoding) {\\r\\n        return typeof encoding === 'string'\\r\\n            ? encoding\\r\\n            : encoding.getName();\\r\\n    };\\r\\n    /**\\r\\n     * Returns character set from some encoding character set.\\r\\n     */\\r\\n    StringEncoding.encodingCharacterSet = function (encoding) {\\r\\n        if (encoding instanceof CharacterSetECI_1.default) {\\r\\n            return encoding;\\r\\n        }\\r\\n        return CharacterSetECI_1.default.getCharacterSetECIByName(encoding);\\r\\n    };\\r\\n    /**\\r\\n     * Runs a fallback for the native decoding funcion.\\r\\n     */\\r\\n    StringEncoding.decodeFallback = function (bytes, encoding) {\\r\\n        var characterSet = this.encodingCharacterSet(encoding);\\r\\n        if (StringEncoding.isDecodeFallbackSupported(characterSet)) {\\r\\n            var s = '';\\r\\n            for (var i = 0, length_1 = bytes.length; i < length_1; i++) {\\r\\n                var h = bytes[i].toString(16);\\r\\n                if (h.length < 2) {\\r\\n                    h = '0' + h;\\r\\n                }\\r\\n                s += '%' + h;\\r\\n            }\\r\\n            return decodeURIComponent(s);\\r\\n        }\\r\\n        if (characterSet.equals(CharacterSetECI_1.default.UnicodeBigUnmarked)) {\\r\\n            return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));\\r\\n        }\\r\\n        throw new UnsupportedOperationException_1.default(\\\"Encoding \\\" + this.encodingName(encoding) + \\\" not supported by fallback.\\\");\\r\\n    };\\r\\n    StringEncoding.isDecodeFallbackSupported = function (characterSet) {\\r\\n        return characterSet.equals(CharacterSetECI_1.default.UTF8) ||\\r\\n            characterSet.equals(CharacterSetECI_1.default.ISO8859_1) ||\\r\\n            characterSet.equals(CharacterSetECI_1.default.ASCII);\\r\\n    };\\r\\n    /**\\r\\n     * Runs a fallback for the native encoding funcion.\\r\\n     *\\r\\n     * @see https://stackoverflow.com/a/17192845/4367683\\r\\n     */\\r\\n    StringEncoding.encodeFallback = function (s) {\\r\\n        var encodedURIstring = btoa(unescape(encodeURIComponent(s)));\\r\\n        var charList = encodedURIstring.split('');\\r\\n        var uintArray = [];\\r\\n        for (var i = 0; i < charList.length; i++) {\\r\\n            uintArray.push(charList[i].charCodeAt(0));\\r\\n        }\\r\\n        return new Uint8Array(uintArray);\\r\\n    };\\r\\n    return StringEncoding;\\r\\n}());\\r\\nexports.default = StringEncoding;\\r\\n\\n\\n//# sourceURL=webpack://OZSealRecognition/./src/core/util/StringEncoding.ts?\");\r\n\r\n                /***/ }),\r\n\r\n            /***/ \"./src/index.ts\":\r\n            /*!**********************!*\\\r\n              !*** ./src/index.ts ***!\r\n              \\**********************/\r\n            /*! no static exports found */\r\n            /*! ModuleConcatenation bailout: Module is not an ECMAScript module */\r\n            /***/ (function(module, exports, __webpack_require__) {\r\n\r\n                \"use strict\";\r\n                eval(\"\\r\\n//export * from './browser';\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\n//// Exceptions\\r\\n//export { default as ArgumentException } from './core/ArgumentException';\\r\\n//export { default as ArithmeticException } from './core/ArithmeticException';\\r\\n//export { default as ChecksumException } from './core/ChecksumException';\\r\\n//export { default as Exception } from './core/Exception';\\r\\n//export { default as FormatException } from './core/FormatException';\\r\\n//export { default as IllegalArgumentException } from './core/IllegalArgumentException';\\r\\n//export { default as IllegalStateException } from './core/IllegalStateException';\\r\\n//export { default as NotFoundException } from './core/NotFoundException';\\r\\n//export { default as ReaderException } from './core/ReaderException';\\r\\n//export { default as ReedSolomonException } from './core/ReedSolomonException';\\r\\n//export { default as UnsupportedOperationException } from './core/UnsupportedOperationException';\\r\\n//export { default as WriterException } from './core/WriterException';\\r\\n//// core\\r\\n//export { default as BarcodeFormat } from './core/BarcodeFormat';\\r\\n//export { default as Binarizer } from './core/Binarizer';\\r\\n//export { default as BinaryBitmap } from './core/BinaryBitmap';\\r\\n//export { default as DecodeHintType } from './core/DecodeHintType';\\r\\n//export { default as InvertedLuminanceSource } from './core/InvertedLuminanceSource';\\r\\n//export { default as LuminanceSource } from './core/LuminanceSource';\\r\\n//export { default as MultiFormatReader } from './core/MultiFormatReader';\\r\\n//export { default as MultiFormatWriter } from './core/MultiFormatWriter';\\r\\n//export { default as PlanarYUVLuminanceSource } from './core/PlanarYUVLuminanceSource';\\r\\n//export { default as Reader } from './core/Reader';\\r\\n//export { default as Result } from './core/Result';\\r\\n//export { default as ResultMetadataType } from './core/ResultMetadataType';\\r\\n//export { default as ResultPointCallback } from './core/ResultPointCallback';\\r\\n//export { default as RGBLuminanceSource } from './core/RGBLuminanceSource';\\r\\n//export { default as Writer } from './core/Writer';\\r\\n//// core/common\\r\\n//export { default as BitArray } from './core/common/BitArray';\\r\\n//export { default as BitMatrix } from './core/common/BitMatrix';\\r\\n//export { default as BitSource } from './core/common/BitSource';\\r\\n//export { default as CharacterSetECI } from './core/common/CharacterSetECI';\\r\\n//export { default as DecoderResult } from './core/common/DecoderResult';\\r\\n//export { default as DefaultGridSampler } from './core/common/DefaultGridSampler';\\r\\n//export { default as DetectorResult } from './core/common/DetectorResult';\\r\\n//export { default as EncodeHintType } from './core/EncodeHintType';\\r\\n//export { default as GlobalHistogramBinarizer } from './core/common/GlobalHistogramBinarizer';\\r\\n//export { default as GridSampler } from './core/common/GridSampler';\\r\\n//export { default as GridSamplerInstance } from './core/common/GridSamplerInstance';\\r\\n//export { default as HybridBinarizer } from './core/common/HybridBinarizer';\\r\\n//export { default as PerspectiveTransform } from './core/common/PerspectiveTransform';\\r\\n//export { default as StringUtils } from './core/common/StringUtils';\\r\\n//// core/common/detector\\r\\n//export { default as MathUtils } from './core/common/detector/MathUtils';\\r\\n//// export { default as MonochromeRectangleDetector } from './core/common/detector/MonochromeRectangleDetector';\\r\\n//export { default as WhiteRectangleDetector } from './core/common/detector/WhiteRectangleDetector';\\r\\n//// core/common/reedsolomon\\r\\n//export { default as GenericGF } from './core/common/reedsolomon/GenericGF';\\r\\n//export { default as GenericGFPoly } from './core/common/reedsolomon/GenericGFPoly';\\r\\n//export { default as ReedSolomonDecoder } from './core/common/reedsolomon/ReedSolomonDecoder';\\r\\n//export { default as ReedSolomonEncoder } from './core/common/reedsolomon/ReedSolomonEncoder';\\r\\n//// core/datamatrix\\r\\n//export { default as DataMatrixReader } from './core/datamatrix/DataMatrixReader';\\r\\n//// core/twod/qrcode\\r\\n//export { default as QRCodeReader } from './core/qrcode/QRCodeReader';\\r\\n//export { default as QRCodeWriter } from './core/qrcode/QRCodeWriter';\\r\\n//export { default as QRCodeDecoderErrorCorrectionLevel } from './core/qrcode/decoder/ErrorCorrectionLevel';\\r\\n//export { default as QRCodeEncoder } from './core/qrcode/encoder/Encoder';\\r\\n//export { default as QRCodeEncoderQRCode } from './core/qrcode/encoder/QRCode';\\r\\n//// core/twod/aztec\\r\\n//export { default as AztecCodeReader } from './core/aztec/AztecReader';\\r\\n//// core/oned\\r\\n//export { default as OneDReader } from './core/oned/OneDReader';\\r\\n//export { default as EAN13Reader } from './core/oned/EAN13Reader';\\r\\n//export { default as Code128Reader } from './core/oned/Code128Reader';\\r\\n//export { default as ITFReader } from './core/oned/ITFReader';\\r\\n//export { default as Code39Reader } from './core/oned/Code39Reader';\\r\\n//export { default as RSS14Reader } from './core/oned/rss/RSS14Reader';\\r\\n//export { default as RSSExpandedReader } from './core/oned/rss/expanded/RSSExpandedReader';\\r\\n//export { default as MultiformatReader } from './core/oned/MultiFormatOneDReader';\\r\\n// OZ_Seal_Recognition\\r\\nvar OZSealFinderPatternFinder_1 = __webpack_require__(/*! ./core/qrcode/detector/OZSealFinderPatternFinder */ \\\"./src/core/qrcode/detector/OZSealFinderPatternFinder.ts\\\");\\r\\nObject.defineProperty(exports, \\\"OZSealFinderPatternFinder\\\", { enumerable: true, get: function () { return OZSealFinderPatternFinder_1.default; } });\\r\\nvar StringUtils_1 = __webpack_require__(/*! ./core/common/StringUtils */ \\\"./src/core/common/StringUtils.ts\\\");\\r\\nObject.defineProperty(exports, \\\"StringUtils\\\", { enumerable: true, get: function () { return StringUtils_1.default; } });\\r\\n// OZ_Seal_Recognition_ZXing 제외한 버전\\r\\n//export { default as OZSealFinderPattern } from './core/qrcode/detector/OZSealFinderPattern';\\r\\n//export { default as BinaryBitmap } from './core/BinaryBitmap';\\r\\n//export { default as DecodeHintType } from './core/DecodeHintType';\\r\\n//export { default as Result } from './core/Result';\\r\\n//export { default as BarcodeFormat } from './core/BarcodeFormat';\\r\\n//export { default as Code128Reader } from './core/oned/Code128Reader';\\r\\n//export { default as InvertedLuminanceSource } from './core/InvertedLuminanceSource';\\r\\n//export { default as LuminanceSource } from './core/LuminanceSource';\\r\\n//export { default as IllegalArgumentException } from './core/IllegalArgumentException';\\r\\n//export { default as BitMatrix } from './core/common/BitMatrix';\\r\\n//export { default as NotFoundException } from './core/NotFoundException';\\r\\n//export { default as Binarizer } from './core/Binarizer';\\r\\n//export { default as BitArray } from './core/common/BitArray';\\r\\n//export { default as ResultMetadataType } from './core/ResultMetadataType';\\r\\n//export { default as Reader } from './core/Reader';\\r\\n//export { default as OneDReader } from './core/oned/OneDReader';\\r\\n//export { default as FormatException } from './core/FormatException';\\r\\n//export { default as ChecksumException } from './core/ChecksumException';\\r\\n//export { default as UnsupportedOperationException } from './core/UnsupportedOperationException';\\r\\n//export { default as Exception } from './core/Exception';\\r\\n//export { default as CharacterSetECI } from './core/common/CharacterSetECI';\\r\\n//export { default as HybridBinarizer } from './core/common/HybridBinarizer';\\r\\n\\n\\n//# sourceURL=webpack://OZSealRecognition/./src/index.ts?\");\r\n\r\n                /***/ }),\r\n\r\n            /***/ 0:\r\n            /*!****************************!*\\\r\n              !*** multi ./src/index.ts ***!\r\n              \\****************************/\r\n            /*! no static exports found */\r\n            /*! ModuleConcatenation bailout: Module is not an ECMAScript module */\r\n            /***/ (function(module, exports, __webpack_require__) {\r\n\r\n                eval(\"module.exports = __webpack_require__(/*! ./src/index.ts */\\\"./src/index.ts\\\");\\n\\n\\n//# sourceURL=webpack://OZSealRecognition/multi_./src/index.ts?\");\r\n\r\n                /***/ })\r\n\r\n            /******/ });\r\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvT1pTZWFsUmVjb2duaXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxPQUFPLElBQXlEO0FBQ2hFO0FBQ0EsU0FBUyxFQUtxQztBQUM5QyxDQUFDO0FBQ0QseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhCQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRiw4QkFBbUI7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsOEJBQW1CO0FBQ3JDO0FBQ0E7QUFDQSxrQkFBa0IsOEJBQW1CO0FBQ3JDO0FBQ0E7QUFDQSxrQkFBa0IsOEJBQW1CO0FBQ3JDLDJCQUEyQiw4QkFBbUI7QUFDOUMsbUVBQW1FLCtCQUErQjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4QkFBbUI7QUFDckM7QUFDQSxpRkFBaUYsaUJBQWlCO0FBQ2xHO0FBQ0Esc0VBQXNFLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsOEJBQW1CO0FBQ3JDLDRDQUE0Qyw4QkFBbUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhCQUFtQjtBQUMxQyw4REFBOEQsZ0NBQWdDO0FBQzlGLHNGQUFzRiw4QkFBbUIsNEJBQTRCLG9CQUFvQjtBQUN6SjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4QkFBbUI7QUFDckM7QUFDQSxvREFBb0QsNEJBQTRCO0FBQ2hGLDBEQUEwRDtBQUMxRCx1QkFBdUIsOEJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDhCQUFtQixrQ0FBa0M7QUFDdkU7QUFDQTtBQUNBLGtCQUFrQiw4QkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDhCQUFtQixDQUFDLDhCQUFtQjtBQUNoRSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLDBHQUEwRyxxQkFBcUIsRUFBRSxpSEFBaUgsNEJBQTRCLEVBQUUsd0NBQXdDLCtDQUErQyxzRkFBc0YsR0FBRyxpQ0FBaUMsd0JBQXdCLDhCQUE4QixLQUFLLHNEQUFzRCx1REFBdUQsR0FBRyxxRUFBcUUsdURBQXVELGlEQUFpRCw2QkFBNkIscUNBQXFDLHdCQUF3QixRQUFRLG9CQUFvQiwwQkFBMEIsc0VBQXNFLFNBQVMsUUFBUSxvQ0FBb0MsTUFBTSw4QkFBOEIsaUpBQWlKLDZCQUE2Qix1QkFBdUIsNkJBQTZCLE9BQU8sNkZBQTZGLE1BQU0sR0FBRyxHQUFHLHlDQUF5QyxtQ0FBbUMsOENBQThDLHdDQUF3QyxnRUFBZ0UsOENBQThDLDBGQUEwRixFQUFFLDRDQUE0QyxzQkFBc0IsbUJBQW1CLEtBQUsseUJBQXlCLEdBQUcsUUFBUSwyRkFBMkYsNkVBQTZFLE9BQU8sTUFBTSwrQkFBK0IsNkRBQTZELHdCQUF3QixPQUFPLEtBQUssNkRBQTZELElBQUksMkNBQTJDLDRCQUE0QixxQkFBcUIsS0FBSyw4QkFBOEIsb0JBQW9CLHlCQUF5Qix1QkFBdUIsT0FBTyxpQ0FBaUMsT0FBTyxxSUFBcUksK0JBQStCLDJDQUEyQyxpR0FBaUcsRUFBRSwyQkFBMkIsa0NBQWtDLEtBQUssbURBQW1ELGtCQUFrQixnREFBZ0Qsd0JBQXdCLG1HQUFtRyxTQUFTLFFBQVEsS0FBSyxFQUFFLEdBQUc7QUFDNXNHO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNklBQTZJLHFrQkFBcWtCLGFBQWEsRUFBRSxrQ0FBa0MsNlpBQTZaLGdDQUFnQyxzRkFBc0YsYUFBYSwrRUFBK0Usc0hBQXNILGdCQUFnQixtQkFBbUIsNkZBQTZGLGtIQUFrSCxZQUFZLElBQUksb0JBQW9CLHNHQUFzRyxnRkFBZ0YsNEVBQTRFLEtBQUssbUJBQW1CLHlGQUF5RiwwTkFBME4sNkdBQTZHLGlCQUFpQixtR0FBbUcsc0hBQXNILGdCQUFnQixtQkFBbUIseUhBQXlILHlPQUF5TyxnQkFBZ0IsbUJBQW1CLHlGQUF5RixnU0FBZ1MsS0FBSyxtQkFBbUIscUhBQXFILG9HQUFvRyxrQkFBa0IsZ0NBQWdDLDBCQUEwQix5SEFBeUgsOEpBQThKLGtCQUFrQixrWUFBa1ksMkpBQTJKLFlBQVksOExBQThMLG1CQUFtQixnREFBZ0Qsb0JBQW9CLDhJQUE4SSxtREFBbUQsNENBQTRDLHlDQUF5QyxLQUFLLHdDQUF3QyxHQUFHLHFDQUFxQztBQUNsdEs7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsNkNBQTZDLHVFQUF1RSxnQkFBZ0Isc0NBQXNDLGtCQUFrQixzQ0FBc0MseURBQXlELHVDQUF1QyxVQUFVLGdDQUFnQyxnQ0FBZ0MsNEJBQTRCLHVCQUF1QixpR0FBaUcsVUFBVSxLQUFLLElBQUkscURBQXFELGFBQWEsRUFBRSxpSUFBaUksZ0hBQWdILHFDQUFxQyx1S0FBdUssc0NBQXNDLHNCQUFzQiwyREFBMkQsb0NBQW9DLHlCQUF5QixTQUFTLHlCQUF5QixLQUFLLGlDQUFpQyxnQ0FBZ0M7QUFDcDZDO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLDZDQUE2Qyx1RUFBdUUsZ0JBQWdCLHNDQUFzQyxrQkFBa0Isc0NBQXNDLHlEQUF5RCx1Q0FBdUMsVUFBVSxnQ0FBZ0MsZ0NBQWdDLDRCQUE0Qix1QkFBdUIsaUdBQWlHLFVBQVUsS0FBSyxJQUFJLHFEQUFxRCxhQUFhLEVBQUUsMEZBQTBGLHNIQUFzSCwyQ0FBMkMsb0NBQW9DLDRFQUE0RSxTQUFTLHlEQUF5RCx5Q0FBeUMsVUFBVSwrQkFBK0IsS0FBSyx1QkFBdUIsc0NBQXNDO0FBQzV3QztBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRiw2Q0FBNkMsdUVBQXVFLGdCQUFnQixzQ0FBc0Msa0JBQWtCLHNDQUFzQyx5REFBeUQsdUNBQXVDLFVBQVUsZ0NBQWdDLGdDQUFnQyw0QkFBNEIsdUJBQXVCLGlHQUFpRyxVQUFVLEtBQUssSUFBSSxxREFBcUQsYUFBYSxFQUFFLDBGQUEwRix3SEFBd0gsNkNBQTZDLHNDQUFzQyw0RUFBNEUsU0FBUyw2REFBNkQsMkNBQTJDLFVBQVUsaUNBQWlDLEtBQUssdUJBQXVCLHdDQUF3QztBQUM1eEM7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2SUFBNkkscWtCQUFxa0IsYUFBYSxFQUFFLGtDQUFrQyw0SEFBNEgsd0ZBQXdGLHlSQUF5UixvQ0FBb0MsdUJBQXVCLHVCQUF1QixTQUFTLGtEQUFrRCwwQkFBMEIsVUFBVSxrREFBa0QsMEJBQTBCLFVBQVUsOEVBQThFLCtDQUErQyx1Q0FBdUMsMEVBQTBFLGFBQWEseUJBQXlCLFVBQVUsMkVBQTJFLHdHQUF3RyxVQUFVLDJFQUEyRSxxREFBcUQsVUFBVSw2UEFBNlAsbUJBQW1CLGdGQUFnRiwrSEFBK0gseUVBQXlFLDBFQUEwRSx1QkFBdUIsdUJBQXVCLHVCQUF1QixxREFBcUQsOEhBQThILHFDQUFxQyxxQ0FBcUMscUNBQXFDLGFBQWEsK0ZBQStGLHFDQUFxQyxxQ0FBcUMscUNBQXFDLGFBQWEsa0JBQWtCLHFDQUFxQyxxQ0FBcUMscUNBQXFDLGFBQWEsbVhBQW1YLGtDQUFrQyxnQ0FBZ0MsOEJBQThCLGFBQWEsaUNBQWlDLGlDQUFpQyxpQ0FBaUMsVUFBVSxtTkFBbU4sZ0dBQWdHLFVBQVUsK0tBQStLLDhCQUE4Qiw4QkFBOEIsNkZBQTZGLFVBQVUsMkJBQTJCLEtBQUssSUFBSSxrQ0FBa0M7QUFDN3NKO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLDZDQUE2Qyx1RUFBdUUsZ0JBQWdCLHNDQUFzQyxrQkFBa0Isc0NBQXNDLHlEQUF5RCx1Q0FBdUMsVUFBVSxnQ0FBZ0MsZ0NBQWdDLDRCQUE0Qix1QkFBdUIsaUdBQWlHLFVBQVUsS0FBSyxJQUFJLHFEQUFxRCxhQUFhLEVBQUUsMEZBQTBGLG9JQUFvSSx5REFBeUQsa0RBQWtELDRFQUE0RSxTQUFTLDZDQUE2QyxLQUFLLHVCQUF1QixvREFBb0Q7QUFDdHVDO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNklBQTZJLDJrQkFBMmtCLHdGQUF3RixnQ0FBZ0MseURBQXlELCtCQUErQixtREFBbUQseUJBQXlCLCtCQUErQixhQUFhLFVBQVUsbUdBQW1HLE1BQU0scURBQXFELGFBQWEsRUFBRSxrREFBa0QseUNBQXlDLCtHQUErRywrQkFBK0IsNkJBQTZCLHVDQUF1Qyw4Q0FBOEMsOEZBQThGLHNHQUFzRyxzR0FBc0csc0dBQXNHLHNHQUFzRyxzR0FBc0csc0dBQXNHLHNHQUFzRyxzR0FBc0csc0dBQXNHLHlHQUF5Ryx5R0FBeUcseUdBQXlHLHlHQUF5Ryx5R0FBeUcseUdBQXlHLDZGQUE2RixpR0FBaUcsaUdBQWlHLGlHQUFpRyxpR0FBaUcseUhBQXlILDZGQUE2RiwrRkFBK0YsNkZBQTZGLG1HQUFtRyxpR0FBaUcsS0FBSyxtSEFBbUgsR0FBRyx3TkFBd04sc0VBQXNFLHdCQUF3Qix3Q0FBd0MsNkJBQTZCLHVCQUF1QixPQUFPLDJEQUEyRCxhQUFhLG1EQUFtRCw2QkFBNkIsa0RBQWtELDZEQUE2RCxhQUFhLGtCQUFrQiwwQ0FBMEMsYUFBYSx5REFBeUQsK0VBQStFLHdEQUF3RCxxQ0FBcUMsc0RBQXNELGdCQUFnQixNQUFNLGtDQUFrQywyREFBMkQsYUFBYSxpQkFBaUIsb0lBQW9JLDhCQUE4Qix1REFBdUQsaUVBQWlFLHFFQUFxRSxpQkFBaUIsYUFBYSw0QkFBNEIsUUFBUSxpQkFBaUIscUJBQXFCLHFCQUFxQixvSkFBb0osaUJBQWlCLDBCQUEwQiwyQkFBMkIsYUFBYSxTQUFTLG1EQUFtRCxrQ0FBa0MsTUFBTSxhQUFhLGlGQUFpRiwyQ0FBMkMsTUFBTSxxRUFBcUUsOEVBQThFLHNHQUFzRyxvRUFBb0Usd0NBQXdDLFVBQVUseURBQXlELDZCQUE2QixVQUFVLDBEQUEwRCxrQ0FBa0MsVUFBVSw4RUFBOEUsdUJBQXVCLHNPQUFzTyw0Q0FBNEMsc0VBQXNFLGFBQWEsd0VBQXdFLDZDQUE2QyxzRUFBc0UsYUFBYSxnQ0FBZ0MsVUFBVSw4UUFBOFEscUVBQXFFLDZDQUE2QyxzRUFBc0UsYUFBYSxnQ0FBZ0MsVUFBVSx5REFBeUQsa0RBQWtELDZCQUE2QixhQUFhLDBCQUEwQixzREFBc0QsVUFBVSw0REFBNEQsa0RBQWtELGdEQUFnRCwwZUFBMGUsZ0tBQWdLLDBJQUEwSSwwSUFBMEksMElBQTBJLDBJQUEwSSwwSUFBMEksMElBQTBJLDJJQUEySSwySUFBMkksZ0pBQWdKLGdKQUFnSixnSkFBZ0osZ0pBQWdKLGdKQUFnSixnSkFBZ0osK0dBQStHLHdIQUF3SCx3SEFBd0gsd0hBQXdILHdIQUF3SCxzS0FBc0ssMkdBQTJHLHlJQUF5SSxrR0FBa0csc0lBQXNJLGtIQUFrSCwrQkFBK0IsS0FBSyxJQUFJLHNDQUFzQztBQUM5K1k7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSkFBaUoscWtCQUFxa0IsYUFBYSxFQUFFLHlDQUF5Qyx3Q0FBd0MsNkJBQTZCLDRHQUE0RyxtSEFBbUgsb0hBQW9ILDhKQUE4SixnQ0FBZ0MsU0FBUyxpSUFBaUksbUVBQW1FLHVDQUF1QyxrQkFBa0Isc05BQXNOLHVKQUF1SixVQUFVLDJMQUEyTCxrREFBa0QsaUJBQWlCLEdBQUcsWUFBWSxHQUFHLGdCQUFnQiw4SkFBOEosMkhBQTJILG9GQUFvRixhQUFhLDBMQUEwTCxxQ0FBcUMscUNBQXFDLGlDQUFpQyxrQ0FBa0Msc0VBQXNFLG1DQUFtQyxtQ0FBbUMsa0NBQWtDLHlFQUF5RSx5RkFBeUYsaURBQWlELDhDQUE4QyxpREFBaUQsc0dBQXNHLDJMQUEyTCw0QkFBNEIsNkRBQTZELE1BQU0sNENBQTRDLDhEQUE4RCw0Q0FBNEMsbURBQW1ELDhDQUE4Qyx5QkFBeUIsOEJBQThCLDRDQUE0Qyx5QkFBeUIscUJBQXFCLG9EQUFvRCxtREFBbUQsOENBQThDLHlCQUF5Qiw4QkFBOEIsNENBQTRDLHVEQUF1RCxpREFBaUQsNkJBQTZCLGtDQUFrQyxnREFBZ0QsMkRBQTJELHFEQUFxRCxpQ0FBaUMsc0NBQXNDLG9EQUFvRCwrREFBK0QseURBQXlELHFDQUFxQywwQ0FBMEMsMERBQTBELHFDQUFxQyxpQ0FBaUMsNkJBQTZCLHlCQUF5QixzQkFBc0IsU0FBUyw2REFBNkQsaUJBQWlCLHVFQUF1RSx1REFBdUQsOENBQThDLHFCQUFxQiw0Q0FBNEMsK0VBQStFLDJDQUEyQywwQkFBMEIsU0FBUyxxRUFBcUUsc0JBQXNCLFNBQVMsNERBQTRELGlCQUFpQixzRUFBc0UsNENBQTRDLDZFQUE2RSxrREFBa0QseUJBQXlCLDhCQUE4Qiw0Q0FBNEMseUJBQXlCLHFCQUFxQixnRkFBZ0YsOENBQThDLHFCQUFxQiw0REFBNEQsNENBQTRDLHlEQUF5RCxvREFBb0Qsb0ZBQW9GLGtGQUFrRix5QkFBeUIscUJBQXFCLDRDQUE0Qyx3Q0FBd0MsdUdBQXVHLHVEQUF1RCwwRkFBMEYsd0ZBQXdGLHlCQUF5QixxQkFBcUIsMEJBQTBCLCtGQUErRix5REFBeUQscUJBQXFCLGlCQUFpQixhQUFhLGlEQUFpRCxrQ0FBa0MsYUFBYSxxREFBcUQsc0NBQXNDLGFBQWEsK05BQStOLHdDQUF3QyxhQUFhLDhRQUE4USw2Q0FBNkMsYUFBYSxpYUFBaWEscUxBQXFMLGFBQWEsOElBQThJLDRDQUE0QyxhQUFhLGdDQUFnQyw2Q0FBNkMsYUFBYSw0QkFBNEIsd0NBQXdDLGFBQWEsOEhBQThILFVBQVUsOFBBQThQLDBCQUEwQiw2QkFBNkIsdUJBQXVCLE9BQU8sNkNBQTZDLGFBQWEsdUJBQXVCLHdEQUF3RCxnRUFBZ0UsaUZBQWlGLDhEQUE4RCxtRUFBbUUsd0JBQXdCLDZCQUE2QixtRUFBbUUsOEJBQThCLHNFQUFzRSw4QkFBOEIsNEZBQTRGLDhCQUE4QixnR0FBZ0csOEJBQThCLGtHQUFrRyw4QkFBOEIsd0dBQXdHLDhCQUE4Qix1SUFBdUksOEJBQThCLGlCQUFpQiw0RkFBNEYseUNBQXlDLG1GQUFtRix3SEFBd0gseUNBQXlDLGFBQWEsZ0ZBQWdGLG1EQUFtRCxVQUFVLHlGQUF5RixrRUFBa0UsVUFBVSx1SkFBdUosb0NBQW9DLFlBQVkseUNBQXlDLFVBQVUscUhBQXFILGlEQUFpRCxVQUFVLDBFQUEwRSxpREFBaUQsOEVBQThFLHNEQUFzRCxxRUFBcUUsNkVBQTZFLHlGQUF5RiwyQkFBMkIsS0FBSyxJQUFJLGtDQUFrQztBQUM3cVo7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2SUFBNkkscWtCQUFxa0IsYUFBYSxFQUFFLGtEQUFrRCwwSEFBMEgsOEJBQThCLFNBQVMscURBQXFELFVBQVUsdURBQXVELHdCQUF3Qix1SkFBdUoseUJBQXlCLHlNQUF5TSxVQUFVLDZEQUE2RCxtREFBbUQsNEZBQTRGLDRGQUE0RiwrREFBK0QsVUFBVSxtZUFBbWUsZ0NBQWdDLGdDQUFnQyx5RUFBeUUsVUFBVSxnWEFBZ1gseUlBQXlJLFlBQVksOElBQThJLDBCQUEwQixxREFBcUQsZ0JBQWdCLE1BQU0saUNBQWlDLDJCQUEyQixhQUFhLHlCQUF5QixVQUFVLHlCQUF5QixLQUFLLElBQUksZ0NBQWdDO0FBQ2wxRztBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZJQUE2SSw4a0JBQThrQiw2Q0FBNkMsdUVBQXVFLGdCQUFnQixzQ0FBc0Msa0JBQWtCLHNDQUFzQyx5REFBeUQsdUNBQXVDLFVBQVUsZ0NBQWdDLGdDQUFnQyw0QkFBNEIsdUJBQXVCLGlHQUFpRyxVQUFVLEtBQUssSUFBSSxxREFBcUQsYUFBYSxFQUFFLGtEQUFrRCxzR0FBc0csaVZBQWlWLCtDQUErQyxvSEFBb0gsaUVBQWlFLG9IQUFvSCw4REFBOEQsNERBQTRELGdDQUFnQyxzQ0FBc0MsZ0NBQWdDLGFBQWEseUJBQXlCLFNBQVMsNEVBQTRFLDRDQUE0QyxVQUFVLDhEQUE4RCw4QkFBOEIsVUFBVSx5Q0FBeUMsK0JBQStCLHNWQUFzVixxR0FBcUcscUZBQXFGLDJGQUEyRixhQUFhLHlCQUF5QixVQUFVLDRKQUE0SiwyQkFBMkIsd0xBQXdMLCtDQUErQywyRUFBMkUsMkVBQTJFLDZHQUE2RyxvR0FBb0csVUFBVSxtQ0FBbUMsS0FBSyx5QkFBeUIsMENBQTBDO0FBQ3Z1STtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZJQUE2SSwya0JBQTJrQix3RkFBd0YsZ0NBQWdDLHlEQUF5RCwrQkFBK0IsbURBQW1ELHlCQUF5QiwrQkFBK0IsYUFBYSxVQUFVLG1HQUFtRyxNQUFNLHFEQUFxRCxhQUFhLEVBQUUsd0lBQXdJLHNIQUFzSCxrQ0FBa0MsbUNBQW1DLHFDQUFxQyxvQ0FBb0MsOEJBQThCLDZCQUE2Qix1V0FBdVcsZ05BQWdOLDBDQUEwQyxtREFBbUQsK0JBQStCLHNDQUFzQywwREFBMEQsU0FBUyxvRUFBb0UsOEJBQThCLFVBQVUsOEVBQThFLHdDQUF3QyxVQUFVLHdFQUF3RSxrQ0FBa0MsbUNBQW1DLHlDQUF5Qyx3Q0FBd0MsMEdBQTBHLGdnQkFBZ2dCLDBFQUEwRSwyREFBMkQsYUFBYSw2QkFBNkIsK0NBQStDLG9DQUFvQyxtQkFBbUIsYUFBYSxvRkFBb0Ysa0NBQWtDLGtDQUFrQyxrQ0FBa0Msa0NBQWtDLHFDQUFxQyxnQ0FBZ0MsVUFBVSxNQUFNLDBDQUEwQyw4RkFBOEYsbUVBQW1FLHlCQUF5QixtREFBbUQscUJBQXFCLDJCQUEyQixzRUFBc0UsOEVBQThFLDJHQUEyRyxzR0FBc0csNkRBQTZELDBQQUEwUCx1RUFBdUUseUZBQXlGLHlDQUF5Qyw4Q0FBOEMsaUZBQWlGLDRFQUE0RSxxdkJBQXF2QiwyREFBMkQsK0NBQStDLHlDQUF5QyxxQ0FBcUMsMENBQTBDLHNFQUFzRSxzRUFBc0Usc0VBQXNFLDBEQUEwRCwwREFBMEQseURBQXlELGlEQUFpRCxxQ0FBcUMsOEhBQThILHNEQUFzRCxzREFBc0Qsc0RBQXNELHNEQUFzRCxzREFBc0QsaUNBQWlDLHVDQUF1QyxpR0FBaUcsa0VBQWtFLGtFQUFrRSxzREFBc0Qsc0RBQXNELHFEQUFxRCxpQ0FBaUMsNkJBQTZCLGtDQUFrQyw2REFBNkQsNkJBQTZCLHlCQUF5QiwrQkFBK0IsK0VBQStFLHlCQUF5QixxQkFBcUIsaUJBQWlCLDhFQUE4RSxtRkFBbUYsNkNBQTZDLDhDQUE4Qyw4Q0FBOEMseUhBQXlILHlCQUF5QixxQkFBcUIsaUJBQWlCLGFBQWEsa0RBQWtELGdDQUFnQyxpQ0FBaUMsTUFBTSwyREFBMkQsaUJBQWlCLGFBQWEsNkVBQTZFLHlEQUF5RCx1Q0FBdUMsVUFBVSxxUUFBcVEsK0VBQStFLFVBQVUsMlZBQTJWLG9DQUFvQyw0QkFBNEIsT0FBTyxNQUFNLDBDQUEwQyxrQ0FBa0MsaUNBQWlDLGlCQUFpQix5Q0FBeUMsYUFBYSxzQ0FBc0MsNkJBQTZCLGFBQWEsbURBQW1ELCtDQUErQywwYUFBMGEsVUFBVSxtRkFBbUYsaUVBQWlFLHdDQUF3Qyx3Q0FBd0Msd0NBQXdDLHdDQUF3Qyx3Q0FBd0Msd0NBQXdDLFVBQVUsNDRCQUE0NEIsNERBQTRELGtHQUFrRyxtQ0FBbUMsdUZBQXVGLGdDQUFnQyxvQkFBb0IsYUFBYSw0Q0FBNEMsNkJBQTZCLGFBQWEsd0xBQXdMLGdDQUFnQyxvQkFBb0IsYUFBYSxxSkFBcUosNkJBQTZCLGFBQWEsd0xBQXdMLGdDQUFnQyxvQkFBb0IsYUFBYSwyQ0FBMkMsNkJBQTZCLGFBQWEseUNBQXlDLHdDQUF3Qyx1RUFBdUUsbUdBQW1HLGdDQUFnQyxvQkFBb0IsYUFBYSw0RkFBNEYsNkJBQTZCLGFBQWEsK0lBQStJLGdDQUFnQyxvQkFBb0IsYUFBYSx5RkFBeUYsNkJBQTZCLGFBQWEsOElBQThJLGdDQUFnQyxvQkFBb0IsYUFBYSw0Q0FBNEMsNkJBQTZCLGFBQWEsZ1JBQWdSLCtLQUErSyxVQUFVLDZuQkFBNm5CLGlCQUFpQix1TEFBdUwsbUNBQW1DLHlDQUF5Qyw0REFBNEQsdUVBQXVFLHFEQUFxRCxnQ0FBZ0Msb0JBQW9CLGFBQWEsd0JBQXdCLDJCQUEyQixhQUFhLG1GQUFtRixnQ0FBZ0Msb0JBQW9CLGFBQWEsaUlBQWlJLDJCQUEyQixhQUFhLGtGQUFrRixnQ0FBZ0Msb0JBQW9CLGFBQWEsMkNBQTJDLDJCQUEyQixhQUFhLHlFQUF5RSx1REFBdUQsZ0NBQWdDLG9CQUFvQixhQUFhLDZCQUE2QiwyQkFBMkIsYUFBYSxvRkFBb0YsZ0NBQWdDLG9CQUFvQixhQUFhLDBEQUEwRCwyQkFBMkIsYUFBYSxtRkFBbUYsZ0NBQWdDLG9CQUFvQixhQUFhLDRDQUE0QywyQkFBMkIsYUFBYSw4UkFBOFIseUdBQXlHLDJCQUEyQixhQUFhLDBJQUEwSSxVQUFVLCtCQUErQiw4Q0FBOEMsNFlBQTRZLG1DQUFtQyx3Q0FBd0MsNERBQTRELDJCQUEyQixxREFBcUQsZ0NBQWdDLG9CQUFvQixhQUFhLHdCQUF3QiwyQkFBMkIsYUFBYSxtRkFBbUYsZ0NBQWdDLG9CQUFvQixhQUFhLG9EQUFvRCwyQkFBMkIsYUFBYSxrRkFBa0YsZ0NBQWdDLG9CQUFvQixhQUFhLDJDQUEyQywyQkFBMkIsYUFBYSwyQkFBMkIsdURBQXVELGdDQUFnQyxvQkFBb0IsYUFBYSw2QkFBNkIsMkJBQTJCLGFBQWEsb0ZBQW9GLGdDQUFnQyxvQkFBb0IsYUFBYSwwREFBMEQsMkJBQTJCLGFBQWEsbUZBQW1GLGdDQUFnQyxvQkFBb0IsYUFBYSw0Q0FBNEMsMkJBQTJCLGFBQWEsOFJBQThSLHFHQUFxRywyQkFBMkIsYUFBYSwwSUFBMEksVUFBVSxrcUNBQWtxQywrSEFBK0gsaUZBQWlGLHFIQUFxSCxrQ0FBa0MscUxBQXFMLHNMQUFzTCxvRUFBb0Usc0NBQXNDLCtEQUErRCwyRUFBMkUsa0JBQWtCLFVBQVUsNERBQTRELGtLQUFrSyxtSEFBbUgseUNBQXlDLGtDQUFrQyx5QkFBeUIscUJBQXFCLGlDQUFpQyw2R0FBNkcsb0RBQW9ELHFCQUFxQixnQ0FBZ0MsaUJBQWlCLGFBQWEseUJBQXlCLFVBQVUsOFpBQThaLHdCQUF3QixrREFBa0QsMkJBQTJCLHlCQUF5QixhQUFhLDRDQUE0QyxpQkFBaUIsOEVBQThFLFVBQVUsaUJBQWlCLDBDQUEwQyx1RkFBdUYsMkRBQTJELDBEQUEwRCx5QkFBeUIsOEJBQThCLHdjQUF3Yyw2TUFBNk0seUJBQXlCLHFCQUFxQixpQkFBaUIsYUFBYSw0QkFBNEIsUUFBUSxpQkFBaUIscUJBQXFCLHFCQUFxQix3RUFBd0UsaUJBQWlCLDBCQUEwQiwyQkFBMkIsYUFBYSxxQkFBcUIsVUFBVSxvSUFBb0ksc0JBQXNCLHVNQUF1TSxpQ0FBaUMsbUNBQW1DLHNDQUFzQyxrREFBa0QsaUJBQWlCLDhFQUE4RSxVQUFVLGlCQUFpQiwyQ0FBMkMsd0ZBQXdGLHlDQUF5Qyw0RUFBNEUscUJBQXFCLGlCQUFpQixhQUFhLDRCQUE0QixRQUFRLGlCQUFpQixxQkFBcUIscUJBQXFCLHdFQUF3RSxpQkFBaUIsMEJBQTBCLDJCQUEyQixhQUFhLHFDQUFxQyw2QkFBNkIsYUFBYSwwYUFBMGEscUNBQXFDLGlCQUFpQiw4RUFBOEUsVUFBVSxpQkFBaUIsMkNBQTJDLDJGQUEyRixpQkFBaUIsYUFBYSw0QkFBNEIsUUFBUSxpQkFBaUIscUJBQXFCLHFCQUFxQix3RUFBd0UsaUJBQWlCLDBCQUEwQiwyQkFBMkIsYUFBYSw0REFBNEQsVUFBVSwwQ0FBMEMsb0JBQW9CLDBHQUEwRyxzQkFBc0IsMFFBQTBRLGlDQUFpQyx3REFBd0QsZ0NBQWdDLCtHQUErRyxhQUFhLHVEQUF1RCx3QkFBd0IsOEdBQThHLCtJQUErSSxpQ0FBaUMscUJBQXFCLGtGQUFrRixVQUFVLGlCQUFpQiw4Q0FBOEMsbUVBQW1FLGdEQUFnRCw4Q0FBOEMscUJBQXFCLGlCQUFpQixnQ0FBZ0MsUUFBUSxpQkFBaUIseUJBQXlCLHlCQUF5Qiw0RUFBNEUscUJBQXFCLDhCQUE4QiwyQkFBMkIsaUJBQWlCLHNEQUFzRCwrRUFBK0Usc1FBQXNRLGtGQUFrRixrRkFBa0YsMERBQTBELGlCQUFpQixFQUFFLDREQUE0RCxnQ0FBZ0MsMERBQTBELE1BQU0scURBQXFELHVGQUF1RixxREFBcUQsNEJBQTRCLHFCQUFxQixpQkFBaUIsYUFBYSw2Q0FBNkMsMkhBQTJILHFCQUFxQiw0SEFBNEgsMkJBQTJCLGlEQUFpRCx1RUFBdUUsbUZBQW1GLHFCQUFxQixpQkFBaUIsZ0NBQWdDLFFBQVEsaUJBQWlCLHlCQUF5Qix5QkFBeUIsNElBQTRJLHFCQUFxQiw4QkFBOEIsMkJBQTJCLGlCQUFpQixtRUFBbUUseUZBQXlGLCtCQUErQix5SkFBeUosb0VBQW9FLHNGQUFzRixzRkFBc0YsOERBQThELHFCQUFxQiwwQkFBMEIsdUVBQXVFLHFCQUFxQixpQkFBaUIsRUFBRSwyQ0FBMkMsNEVBQTRFLDBJQUEwSSxVQUFVLG9EQUFvRCxnREFBZ0QsNEZBQTRGLHVGQUF1RixLQUFLLElBQUksZ0RBQWdEO0FBQ25rZ0M7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsYUFBYSxFQUFFLGlHQUFpRywwQkFBMEIsU0FBUyxxTUFBcU0scUJBQXFCLFVBQVUscUlBQXFJLHFCQUFxQixLQUFLLElBQUksNEJBQTRCO0FBQ2pvQjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxhQUFhLEVBQUUsdUpBQXVKLDJIQUEySCw4R0FBOEcsbUNBQW1DLFNBQVMsd0lBQXdJLDJEQUEyRCxxQ0FBcUMsK0RBQStELGFBQWEsMklBQTJJLGdFQUFnRSxhQUFhLCtEQUErRCxVQUFVLDBSQUEwUixnRkFBZ0YsVUFBVSwrSEFBK0gsMkRBQTJELHFDQUFxQywyREFBMkQsYUFBYSw4RkFBOEYsOENBQThDLGFBQWEsa0pBQWtKLFVBQVUsZ0RBQWdELHVEQUF1RCw4Q0FBOEMsVUFBVSxzSkFBc0osOEdBQThHLFVBQVUsMkpBQTJKLGdFQUFnRSxnQ0FBZ0MsYUFBYSxnRkFBZ0YsVUFBVSxxSkFBcUosbUVBQW1FLHlFQUF5RSwyQkFBMkIseURBQXlELGNBQWMsTUFBTSxrREFBa0QsdUNBQXVDLG9DQUFvQyxxQkFBcUIsaUNBQWlDLGlCQUFpQiw2Q0FBNkMsYUFBYSxvRkFBb0Ysc0ZBQXNGLGFBQWEsNklBQTZJLFVBQVUsNEVBQTRFLHlOQUF5TixVQUFVLDZNQUE2TSx5RUFBeUUsc0RBQXNELCtCQUErQiw0QkFBNEIscUJBQXFCLE1BQU0sMERBQTBELGFBQWEsNkNBQTZDLFVBQVUsOEJBQThCLEtBQUssSUFBSSxxQ0FBcUM7QUFDMXFKO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHFEQUFxRCxhQUFhLEVBQUUsa0NBQWtDLCtCQUErQixnQ0FBZ0MsZUFBZSxpQ0FBaUMsa0NBQWtDLGVBQWUsK0JBQStCLGdDQUFnQyxlQUFlLHVCQUF1Qix3QkFBd0IsZUFBZSw2QkFBNkIsOEJBQThCLGVBQWUsc0NBQXNDLHVDQUF1QyxlQUFlLG1DQUFtQyxvQ0FBb0MsZUFBZSwrQkFBK0IsZ0NBQWdDLGVBQWUsNkJBQTZCLDhCQUE4QixlQUFlLGtDQUFrQyxtQ0FBbUMsZUFBZSwyQ0FBMkMsNENBQTRDLGVBQWUsNkJBQTZCLDhCQUE4Qiw0QkFBNEIsMkJBQTJCLDRCQUE0QixlQUFlLHVCQUF1Qix3QkFBd0IsZUFBZSwwQkFBMEIsMkJBQTJCLGVBQWUsNEJBQTRCLDZCQUE2QixlQUFlLHFDQUFxQyxzQ0FBc0MsZUFBZSw2QkFBNkIsOEJBQThCLGVBQWUsK0JBQStCLGdDQUFnQyxlQUFlLCtCQUErQixnQ0FBZ0MsZUFBZSxzQ0FBc0MsdUNBQXVDLGVBQWUsb0JBQW9CLHFCQUFxQixlQUFlLG9CQUFvQixxQkFBcUIsZUFBZSxnQ0FBZ0MsaUNBQWlDLGVBQWUsaUNBQWlDLGtDQUFrQyxlQUFlLGdDQUFnQyxpQ0FBaUMsZUFBZSxvQkFBb0IscUJBQXFCLG1DQUFtQyxzQkFBc0IsOEJBQThCLGVBQWUsdUJBQXVCLCtCQUErQixlQUFlLHVCQUF1QiwrQkFBK0IsZUFBZSw2QkFBNkIscUNBQXFDLGVBQWUsMkJBQTJCLG1DQUFtQyxlQUFlLGdDQUFnQyx3Q0FBd0MsZUFBZSw0QkFBNEIsb0NBQW9DLGVBQWUsNEJBQTRCLDZCQUE2QixlQUFlLHNDQUFzQyw4Q0FBOEMsZUFBZSx5QkFBeUIsaUNBQWlDLGVBQWUsaUNBQWlDLHlDQUF5QyxlQUFlLDZCQUE2QixxQ0FBcUMsZUFBZSxrQ0FBa0MsMENBQTBDLGVBQWUseUJBQXlCLGlDQUFpQyw0Q0FBNEMsdUJBQXVCLHdDQUF3QyxrQkFBa0IseUNBQXlDLDBEQUEwRCxlQUFlLG9DQUFvQyxxREFBcUQsK0NBQStDLHVCQUF1QiwyQ0FBMkMsZUFBZSwyQkFBMkIsK0NBQStDLGVBQWUsZ0NBQWdDLG9EQUFvRCxlQUFlLGdDQUFnQyxvREFBb0QsdUNBQXVDLDhCQUE4QiwwQ0FBMEMsd0NBQXdDLDBCQUEwQixrQ0FBa0MsZUFBZSwwQkFBMEIsa0NBQWtDLGVBQWUsK0NBQStDLGtEQUFrRCxlQUFlLDJCQUEyQixxQ0FBcUMsZUFBZSxpQ0FBaUMsb0NBQW9DLHVDQUF1Qyw2QkFBNkIsZ0NBQWdDLGlDQUFpQyx3QkFBd0IsOEJBQThCLGVBQWUseUJBQXlCLCtCQUErQixlQUFlLDJCQUEyQixpQ0FBaUMsZUFBZSx1QkFBdUIsNkJBQTZCLGVBQWUsMEJBQTBCLGdDQUFnQyxlQUFlLHlCQUF5QixtQ0FBbUMsZUFBZSwrQkFBK0Isa0RBQWtELGVBQWUsK0JBQStCLHlDQUF5Qyx5TUFBeU0sb0VBQW9FLHFDQUFxQywrQ0FBK0MsRUFBRSxtSEFBbUgsc0RBQXNELHFDQUFxQyxpQ0FBaUMsRUFBRSxzREFBc0QsaUNBQWlDLGtEQUFrRCxlQUFlLDBCQUEwQiwyQkFBMkIsZUFBZSw0QkFBNEIsNkJBQTZCLGVBQWUsb0JBQW9CLHFCQUFxQixlQUFlLDJCQUEyQiw0QkFBNEIsZUFBZSwyQkFBMkIsaUNBQWlDLGVBQWUscUNBQXFDLHNDQUFzQyxlQUFlLDZCQUE2Qiw4QkFBOEIsZUFBZSxzQ0FBc0MsdUNBQXVDLGVBQWUsdUJBQXVCLCtCQUErQixlQUFlLCtCQUErQixnQ0FBZ0MsZUFBZSx1QkFBdUIsd0JBQXdCLGVBQWUsc0JBQXNCLDhCQUE4QixlQUFlLGdDQUFnQyxpQ0FBaUMsZUFBZSxvQkFBb0IscUJBQXFCLGVBQWUsd0JBQXdCLDhCQUE4QixlQUFlLDZCQUE2Qiw4QkFBOEIsZUFBZSwrQkFBK0IsZ0NBQWdDLGVBQWUsMkNBQTJDLDRDQUE0QyxlQUFlLHVCQUF1Qix3QkFBd0IsZUFBZSw2QkFBNkIscUNBQXFDLGVBQWUsNkJBQTZCLHFDQUFxQztBQUNoK087QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HO0FBQ3BHO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0Esc0JBQXNCO0FBQ3RCLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9PWlNlYWxSZWNvZ25pdGlvbi8uL3NyYy9PWlNlYWxSZWNvZ25pdGlvbi5qcz81NWJjIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XHJcbiAgICBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXHJcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XHJcbiAgICBlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcclxuICAgICAgICBkZWZpbmUoXCJPWlNlYWxSZWNvZ25pdGlvblwiLCBbXSwgZmFjdG9yeSk7XHJcbiAgICBlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JylcclxuICAgICAgICBleHBvcnRzW1wiT1pTZWFsUmVjb2duaXRpb25cIl0gPSBmYWN0b3J5KCk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcm9vdFtcIk9aU2VhbFJlY29nbml0aW9uXCJdID0gZmFjdG9yeSgpO1xyXG59KSh3aW5kb3csIGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcclxuICAgICAgICAvKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcclxuICAgICAgICAvKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XHJcbiAgICAgICAgLyoqKioqKi9cclxuICAgICAgICAvKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXHJcbiAgICAgICAgLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XHJcbiAgICAgICAgICAgIC8qKioqKiovXHJcbiAgICAgICAgICAgIC8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcclxuICAgICAgICAgICAgLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XHJcbiAgICAgICAgICAgICAgICAvKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcclxuICAgICAgICAgICAgICAgIC8qKioqKiovIFx0XHR9XHJcbiAgICAgICAgICAgIC8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxyXG4gICAgICAgICAgICAvKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xyXG4gICAgICAgICAgICAgICAgLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXHJcbiAgICAgICAgICAgICAgICAvKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIC8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XHJcbiAgICAgICAgICAgICAgICAvKioqKioqLyBcdFx0fTtcclxuICAgICAgICAgICAgLyoqKioqKi9cclxuICAgICAgICAgICAgLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxyXG4gICAgICAgICAgICAvKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XHJcbiAgICAgICAgICAgIC8qKioqKiovXHJcbiAgICAgICAgICAgIC8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXHJcbiAgICAgICAgICAgIC8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XHJcbiAgICAgICAgICAgIC8qKioqKiovXHJcbiAgICAgICAgICAgIC8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxyXG4gICAgICAgICAgICAvKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xyXG4gICAgICAgICAgICAvKioqKioqLyBcdH1cclxuICAgICAgICAvKioqKioqL1xyXG4gICAgICAgIC8qKioqKiovXHJcbiAgICAgICAgLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxyXG4gICAgICAgIC8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcclxuICAgICAgICAvKioqKioqL1xyXG4gICAgICAgIC8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcclxuICAgICAgICAvKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XHJcbiAgICAgICAgLyoqKioqKi9cclxuICAgICAgICAvKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xyXG4gICAgICAgIC8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XHJcbiAgICAgICAgICAgIC8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAvKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcclxuICAgICAgICAgICAgICAgIC8qKioqKiovIFx0XHR9XHJcbiAgICAgICAgICAgIC8qKioqKiovIFx0fTtcclxuICAgICAgICAvKioqKioqL1xyXG4gICAgICAgIC8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xyXG4gICAgICAgIC8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xyXG4gICAgICAgICAgICAvKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XHJcbiAgICAgICAgICAgICAgICAvKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcclxuICAgICAgICAgICAgICAgIC8qKioqKiovIFx0XHR9XHJcbiAgICAgICAgICAgIC8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAvKioqKioqLyBcdH07XHJcbiAgICAgICAgLyoqKioqKi9cclxuICAgICAgICAvKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxyXG4gICAgICAgIC8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XHJcbiAgICAgICAgLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcclxuICAgICAgICAvKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxyXG4gICAgICAgIC8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxyXG4gICAgICAgIC8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcclxuICAgICAgICAgICAgLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xyXG4gICAgICAgICAgICAvKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgIC8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgICAgICAgICAvKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcclxuICAgICAgICAgICAgLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcclxuICAgICAgICAgICAgLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcclxuICAgICAgICAgICAgLyoqKioqKi8gXHRcdHJldHVybiBucztcclxuICAgICAgICAgICAgLyoqKioqKi8gXHR9O1xyXG4gICAgICAgIC8qKioqKiovXHJcbiAgICAgICAgLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xyXG4gICAgICAgIC8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcbiAgICAgICAgICAgIC8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cclxuICAgICAgICAgICAgICAgIC8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XHJcbiAgICAgICAgICAgICAgICAvKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xyXG4gICAgICAgICAgICAvKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xyXG4gICAgICAgICAgICAvKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcclxuICAgICAgICAgICAgLyoqKioqKi8gXHR9O1xyXG4gICAgICAgIC8qKioqKiovXHJcbiAgICAgICAgLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcclxuICAgICAgICAvKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcclxuICAgICAgICAvKioqKioqL1xyXG4gICAgICAgIC8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cclxuICAgICAgICAvKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XHJcbiAgICAgICAgLyoqKioqKi9cclxuICAgICAgICAvKioqKioqL1xyXG4gICAgICAgIC8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXHJcbiAgICAgICAgLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAwKTtcclxuICAgICAgICAvKioqKioqLyB9KVxyXG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgICAgICAgLyoqKioqKi8gKHtcclxuXHJcbiAgICAgICAgICAgIC8qKiovIFwiLi9ub2RlX21vZHVsZXMvdHMtY3VzdG9tLWVycm9yL2Rpc3QvY3VzdG9tLWVycm9yLm1qc1wiOlxyXG4gICAgICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXHJcbiAgICAgICAgICAgICAgISoqKiAuL25vZGVfbW9kdWxlcy90cy1jdXN0b20tZXJyb3IvZGlzdC9jdXN0b20tZXJyb3IubWpzICoqKiFcclxuICAgICAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuICAgICAgICAgICAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IEN1c3RvbUVycm9yLCBjdXN0b21FcnJvckZhY3RvcnkgKi9cclxuICAgICAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIHJlZmVyZW5jZWQgZnJvbSB0aGVzZSBtb2R1bGVzIHdpdGggdW5zdXBwb3J0ZWQgc3ludGF4OiAuL3NyYy9jb3JlL0V4Y2VwdGlvbi50cyAocmVmZXJlbmNlZCB3aXRoIGNqcyByZXF1aXJlKSAqL1xyXG4gICAgICAgICAgICAvKioqLyAoZnVuY3Rpb24oX193ZWJwYWNrX21vZHVsZV9fLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICAgICAgICAgICAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIkN1c3RvbUVycm9yXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBDdXN0b21FcnJvcjsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiY3VzdG9tRXJyb3JGYWN0b3J5XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjdXN0b21FcnJvckZhY3Rvcnk7IH0pO1xcbmZ1bmN0aW9uIGZpeFByb3RvKHRhcmdldCwgcHJvdG90eXBlKSB7XFxuICB2YXIgc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2Y7XFxuICBzZXRQcm90b3R5cGVPZiA/IHNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG90eXBlKSA6IHRhcmdldC5fX3Byb3RvX18gPSBwcm90b3R5cGU7XFxufVxcbmZ1bmN0aW9uIGZpeFN0YWNrKHRhcmdldCwgZm4pIHtcXG4gIGlmIChmbiA9PT0gdm9pZCAwKSB7XFxuICAgIGZuID0gdGFyZ2V0LmNvbnN0cnVjdG9yO1xcbiAgfVxcblxcbiAgdmFyIGNhcHR1cmVTdGFja1RyYWNlID0gRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2U7XFxuICBjYXB0dXJlU3RhY2tUcmFjZSAmJiBjYXB0dXJlU3RhY2tUcmFjZSh0YXJnZXQsIGZuKTtcXG59XFxuXFxudmFyIF9fZXh0ZW5kcyA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19leHRlbmRzIHx8IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBfZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIGV4dGVuZFN0YXRpY3MoZCwgYikge1xcbiAgICBfZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XFxuICAgICAgX19wcm90b19fOiBbXVxcbiAgICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcXG4gICAgICBkLl9fcHJvdG9fXyA9IGI7XFxuICAgIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcXG4gICAgICBmb3IgKHZhciBwIGluIGIpIHtcXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdO1xcbiAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgcmV0dXJuIF9leHRlbmRTdGF0aWNzKGQsIGIpO1xcbiAgfTtcXG5cXG4gIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xcbiAgICBpZiAodHlwZW9mIGIgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgYiAhPT0gbnVsbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcXFwiICsgU3RyaW5nKGIpICsgXFxcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXFxcIik7XFxuXFxuICAgIF9leHRlbmRTdGF0aWNzKGQsIGIpO1xcblxcbiAgICBmdW5jdGlvbiBfXygpIHtcXG4gICAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDtcXG4gICAgfVxcblxcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XFxuICB9O1xcbn0oKTtcXG5cXG52YXIgQ3VzdG9tRXJyb3IgPSBmdW5jdGlvbiAoX3N1cGVyKSB7XFxuICBfX2V4dGVuZHMoQ3VzdG9tRXJyb3IsIF9zdXBlcik7XFxuXFxuICBmdW5jdGlvbiBDdXN0b21FcnJvcihtZXNzYWdlLCBvcHRpb25zKSB7XFxuICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3RvcjtcXG5cXG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSwgb3B0aW9ucykgfHwgdGhpcztcXG5cXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCAnbmFtZScsIHtcXG4gICAgICB2YWx1ZTogX25ld1RhcmdldC5uYW1lLFxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxcbiAgICB9KTtcXG4gICAgZml4UHJvdG8oX3RoaXMsIF9uZXdUYXJnZXQucHJvdG90eXBlKTtcXG4gICAgZml4U3RhY2soX3RoaXMpO1xcbiAgICByZXR1cm4gX3RoaXM7XFxuICB9XFxuXFxuICByZXR1cm4gQ3VzdG9tRXJyb3I7XFxufShFcnJvcik7XFxuXFxudmFyIF9fc3ByZWFkQXJyYXkgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fc3ByZWFkQXJyYXkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XFxuICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xcbiAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XFxuICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcXG4gICAgICBhcltpXSA9IGZyb21baV07XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xcbn07XFxuZnVuY3Rpb24gY3VzdG9tRXJyb3JGYWN0b3J5KGZuLCBwYXJlbnQpIHtcXG4gIGlmIChwYXJlbnQgPT09IHZvaWQgMCkge1xcbiAgICBwYXJlbnQgPSBFcnJvcjtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIEN1c3RvbUVycm9yKCkge1xcbiAgICB2YXIgYXJncyA9IFtdO1xcblxcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xcbiAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcXG4gICAgfVxcblxcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ3VzdG9tRXJyb3IpKSByZXR1cm4gbmV3IChDdXN0b21FcnJvci5iaW5kLmFwcGx5KEN1c3RvbUVycm9yLCBfX3NwcmVhZEFycmF5KFt2b2lkIDBdLCBhcmdzLCBmYWxzZSkpKSgpO1xcbiAgICBwYXJlbnQuYXBwbHkodGhpcywgYXJncyk7XFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmFtZScsIHtcXG4gICAgICB2YWx1ZTogZm4ubmFtZSB8fCBwYXJlbnQubmFtZSxcXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcXG4gICAgfSk7XFxuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xcbiAgICBmaXhTdGFjayh0aGlzLCBDdXN0b21FcnJvcik7XFxuICB9XFxuXFxuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ3VzdG9tRXJyb3IsIHtcXG4gICAgcHJvdG90eXBlOiB7XFxuICAgICAgdmFsdWU6IE9iamVjdC5jcmVhdGUocGFyZW50LnByb3RvdHlwZSwge1xcbiAgICAgICAgY29uc3RydWN0b3I6IHtcXG4gICAgICAgICAgdmFsdWU6IEN1c3RvbUVycm9yLFxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXFxuICAgICAgICB9XFxuICAgICAgfSlcXG4gICAgfVxcbiAgfSk7XFxufVxcblxcblxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWN1c3RvbS1lcnJvci5tanMubWFwXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vT1pTZWFsUmVjb2duaXRpb24vLi9ub2RlX21vZHVsZXMvdHMtY3VzdG9tLWVycm9yL2Rpc3QvY3VzdG9tLWVycm9yLm1qcz9cIik7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqKi8gfSksXHJcblxyXG4gICAgICAgICAgICAvKioqLyBcIi4vc3JjL2NvcmUvRGVjb2RlSGludFR5cGUudHNcIjpcclxuICAgICAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxyXG4gICAgICAgICAgICAgICEqKiogLi9zcmMvY29yZS9EZWNvZGVIaW50VHlwZS50cyAqKiohXHJcbiAgICAgICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgICAgICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xyXG4gICAgICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXHJcbiAgICAgICAgICAgIC8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbiAgICAgICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgICAgICAgICAgICAgIGV2YWwoXCJcXHJcXG4vKlxcclxcbiAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcXHJcXG4gKlxcclxcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcXFwiTGljZW5zZVxcXCIpO1xcclxcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cXHJcXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcXHJcXG4gKlxcclxcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXFxyXFxuICpcXHJcXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXFxyXFxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXFxcIkFTIElTXFxcIiBCQVNJUyxcXHJcXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cXHJcXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXFxyXFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXFxyXFxuICovXFxyXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcXHJcXG4vKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nIHsqL1xcclxcbi8qKlxcclxcbiAqIEVuY2Fwc3VsYXRlcyBhIHR5cGUgb2YgaGludCB0aGF0IGEgY2FsbGVyIG1heSBwYXNzIHRvIGEgYmFyY29kZSByZWFkZXIgdG8gaGVscCBpdFxcclxcbiAqIG1vcmUgcXVpY2tseSBvciBhY2N1cmF0ZWx5IGRlY29kZSBpdC4gSXQgaXMgdXAgdG8gaW1wbGVtZW50YXRpb25zIHRvIGRlY2lkZSB3aGF0LFxcclxcbiAqIGlmIGFueXRoaW5nLCB0byBkbyB3aXRoIHRoZSBpbmZvcm1hdGlvbiB0aGF0IGlzIHN1cHBsaWVkLlxcclxcbiAqXFxyXFxuICogQGF1dGhvciBTZWFuIE93ZW5cXHJcXG4gKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxcclxcbiAqIEBzZWUgUmVhZGVyI2RlY29kZShCaW5hcnlCaXRtYXAsamF2YS51dGlsLk1hcClcXHJcXG4gKi9cXHJcXG52YXIgRGVjb2RlSGludFR5cGU7XFxyXFxuKGZ1bmN0aW9uIChEZWNvZGVIaW50VHlwZSkge1xcclxcbiAgICAvKipcXHJcXG4gICAgICogVW5zcGVjaWZpZWQsIGFwcGxpY2F0aW9uLXNwZWNpZmljIGhpbnQuIE1hcHMgdG8gYW4gdW5zcGVjaWZpZWQge0BsaW5rIE9iamVjdH0uXFxyXFxuICAgICAqL1xcclxcbiAgICBEZWNvZGVIaW50VHlwZVtEZWNvZGVIaW50VHlwZVtcXFwiT1RIRVJcXFwiXSA9IDBdID0gXFxcIk9USEVSXFxcIjsgLyooT2JqZWN0LmNsYXNzKSovXFxyXFxuICAgIC8qKlxcclxcbiAgICAgKiBJbWFnZSBpcyBhIHB1cmUgbW9ub2Nocm9tZSBpbWFnZSBvZiBhIGJhcmNvZGUuIERvZXNuJ3QgbWF0dGVyIHdoYXQgaXQgbWFwcyB0bztcXHJcXG4gICAgICogdXNlIHtAbGluayBCb29sZWFuI1RSVUV9LlxcclxcbiAgICAgKi9cXHJcXG4gICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbXFxcIlBVUkVfQkFSQ09ERVxcXCJdID0gMV0gPSBcXFwiUFVSRV9CQVJDT0RFXFxcIjsgLyooVm9pZC5jbGFzcykqL1xcclxcbiAgICAvKipcXHJcXG4gICAgICogSW1hZ2UgaXMga25vd24gdG8gYmUgb2Ygb25lIG9mIGEgZmV3IHBvc3NpYmxlIGZvcm1hdHMuXFxyXFxuICAgICAqIE1hcHMgdG8gYSB7QGxpbmsgTGlzdH0gb2Yge0BsaW5rIEJhcmNvZGVGb3JtYXR9cy5cXHJcXG4gICAgICovXFxyXFxuICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlW1xcXCJQT1NTSUJMRV9GT1JNQVRTXFxcIl0gPSAyXSA9IFxcXCJQT1NTSUJMRV9GT1JNQVRTXFxcIjsgLyooTGlzdC5jbGFzcykqL1xcclxcbiAgICAvKipcXHJcXG4gICAgICogU3BlbmQgbW9yZSB0aW1lIHRvIHRyeSB0byBmaW5kIGEgYmFyY29kZTsgb3B0aW1pemUgZm9yIGFjY3VyYWN5LCBub3Qgc3BlZWQuXFxyXFxuICAgICAqIERvZXNuJ3QgbWF0dGVyIHdoYXQgaXQgbWFwcyB0bzsgdXNlIHtAbGluayBCb29sZWFuI1RSVUV9LlxcclxcbiAgICAgKi9cXHJcXG4gICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbXFxcIlRSWV9IQVJERVJcXFwiXSA9IDNdID0gXFxcIlRSWV9IQVJERVJcXFwiOyAvKihWb2lkLmNsYXNzKSovXFxyXFxuICAgIC8qKlxcclxcbiAgICAgKiBTcGVjaWZpZXMgd2hhdCBjaGFyYWN0ZXIgZW5jb2RpbmcgdG8gdXNlIHdoZW4gZGVjb2RpbmcsIHdoZXJlIGFwcGxpY2FibGUgKHR5cGUgU3RyaW5nKVxcclxcbiAgICAgKi9cXHJcXG4gICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbXFxcIkNIQVJBQ1RFUl9TRVRcXFwiXSA9IDRdID0gXFxcIkNIQVJBQ1RFUl9TRVRcXFwiOyAvKihTdHJpbmcuY2xhc3MpKi9cXHJcXG4gICAgLyoqXFxyXFxuICAgICAqIEFsbG93ZWQgbGVuZ3RocyBvZiBlbmNvZGVkIGRhdGEgLS0gcmVqZWN0IGFueXRoaW5nIGVsc2UuIE1hcHMgdG8gYW4ge0Bjb2RlIEludDMyQXJyYXl9LlxcclxcbiAgICAgKi9cXHJcXG4gICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbXFxcIkFMTE9XRURfTEVOR1RIU1xcXCJdID0gNV0gPSBcXFwiQUxMT1dFRF9MRU5HVEhTXFxcIjsgLyooSW50MzJBcnJheS5jbGFzcykqL1xcclxcbiAgICAvKipcXHJcXG4gICAgICogQXNzdW1lIENvZGUgMzkgY29kZXMgZW1wbG95IGEgY2hlY2sgZGlnaXQuIERvZXNuJ3QgbWF0dGVyIHdoYXQgaXQgbWFwcyB0bztcXHJcXG4gICAgICogdXNlIHtAbGluayBCb29sZWFuI1RSVUV9LlxcclxcbiAgICAgKi9cXHJcXG4gICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbXFxcIkFTU1VNRV9DT0RFXzM5X0NIRUNLX0RJR0lUXFxcIl0gPSA2XSA9IFxcXCJBU1NVTUVfQ09ERV8zOV9DSEVDS19ESUdJVFxcXCI7IC8qKFZvaWQuY2xhc3MpKi9cXHJcXG4gICAgLyoqXFxyXFxuICAgICAqIEFzc3VtZSB0aGUgYmFyY29kZSBpcyBiZWluZyBwcm9jZXNzZWQgYXMgYSBHUzEgYmFyY29kZSwgYW5kIG1vZGlmeSBiZWhhdmlvciBhcyBuZWVkZWQuXFxyXFxuICAgICAqIEZvciBleGFtcGxlIHRoaXMgYWZmZWN0cyBGTkMxIGhhbmRsaW5nIGZvciBDb2RlIDEyOCAoYWthIEdTMS0xMjgpLiBEb2Vzbid0IG1hdHRlciB3aGF0IGl0IG1hcHMgdG87XFxyXFxuICAgICAqIHVzZSB7QGxpbmsgQm9vbGVhbiNUUlVFfS5cXHJcXG4gICAgICovXFxyXFxuICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlW1xcXCJBU1NVTUVfR1MxXFxcIl0gPSA3XSA9IFxcXCJBU1NVTUVfR1MxXFxcIjsgLyooVm9pZC5jbGFzcykqL1xcclxcbiAgICAvKipcXHJcXG4gICAgICogSWYgdHJ1ZSwgcmV0dXJuIHRoZSBzdGFydCBhbmQgZW5kIGRpZ2l0cyBpbiBhIENvZGFiYXIgYmFyY29kZSBpbnN0ZWFkIG9mIHN0cmlwcGluZyB0aGVtLiBUaGV5XFxyXFxuICAgICAqIGFyZSBhbHBoYSwgd2hlcmVhcyB0aGUgcmVzdCBhcmUgbnVtZXJpYy4gQnkgZGVmYXVsdCwgdGhleSBhcmUgc3RyaXBwZWQsIGJ1dCB0aGlzIGNhdXNlcyB0aGVtXFxyXFxuICAgICAqIHRvIG5vdCBiZS4gRG9lc24ndCBtYXR0ZXIgd2hhdCBpdCBtYXBzIHRvOyB1c2Uge0BsaW5rIEJvb2xlYW4jVFJVRX0uXFxyXFxuICAgICAqL1xcclxcbiAgICBEZWNvZGVIaW50VHlwZVtEZWNvZGVIaW50VHlwZVtcXFwiUkVUVVJOX0NPREFCQVJfU1RBUlRfRU5EXFxcIl0gPSA4XSA9IFxcXCJSRVRVUk5fQ09EQUJBUl9TVEFSVF9FTkRcXFwiOyAvKihWb2lkLmNsYXNzKSovXFxyXFxuICAgIC8qKlxcclxcbiAgICAgKiBUaGUgY2FsbGVyIG5lZWRzIHRvIGJlIG5vdGlmaWVkIHZpYSBjYWxsYmFjayB3aGVuIGEgcG9zc2libGUge0BsaW5rIFJlc3VsdFBvaW50fVxcclxcbiAgICAgKiBpcyBmb3VuZC4gTWFwcyB0byBhIHtAbGluayBSZXN1bHRQb2ludENhbGxiYWNrfS5cXHJcXG4gICAgICovXFxyXFxuICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlW1xcXCJORUVEX1JFU1VMVF9QT0lOVF9DQUxMQkFDS1xcXCJdID0gOV0gPSBcXFwiTkVFRF9SRVNVTFRfUE9JTlRfQ0FMTEJBQ0tcXFwiOyAvKihSZXN1bHRQb2ludENhbGxiYWNrLmNsYXNzKSovXFxyXFxuICAgIC8qKlxcclxcbiAgICAgKiBBbGxvd2VkIGV4dGVuc2lvbiBsZW5ndGhzIGZvciBFQU4gb3IgVVBDIGJhcmNvZGVzLiBPdGhlciBmb3JtYXRzIHdpbGwgaWdub3JlIHRoaXMuXFxyXFxuICAgICAqIE1hcHMgdG8gYW4ge0Bjb2RlIEludDMyQXJyYXl9IG9mIHRoZSBhbGxvd2VkIGV4dGVuc2lvbiBsZW5ndGhzLCBmb3IgZXhhbXBsZSBbMl0sIFs1XSwgb3IgWzIsIDVdLlxcclxcbiAgICAgKiBJZiBpdCBpcyBvcHRpb25hbCB0byBoYXZlIGFuIGV4dGVuc2lvbiwgZG8gbm90IHNldCB0aGlzIGhpbnQuIElmIHRoaXMgaXMgc2V0LFxcclxcbiAgICAgKiBhbmQgYSBVUEMgb3IgRUFOIGJhcmNvZGUgaXMgZm91bmQgYnV0IGFuIGV4dGVuc2lvbiBpcyBub3QsIHRoZW4gbm8gcmVzdWx0IHdpbGwgYmUgcmV0dXJuZWRcXHJcXG4gICAgICogYXQgYWxsLlxcclxcbiAgICAgKi9cXHJcXG4gICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbXFxcIkFMTE9XRURfRUFOX0VYVEVOU0lPTlNcXFwiXSA9IDEwXSA9IFxcXCJBTExPV0VEX0VBTl9FWFRFTlNJT05TXFxcIjsgLyooSW50MzJBcnJheS5jbGFzcykqL1xcclxcbiAgICAvLyBFbmQgb2YgZW51bWVyYXRpb24gdmFsdWVzLlxcclxcbiAgICAvKipcXHJcXG4gICAgICogRGF0YSB0eXBlIHRoZSBoaW50IGlzIGV4cGVjdGluZy5cXHJcXG4gICAgICogQW1vbmcgdGhlIHBvc3NpYmxlIHZhbHVlcyB0aGUge0BsaW5rIFZvaWR9IHN0YW5kcyBvdXQgYXMgYmVpbmcgdXNlZCBmb3JcXHJcXG4gICAgICogaGludHMgdGhhdCBkbyBub3QgZXhwZWN0IGEgdmFsdWUgdG8gYmUgc3VwcGxpZWQgKGZsYWcgaGludHMpLiBTdWNoIGhpbnRzXFxyXFxuICAgICAqIHdpbGwgcG9zc2libHkgaGF2ZSB0aGVpciB2YWx1ZSBpZ25vcmVkLCBvciByZXBsYWNlZCBieSBhXFxyXFxuICAgICAqIHtAbGluayBCb29sZWFuI1RSVUV9LiBIaW50IHN1cHBsaWVycyBzaG91bGQgcHJvYmFibHkgdXNlXFxyXFxuICAgICAqIHtAbGluayBCb29sZWFuI1RSVUV9IGFzIGRpcmVjdGVkIGJ5IHRoZSBhY3R1YWwgaGludCBkb2N1bWVudGF0aW9uLlxcclxcbiAgICAgKi9cXHJcXG4gICAgLy8gcHJpdmF0ZSB2YWx1ZVR5cGU6IENsYXNzPD8+XFxyXFxuICAgIC8vIERlY29kZUhpbnRUeXBlKHZhbHVlVHlwZTogQ2xhc3M8Pz4pIHtcXHJcXG4gICAgLy8gICB0aGlzLnZhbHVlVHlwZSA9IHZhbHVlVHlwZVxcclxcbiAgICAvLyB9XFxyXFxuICAgIC8vIHB1YmxpYyBnZXRWYWx1ZVR5cGUoKTogQ2xhc3M8Pz4ge1xcclxcbiAgICAvLyAgIHJldHVybiB2YWx1ZVR5cGVcXHJcXG4gICAgLy8gfVxcclxcbn0pKERlY29kZUhpbnRUeXBlIHx8IChEZWNvZGVIaW50VHlwZSA9IHt9KSk7XFxyXFxuZXhwb3J0cy5kZWZhdWx0ID0gRGVjb2RlSGludFR5cGU7XFxyXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vT1pTZWFsUmVjb2duaXRpb24vLi9zcmMvY29yZS9EZWNvZGVIaW50VHlwZS50cz9cIik7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqKi8gfSksXHJcblxyXG4gICAgICAgICAgICAvKioqLyBcIi4vc3JjL2NvcmUvRXhjZXB0aW9uLnRzXCI6XHJcbiAgICAgICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXHJcbiAgICAgICAgICAgICAgISoqKiAuL3NyYy9jb3JlL0V4Y2VwdGlvbi50cyAqKiohXHJcbiAgICAgICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cclxuICAgICAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xyXG4gICAgICAgICAgICAvKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICAgICAgICAgICAgICBldmFsKFwiXFxyXFxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xcclxcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XFxyXFxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XFxyXFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxcclxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xcclxcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XFxyXFxuICAgIH07XFxyXFxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xcclxcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcXHJcXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxcclxcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xcclxcbiAgICB9O1xcclxcbn0pKCk7XFxyXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcXHJcXG52YXIgdHNfY3VzdG9tX2Vycm9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0cy1jdXN0b20tZXJyb3IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3RzLWN1c3RvbS1lcnJvci9kaXN0L2N1c3RvbS1lcnJvci5tanNcXFwiKTtcXHJcXG4vKipcXHJcXG4gKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uXFxyXFxuICovXFxyXFxudmFyIEV4Y2VwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcXHJcXG4gICAgX19leHRlbmRzKEV4Y2VwdGlvbiwgX3N1cGVyKTtcXHJcXG4gICAgLyoqXFxyXFxuICAgICAqIEFsbG93cyBFeGNlcHRpb24gdG8gYmUgY29uc3RydWN0ZWQgZGlyZWN0bHlcXHJcXG4gICAgICogd2l0aCBzb21lIG1lc3NhZ2UgYW5kIHByb3RvdHlwZSBkZWZpbml0aW9uLlxcclxcbiAgICAgKi9cXHJcXG4gICAgZnVuY3Rpb24gRXhjZXB0aW9uKG1lc3NhZ2UpIHtcXHJcXG4gICAgICAgIGlmIChtZXNzYWdlID09PSB2b2lkIDApIHsgbWVzc2FnZSA9IHVuZGVmaW5lZDsgfVxcclxcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcXHJcXG4gICAgICAgIF90aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xcclxcbiAgICAgICAgcmV0dXJuIF90aGlzO1xcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiBFeGNlcHRpb247XFxyXFxufSh0c19jdXN0b21fZXJyb3JfMS5DdXN0b21FcnJvcikpO1xcclxcbmV4cG9ydHMuZGVmYXVsdCA9IEV4Y2VwdGlvbjtcXHJcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9PWlNlYWxSZWNvZ25pdGlvbi8uL3NyYy9jb3JlL0V4Y2VwdGlvbi50cz9cIik7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqKi8gfSksXHJcblxyXG4gICAgICAgICAgICAvKioqLyBcIi4vc3JjL2NvcmUvRm9ybWF0RXhjZXB0aW9uLnRzXCI6XHJcbiAgICAgICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXHJcbiAgICAgICAgICAgICAgISoqKiAuL3NyYy9jb3JlL0Zvcm1hdEV4Y2VwdGlvbi50cyAqKiohXHJcbiAgICAgICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cclxuICAgICAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xyXG4gICAgICAgICAgICAvKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICAgICAgICAgICAgICBldmFsKFwiXFxyXFxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xcclxcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XFxyXFxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XFxyXFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxcclxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xcclxcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XFxyXFxuICAgIH07XFxyXFxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xcclxcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcXHJcXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxcclxcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xcclxcbiAgICB9O1xcclxcbn0pKCk7XFxyXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcXHJcXG52YXIgRXhjZXB0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL0V4Y2VwdGlvbiAqLyBcXFwiLi9zcmMvY29yZS9FeGNlcHRpb24udHNcXFwiKTtcXHJcXG4vKipcXHJcXG4gKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uXFxyXFxuICovXFxyXFxudmFyIEZvcm1hdEV4Y2VwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcXHJcXG4gICAgX19leHRlbmRzKEZvcm1hdEV4Y2VwdGlvbiwgX3N1cGVyKTtcXHJcXG4gICAgZnVuY3Rpb24gRm9ybWF0RXhjZXB0aW9uKCkge1xcclxcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xcclxcbiAgICB9XFxyXFxuICAgIEZvcm1hdEV4Y2VwdGlvbi5nZXRGb3JtYXRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgIHJldHVybiBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XFxyXFxuICAgIH07XFxyXFxuICAgIHJldHVybiBGb3JtYXRFeGNlcHRpb247XFxyXFxufShFeGNlcHRpb25fMS5kZWZhdWx0KSk7XFxyXFxuZXhwb3J0cy5kZWZhdWx0ID0gRm9ybWF0RXhjZXB0aW9uO1xcclxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL09aU2VhbFJlY29nbml0aW9uLy4vc3JjL2NvcmUvRm9ybWF0RXhjZXB0aW9uLnRzP1wiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKioqLyB9KSxcclxuXHJcbiAgICAgICAgICAgIC8qKiovIFwiLi9zcmMvY29yZS9Ob3RGb3VuZEV4Y2VwdGlvbi50c1wiOlxyXG4gICAgICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXHJcbiAgICAgICAgICAgICAgISoqKiAuL3NyYy9jb3JlL05vdEZvdW5kRXhjZXB0aW9uLnRzICoqKiFcclxuICAgICAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuICAgICAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXHJcbiAgICAgICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cclxuICAgICAgICAgICAgLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuICAgICAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgICAgICAgICAgICAgZXZhbChcIlxcclxcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xcclxcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxcclxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcXHJcXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcXHJcXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xcclxcbiAgICB9O1xcclxcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcXHJcXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XFxyXFxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cXHJcXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcXHJcXG4gICAgfTtcXHJcXG59KSgpO1xcclxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHsgdmFsdWU6IHRydWUgfSk7XFxyXFxudmFyIEV4Y2VwdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9FeGNlcHRpb24gKi8gXFxcIi4vc3JjL2NvcmUvRXhjZXB0aW9uLnRzXFxcIik7XFxyXFxuLyoqXFxyXFxuICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxcclxcbiAqL1xcclxcbnZhciBOb3RGb3VuZEV4Y2VwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcXHJcXG4gICAgX19leHRlbmRzKE5vdEZvdW5kRXhjZXB0aW9uLCBfc3VwZXIpO1xcclxcbiAgICBmdW5jdGlvbiBOb3RGb3VuZEV4Y2VwdGlvbigpIHtcXHJcXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcXHJcXG4gICAgfVxcclxcbiAgICBOb3RGb3VuZEV4Y2VwdGlvbi5nZXROb3RGb3VuZEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xcclxcbiAgICAgICAgcmV0dXJuIG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xcclxcbiAgICB9O1xcclxcbiAgICByZXR1cm4gTm90Rm91bmRFeGNlcHRpb247XFxyXFxufShFeGNlcHRpb25fMS5kZWZhdWx0KSk7XFxyXFxuZXhwb3J0cy5kZWZhdWx0ID0gTm90Rm91bmRFeGNlcHRpb247XFxyXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vT1pTZWFsUmVjb2duaXRpb24vLi9zcmMvY29yZS9Ob3RGb3VuZEV4Y2VwdGlvbi50cz9cIik7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqKi8gfSksXHJcblxyXG4gICAgICAgICAgICAvKioqLyBcIi4vc3JjL2NvcmUvUmVzdWx0UG9pbnQudHNcIjpcclxuICAgICAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxyXG4gICAgICAgICAgICAgICEqKiogLi9zcmMvY29yZS9SZXN1bHRQb2ludC50cyAqKiohXHJcbiAgICAgICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgICAgICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xyXG4gICAgICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXHJcbiAgICAgICAgICAgIC8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbiAgICAgICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgICAgICAgICAgICAgIGV2YWwoXCJcXHJcXG4vKlxcclxcbiAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcXHJcXG4gKlxcclxcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcXFwiTGljZW5zZVxcXCIpO1xcclxcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cXHJcXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcXHJcXG4gKlxcclxcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXFxyXFxuICpcXHJcXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXFxyXFxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXFxcIkFTIElTXFxcIiBCQVNJUyxcXHJcXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cXHJcXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXFxyXFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXFxyXFxuICovXFxyXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcXHJcXG4vKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nIHsqL1xcclxcbnZhciBNYXRoVXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29tbW9uL2RldGVjdG9yL01hdGhVdGlscyAqLyBcXFwiLi9zcmMvY29yZS9jb21tb24vZGV0ZWN0b3IvTWF0aFV0aWxzLnRzXFxcIik7XFxyXFxudmFyIEZsb2F0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWwvRmxvYXQgKi8gXFxcIi4vc3JjL2NvcmUvdXRpbC9GbG9hdC50c1xcXCIpO1xcclxcbi8qKlxcclxcbiAqIDxwPkVuY2Fwc3VsYXRlcyBhIHBvaW50IG9mIGludGVyZXN0IGluIGFuIGltYWdlIGNvbnRhaW5pbmcgYSBiYXJjb2RlLiBUeXBpY2FsbHksIHRoaXNcXHJcXG4gKiB3b3VsZCBiZSB0aGUgbG9jYXRpb24gb2YgYSBmaW5kZXIgcGF0dGVybiBvciB0aGUgY29ybmVyIG9mIHRoZSBiYXJjb2RlLCBmb3IgZXhhbXBsZS48L3A+XFxyXFxuICpcXHJcXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxcclxcbiAqL1xcclxcbnZhciBSZXN1bHRQb2ludCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgZnVuY3Rpb24gUmVzdWx0UG9pbnQoeCwgeSkge1xcclxcbiAgICAgICAgdGhpcy54ID0geDtcXHJcXG4gICAgICAgIHRoaXMueSA9IHk7XFxyXFxuICAgIH1cXHJcXG4gICAgUmVzdWx0UG9pbnQucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICByZXR1cm4gdGhpcy54O1xcclxcbiAgICB9O1xcclxcbiAgICBSZXN1bHRQb2ludC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgIHJldHVybiB0aGlzLnk7XFxyXFxuICAgIH07XFxyXFxuICAgIC8qQE92ZXJyaWRlKi9cXHJcXG4gICAgUmVzdWx0UG9pbnQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvdGhlcikge1xcclxcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgUmVzdWx0UG9pbnQpIHtcXHJcXG4gICAgICAgICAgICB2YXIgb3RoZXJQb2ludCA9IG90aGVyO1xcclxcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnggPT09IG90aGVyUG9pbnQueCAmJiB0aGlzLnkgPT09IG90aGVyUG9pbnQueTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXHJcXG4gICAgfTtcXHJcXG4gICAgLypAT3ZlcnJpZGUqL1xcclxcbiAgICBSZXN1bHRQb2ludC5wcm90b3R5cGUuaGFzaENvZGUgPSBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICByZXR1cm4gMzEgKiBGbG9hdF8xLmRlZmF1bHQuZmxvYXRUb0ludEJpdHModGhpcy54KSArIEZsb2F0XzEuZGVmYXVsdC5mbG9hdFRvSW50Qml0cyh0aGlzLnkpO1xcclxcbiAgICB9O1xcclxcbiAgICAvKkBPdmVycmlkZSovXFxyXFxuICAgIFJlc3VsdFBvaW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgIHJldHVybiAnKCcgKyB0aGlzLnggKyAnLCcgKyB0aGlzLnkgKyAnKSc7XFxyXFxuICAgIH07XFxyXFxuICAgIC8qKlxcclxcbiAgICAgKiBPcmRlcnMgYW4gYXJyYXkgb2YgdGhyZWUgUmVzdWx0UG9pbnRzIGluIGFuIG9yZGVyIFtBLEIsQ10gc3VjaCB0aGF0IEFCIGlzIGxlc3MgdGhhbiBBQ1xcclxcbiAgICAgKiBhbmQgQkMgaXMgbGVzcyB0aGFuIEFDLCBhbmQgdGhlIGFuZ2xlIGJldHdlZW4gQkMgYW5kIEJBIGlzIGxlc3MgdGhhbiAxODAgZGVncmVlcy5cXHJcXG4gICAgICpcXHJcXG4gICAgICogQHBhcmFtIHBhdHRlcm5zIGFycmF5IG9mIHRocmVlIHtAY29kZSBSZXN1bHRQb2ludH0gdG8gb3JkZXJcXHJcXG4gICAgICovXFxyXFxuICAgIFJlc3VsdFBvaW50Lm9yZGVyQmVzdFBhdHRlcm5zID0gZnVuY3Rpb24gKHBhdHRlcm5zKSB7XFxyXFxuICAgICAgICAvLyBGaW5kIGRpc3RhbmNlcyBiZXR3ZWVuIHBhdHRlcm4gY2VudGVyc1xcclxcbiAgICAgICAgdmFyIHplcm9PbmVEaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2UocGF0dGVybnNbMF0sIHBhdHRlcm5zWzFdKTtcXHJcXG4gICAgICAgIHZhciBvbmVUd29EaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2UocGF0dGVybnNbMV0sIHBhdHRlcm5zWzJdKTtcXHJcXG4gICAgICAgIHZhciB6ZXJvVHdvRGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlKHBhdHRlcm5zWzBdLCBwYXR0ZXJuc1syXSk7XFxyXFxuICAgICAgICB2YXIgcG9pbnRBO1xcclxcbiAgICAgICAgdmFyIHBvaW50QjtcXHJcXG4gICAgICAgIHZhciBwb2ludEM7XFxyXFxuICAgICAgICAvLyBBc3N1bWUgb25lIGNsb3Nlc3QgdG8gb3RoZXIgdHdvIGlzIEI7IEEgYW5kIEMgd2lsbCBqdXN0IGJlIGd1ZXNzZXMgYXQgZmlyc3RcXHJcXG4gICAgICAgIGlmIChvbmVUd29EaXN0YW5jZSA+PSB6ZXJvT25lRGlzdGFuY2UgJiYgb25lVHdvRGlzdGFuY2UgPj0gemVyb1R3b0Rpc3RhbmNlKSB7XFxyXFxuICAgICAgICAgICAgcG9pbnRCID0gcGF0dGVybnNbMF07XFxyXFxuICAgICAgICAgICAgcG9pbnRBID0gcGF0dGVybnNbMV07XFxyXFxuICAgICAgICAgICAgcG9pbnRDID0gcGF0dGVybnNbMl07XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBlbHNlIGlmICh6ZXJvVHdvRGlzdGFuY2UgPj0gb25lVHdvRGlzdGFuY2UgJiYgemVyb1R3b0Rpc3RhbmNlID49IHplcm9PbmVEaXN0YW5jZSkge1xcclxcbiAgICAgICAgICAgIHBvaW50QiA9IHBhdHRlcm5zWzFdO1xcclxcbiAgICAgICAgICAgIHBvaW50QSA9IHBhdHRlcm5zWzBdO1xcclxcbiAgICAgICAgICAgIHBvaW50QyA9IHBhdHRlcm5zWzJdO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgZWxzZSB7XFxyXFxuICAgICAgICAgICAgcG9pbnRCID0gcGF0dGVybnNbMl07XFxyXFxuICAgICAgICAgICAgcG9pbnRBID0gcGF0dGVybnNbMF07XFxyXFxuICAgICAgICAgICAgcG9pbnRDID0gcGF0dGVybnNbMV07XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICAvLyBVc2UgY3Jvc3MgcHJvZHVjdCB0byBmaWd1cmUgb3V0IHdoZXRoZXIgQSBhbmQgQyBhcmUgY29ycmVjdCBvciBmbGlwcGVkLlxcclxcbiAgICAgICAgLy8gVGhpcyBhc2tzIHdoZXRoZXIgQkMgeCBCQSBoYXMgYSBwb3NpdGl2ZSB6IGNvbXBvbmVudCwgd2hpY2ggaXMgdGhlIGFycmFuZ2VtZW50XFxyXFxuICAgICAgICAvLyB3ZSB3YW50IGZvciBBLCBCLCBDLiBJZiBpdCdzIG5lZ2F0aXZlLCB0aGVuIHdlJ3ZlIGdvdCBpdCBmbGlwcGVkIGFyb3VuZCBhbmRcXHJcXG4gICAgICAgIC8vIHNob3VsZCBzd2FwIEEgYW5kIEMuXFxyXFxuICAgICAgICBpZiAodGhpcy5jcm9zc1Byb2R1Y3RaKHBvaW50QSwgcG9pbnRCLCBwb2ludEMpIDwgMC4wKSB7XFxyXFxuICAgICAgICAgICAgdmFyIHRlbXAgPSBwb2ludEE7XFxyXFxuICAgICAgICAgICAgcG9pbnRBID0gcG9pbnRDO1xcclxcbiAgICAgICAgICAgIHBvaW50QyA9IHRlbXA7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBwYXR0ZXJuc1swXSA9IHBvaW50QTtcXHJcXG4gICAgICAgIHBhdHRlcm5zWzFdID0gcG9pbnRCO1xcclxcbiAgICAgICAgcGF0dGVybnNbMl0gPSBwb2ludEM7XFxyXFxuICAgIH07XFxyXFxuICAgIC8qKlxcclxcbiAgICAgKiBAcGFyYW0gcGF0dGVybjEgZmlyc3QgcGF0dGVyblxcclxcbiAgICAgKiBAcGFyYW0gcGF0dGVybjIgc2Vjb25kIHBhdHRlcm5cXHJcXG4gICAgICogQHJldHVybiBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcXHJcXG4gICAgICovXFxyXFxuICAgIFJlc3VsdFBvaW50LmRpc3RhbmNlID0gZnVuY3Rpb24gKHBhdHRlcm4xLCBwYXR0ZXJuMikge1xcclxcbiAgICAgICAgcmV0dXJuIE1hdGhVdGlsc18xLmRlZmF1bHQuZGlzdGFuY2UocGF0dGVybjEueCwgcGF0dGVybjEueSwgcGF0dGVybjIueCwgcGF0dGVybjIueSk7XFxyXFxuICAgIH07XFxyXFxuICAgIC8qKlxcclxcbiAgICAgKiBSZXR1cm5zIHRoZSB6IGNvbXBvbmVudCBvZiB0aGUgY3Jvc3MgcHJvZHVjdCBiZXR3ZWVuIHZlY3RvcnMgQkMgYW5kIEJBLlxcclxcbiAgICAgKi9cXHJcXG4gICAgUmVzdWx0UG9pbnQuY3Jvc3NQcm9kdWN0WiA9IGZ1bmN0aW9uIChwb2ludEEsIHBvaW50QiwgcG9pbnRDKSB7XFxyXFxuICAgICAgICB2YXIgYlggPSBwb2ludEIueDtcXHJcXG4gICAgICAgIHZhciBiWSA9IHBvaW50Qi55O1xcclxcbiAgICAgICAgcmV0dXJuICgocG9pbnRDLnggLSBiWCkgKiAocG9pbnRBLnkgLSBiWSkpIC0gKChwb2ludEMueSAtIGJZKSAqIChwb2ludEEueCAtIGJYKSk7XFxyXFxuICAgIH07XFxyXFxuICAgIHJldHVybiBSZXN1bHRQb2ludDtcXHJcXG59KCkpO1xcclxcbmV4cG9ydHMuZGVmYXVsdCA9IFJlc3VsdFBvaW50O1xcclxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL09aU2VhbFJlY29nbml0aW9uLy4vc3JjL2NvcmUvUmVzdWx0UG9pbnQudHM/XCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKiovIH0pLFxyXG5cclxuICAgICAgICAgICAgLyoqKi8gXCIuL3NyYy9jb3JlL1Vuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uLnRzXCI6XHJcbiAgICAgICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcclxuICAgICAgICAgICAgICAhKioqIC4vc3JjL2NvcmUvVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24udHMgKioqIVxyXG4gICAgICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cclxuICAgICAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xyXG4gICAgICAgICAgICAvKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICAgICAgICAgICAgICBldmFsKFwiXFxyXFxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xcclxcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XFxyXFxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XFxyXFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxcclxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xcclxcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XFxyXFxuICAgIH07XFxyXFxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xcclxcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcXHJcXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxcclxcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xcclxcbiAgICB9O1xcclxcbn0pKCk7XFxyXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcXHJcXG52YXIgRXhjZXB0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL0V4Y2VwdGlvbiAqLyBcXFwiLi9zcmMvY29yZS9FeGNlcHRpb24udHNcXFwiKTtcXHJcXG4vKipcXHJcXG4gKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uXFxyXFxuICovXFxyXFxudmFyIFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xcclxcbiAgICBfX2V4dGVuZHMoVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24sIF9zdXBlcik7XFxyXFxuICAgIGZ1bmN0aW9uIFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uKCkge1xcclxcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbjtcXHJcXG59KEV4Y2VwdGlvbl8xLmRlZmF1bHQpKTtcXHJcXG5leHBvcnRzLmRlZmF1bHQgPSBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbjtcXHJcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9PWlNlYWxSZWNvZ25pdGlvbi8uL3NyYy9jb3JlL1Vuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uLnRzP1wiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKioqLyB9KSxcclxuXHJcbiAgICAgICAgICAgIC8qKiovIFwiLi9zcmMvY29yZS9jb21tb24vQ2hhcmFjdGVyU2V0RUNJLnRzXCI6XHJcbiAgICAgICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxyXG4gICAgICAgICAgICAgICEqKiogLi9zcmMvY29yZS9jb21tb24vQ2hhcmFjdGVyU2V0RUNJLnRzICoqKiFcclxuICAgICAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cclxuICAgICAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xyXG4gICAgICAgICAgICAvKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICAgICAgICAgICAgICBldmFsKFwiXFxyXFxuLypcXHJcXG4gKiBDb3B5cmlnaHQgMjAwOCBaWGluZyBhdXRob3JzXFxyXFxuICpcXHJcXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXFxcIkxpY2Vuc2VcXFwiKTtcXHJcXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXFxyXFxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XFxyXFxuICpcXHJcXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxcclxcbiAqXFxyXFxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxcclxcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFxcXCJBUyBJU1xcXCIgQkFTSVMsXFxyXFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXFxyXFxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxcclxcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxcclxcbiAqL1xcclxcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcXHJcXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XFxyXFxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xcclxcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFxcXCJudW1iZXJcXFwiKSByZXR1cm4ge1xcclxcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xcclxcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xcclxcbiAgICAgICAgfVxcclxcbiAgICB9O1xcclxcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcXFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cXFwiIDogXFxcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cXFwiKTtcXHJcXG59O1xcclxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHsgdmFsdWU6IHRydWUgfSk7XFxyXFxuZXhwb3J0cy5DaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzID0gdm9pZCAwO1xcclxcbi8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcuY29tbW9uIHsqL1xcclxcbnZhciBGb3JtYXRFeGNlcHRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL0Zvcm1hdEV4Y2VwdGlvbiAqLyBcXFwiLi9zcmMvY29yZS9Gb3JtYXRFeGNlcHRpb24udHNcXFwiKTtcXHJcXG4vKmltcG9ydCBqYXZhLnV0aWwuSGFzaE1hcDsqL1xcclxcbi8qaW1wb3J0IGphdmEudXRpbC5NYXA7Ki9cXHJcXG52YXIgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycztcXHJcXG4oZnVuY3Rpb24gKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMpIHtcXHJcXG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1xcXCJDcDQzN1xcXCJdID0gMF0gPSBcXFwiQ3A0MzdcXFwiO1xcclxcbiAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXFxcIklTTzg4NTlfMVxcXCJdID0gMV0gPSBcXFwiSVNPODg1OV8xXFxcIjtcXHJcXG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1xcXCJJU084ODU5XzJcXFwiXSA9IDJdID0gXFxcIklTTzg4NTlfMlxcXCI7XFxyXFxuICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcXFwiSVNPODg1OV8zXFxcIl0gPSAzXSA9IFxcXCJJU084ODU5XzNcXFwiO1xcclxcbiAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXFxcIklTTzg4NTlfNFxcXCJdID0gNF0gPSBcXFwiSVNPODg1OV80XFxcIjtcXHJcXG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1xcXCJJU084ODU5XzVcXFwiXSA9IDVdID0gXFxcIklTTzg4NTlfNVxcXCI7XFxyXFxuICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcXFwiSVNPODg1OV82XFxcIl0gPSA2XSA9IFxcXCJJU084ODU5XzZcXFwiO1xcclxcbiAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXFxcIklTTzg4NTlfN1xcXCJdID0gN10gPSBcXFwiSVNPODg1OV83XFxcIjtcXHJcXG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1xcXCJJU084ODU5XzhcXFwiXSA9IDhdID0gXFxcIklTTzg4NTlfOFxcXCI7XFxyXFxuICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcXFwiSVNPODg1OV85XFxcIl0gPSA5XSA9IFxcXCJJU084ODU5XzlcXFwiO1xcclxcbiAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXFxcIklTTzg4NTlfMTBcXFwiXSA9IDEwXSA9IFxcXCJJU084ODU5XzEwXFxcIjtcXHJcXG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1xcXCJJU084ODU5XzExXFxcIl0gPSAxMV0gPSBcXFwiSVNPODg1OV8xMVxcXCI7XFxyXFxuICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcXFwiSVNPODg1OV8xM1xcXCJdID0gMTJdID0gXFxcIklTTzg4NTlfMTNcXFwiO1xcclxcbiAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXFxcIklTTzg4NTlfMTRcXFwiXSA9IDEzXSA9IFxcXCJJU084ODU5XzE0XFxcIjtcXHJcXG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1xcXCJJU084ODU5XzE1XFxcIl0gPSAxNF0gPSBcXFwiSVNPODg1OV8xNVxcXCI7XFxyXFxuICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcXFwiSVNPODg1OV8xNlxcXCJdID0gMTVdID0gXFxcIklTTzg4NTlfMTZcXFwiO1xcclxcbiAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXFxcIlNKSVNcXFwiXSA9IDE2XSA9IFxcXCJTSklTXFxcIjtcXHJcXG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1xcXCJDcDEyNTBcXFwiXSA9IDE3XSA9IFxcXCJDcDEyNTBcXFwiO1xcclxcbiAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXFxcIkNwMTI1MVxcXCJdID0gMThdID0gXFxcIkNwMTI1MVxcXCI7XFxyXFxuICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcXFwiQ3AxMjUyXFxcIl0gPSAxOV0gPSBcXFwiQ3AxMjUyXFxcIjtcXHJcXG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1xcXCJDcDEyNTZcXFwiXSA9IDIwXSA9IFxcXCJDcDEyNTZcXFwiO1xcclxcbiAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXFxcIlVuaWNvZGVCaWdVbm1hcmtlZFxcXCJdID0gMjFdID0gXFxcIlVuaWNvZGVCaWdVbm1hcmtlZFxcXCI7XFxyXFxuICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcXFwiVVRGOFxcXCJdID0gMjJdID0gXFxcIlVURjhcXFwiO1xcclxcbiAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXFxcIkFTQ0lJXFxcIl0gPSAyM10gPSBcXFwiQVNDSUlcXFwiO1xcclxcbiAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXFxcIkJpZzVcXFwiXSA9IDI0XSA9IFxcXCJCaWc1XFxcIjtcXHJcXG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1xcXCJHQjE4MDMwXFxcIl0gPSAyNV0gPSBcXFwiR0IxODAzMFxcXCI7XFxyXFxuICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcXFwiRVVDX0tSXFxcIl0gPSAyNl0gPSBcXFwiRVVDX0tSXFxcIjtcXHJcXG59KShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzID0gZXhwb3J0cy5DaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzIHx8IChleHBvcnRzLkNoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMgPSB7fSkpO1xcclxcbi8qKlxcclxcbiAqIEVuY2Fwc3VsYXRlcyBhIENoYXJhY3RlciBTZXQgRUNJLCBhY2NvcmRpbmcgdG8gXFxcIkV4dGVuZGVkIENoYW5uZWwgSW50ZXJwcmV0YXRpb25zXFxcIiA1LjMuMS4xXFxyXFxuICogb2YgSVNPIDE4MDA0LlxcclxcbiAqXFxyXFxuICogQGF1dGhvciBTZWFuIE93ZW5cXHJcXG4gKi9cXHJcXG52YXIgQ2hhcmFjdGVyU2V0RUNJID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xcclxcbiAgICBmdW5jdGlvbiBDaGFyYWN0ZXJTZXRFQ0kodmFsdWVJZGVudGlmaWVyLCB2YWx1ZXNQYXJhbSwgbmFtZSkge1xcclxcbiAgICAgICAgdmFyIGVfMSwgX2E7XFxyXFxuICAgICAgICB2YXIgb3RoZXJFbmNvZGluZ05hbWVzID0gW107XFxyXFxuICAgICAgICBmb3IgKHZhciBfaSA9IDM7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xcclxcbiAgICAgICAgICAgIG90aGVyRW5jb2RpbmdOYW1lc1tfaSAtIDNdID0gYXJndW1lbnRzW19pXTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHRoaXMudmFsdWVJZGVudGlmaWVyID0gdmFsdWVJZGVudGlmaWVyO1xcclxcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcXHJcXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWVzUGFyYW0gPT09ICdudW1iZXInKSB7XFxyXFxuICAgICAgICAgICAgdGhpcy52YWx1ZXMgPSBJbnQzMkFycmF5LmZyb20oW3ZhbHVlc1BhcmFtXSk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBlbHNlIHtcXHJcXG4gICAgICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlc1BhcmFtO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgdGhpcy5vdGhlckVuY29kaW5nTmFtZXMgPSBvdGhlckVuY29kaW5nTmFtZXM7XFxyXFxuICAgICAgICBDaGFyYWN0ZXJTZXRFQ0kuVkFMVUVfSURFTlRJRklFUl9UT19FQ0kuc2V0KHZhbHVlSWRlbnRpZmllciwgdGhpcyk7XFxyXFxuICAgICAgICBDaGFyYWN0ZXJTZXRFQ0kuTkFNRV9UT19FQ0kuc2V0KG5hbWUsIHRoaXMpO1xcclxcbiAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xcclxcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aF8xID0gdmFsdWVzLmxlbmd0aDsgaSAhPT0gbGVuZ3RoXzE7IGkrKykge1xcclxcbiAgICAgICAgICAgIHZhciB2ID0gdmFsdWVzW2ldO1xcclxcbiAgICAgICAgICAgIENoYXJhY3RlclNldEVDSS5WQUxVRVNfVE9fRUNJLnNldCh2LCB0aGlzKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHRyeSB7XFxyXFxuICAgICAgICAgICAgZm9yICh2YXIgb3RoZXJFbmNvZGluZ05hbWVzXzEgPSBfX3ZhbHVlcyhvdGhlckVuY29kaW5nTmFtZXMpLCBvdGhlckVuY29kaW5nTmFtZXNfMV8xID0gb3RoZXJFbmNvZGluZ05hbWVzXzEubmV4dCgpOyAhb3RoZXJFbmNvZGluZ05hbWVzXzFfMS5kb25lOyBvdGhlckVuY29kaW5nTmFtZXNfMV8xID0gb3RoZXJFbmNvZGluZ05hbWVzXzEubmV4dCgpKSB7XFxyXFxuICAgICAgICAgICAgICAgIHZhciBvdGhlck5hbWUgPSBvdGhlckVuY29kaW5nTmFtZXNfMV8xLnZhbHVlO1xcclxcbiAgICAgICAgICAgICAgICBDaGFyYWN0ZXJTZXRFQ0kuTkFNRV9UT19FQ0kuc2V0KG90aGVyTmFtZSwgdGhpcyk7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cXHJcXG4gICAgICAgIGZpbmFsbHkge1xcclxcbiAgICAgICAgICAgIHRyeSB7XFxyXFxuICAgICAgICAgICAgICAgIGlmIChvdGhlckVuY29kaW5nTmFtZXNfMV8xICYmICFvdGhlckVuY29kaW5nTmFtZXNfMV8xLmRvbmUgJiYgKF9hID0gb3RoZXJFbmNvZGluZ05hbWVzXzEucmV0dXJuKSkgX2EuY2FsbChvdGhlckVuY29kaW5nTmFtZXNfMSk7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICAvLyBDaGFyYWN0ZXJTZXRFQ0kodmFsdWU6IG51bWJlciAvKmludCovKSB7XFxyXFxuICAgIC8vICAgdGhpcyhuZXcgSW50MzJBcnJheSB7dmFsdWV9KVxcclxcbiAgICAvLyB9XFxyXFxuICAgIC8vIENoYXJhY3RlclNldEVDSSh2YWx1ZTogbnVtYmVyIC8qaW50Ki8sIFN0cmluZy4uLiBvdGhlckVuY29kaW5nTmFtZXMpIHtcXHJcXG4gICAgLy8gICB0aGlzLnZhbHVlcyA9IG5ldyBJbnQzMkFycmF5IHt2YWx1ZX1cXHJcXG4gICAgLy8gICB0aGlzLm90aGVyRW5jb2RpbmdOYW1lcyA9IG90aGVyRW5jb2RpbmdOYW1lc1xcclxcbiAgICAvLyB9XFxyXFxuICAgIC8vIENoYXJhY3RlclNldEVDSSh2YWx1ZXM6IEludDMyQXJyYXksIFN0cmluZy4uLiBvdGhlckVuY29kaW5nTmFtZXMpIHtcXHJcXG4gICAgLy8gICB0aGlzLnZhbHVlcyA9IHZhbHVlc1xcclxcbiAgICAvLyAgIHRoaXMub3RoZXJFbmNvZGluZ05hbWVzID0gb3RoZXJFbmNvZGluZ05hbWVzXFxyXFxuICAgIC8vIH1cXHJcXG4gICAgQ2hhcmFjdGVyU2V0RUNJLnByb3RvdHlwZS5nZXRWYWx1ZUlkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZUlkZW50aWZpZXI7XFxyXFxuICAgIH07XFxyXFxuICAgIENoYXJhY3RlclNldEVDSS5wcm90b3R5cGUuZ2V0TmFtZSA9IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XFxyXFxuICAgIH07XFxyXFxuICAgIENoYXJhY3RlclNldEVDSS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXNbMF07XFxyXFxuICAgIH07XFxyXFxuICAgIC8qKlxcclxcbiAgICAgKiBAcGFyYW0gdmFsdWUgY2hhcmFjdGVyIHNldCBFQ0kgdmFsdWVcXHJcXG4gICAgICogQHJldHVybiB7QGNvZGUgQ2hhcmFjdGVyU2V0RUNJfSByZXByZXNlbnRpbmcgRUNJIG9mIGdpdmVuIHZhbHVlLCBvciBudWxsIGlmIGl0IGlzIGxlZ2FsIGJ1dFxcclxcbiAgICAgKiAgIHVuc3VwcG9ydGVkXFxyXFxuICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIEVDSSB2YWx1ZSBpcyBpbnZhbGlkXFxyXFxuICAgICAqL1xcclxcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuZ2V0Q2hhcmFjdGVyU2V0RUNJQnlWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSAvKmludCovKSB7XFxyXFxuICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID49IDkwMCkge1xcclxcbiAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCdpbmNvcmVjdCB2YWx1ZScpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgdmFyIGNoYXJhY3RlclNldCA9IENoYXJhY3RlclNldEVDSS5WQUxVRVNfVE9fRUNJLmdldCh2YWx1ZSk7XFxyXFxuICAgICAgICBpZiAodW5kZWZpbmVkID09PSBjaGFyYWN0ZXJTZXQpIHtcXHJcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgnaW5jb3JlY3QgdmFsdWUnKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHJldHVybiBjaGFyYWN0ZXJTZXQ7XFxyXFxuICAgIH07XFxyXFxuICAgIC8qKlxcclxcbiAgICAgKiBAcGFyYW0gbmFtZSBjaGFyYWN0ZXIgc2V0IEVDSSBlbmNvZGluZyBuYW1lXFxyXFxuICAgICAqIEByZXR1cm4gQ2hhcmFjdGVyU2V0RUNJIHJlcHJlc2VudGluZyBFQ0kgZm9yIGNoYXJhY3RlciBlbmNvZGluZywgb3IgbnVsbCBpZiBpdCBpcyBsZWdhbFxcclxcbiAgICAgKiAgIGJ1dCB1bnN1cHBvcnRlZFxcclxcbiAgICAgKi9cXHJcXG4gICAgQ2hhcmFjdGVyU2V0RUNJLmdldENoYXJhY3RlclNldEVDSUJ5TmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XFxyXFxuICAgICAgICB2YXIgY2hhcmFjdGVyU2V0ID0gQ2hhcmFjdGVyU2V0RUNJLk5BTUVfVE9fRUNJLmdldChuYW1lKTtcXHJcXG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IGNoYXJhY3RlclNldCkge1xcclxcbiAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCdpbmNvcmVjdCB2YWx1ZScpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgcmV0dXJuIGNoYXJhY3RlclNldDtcXHJcXG4gICAgfTtcXHJcXG4gICAgQ2hhcmFjdGVyU2V0RUNJLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAobykge1xcclxcbiAgICAgICAgaWYgKCEobyBpbnN0YW5jZW9mIENoYXJhY3RlclNldEVDSSkpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICB2YXIgb3RoZXIgPSBvO1xcclxcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TmFtZSgpID09PSBvdGhlci5nZXROYW1lKCk7XFxyXFxuICAgIH07XFxyXFxuICAgIENoYXJhY3RlclNldEVDSS5WQUxVRV9JREVOVElGSUVSX1RPX0VDSSA9IG5ldyBNYXAoKTtcXHJcXG4gICAgQ2hhcmFjdGVyU2V0RUNJLlZBTFVFU19UT19FQ0kgPSBuZXcgTWFwKCk7XFxyXFxuICAgIENoYXJhY3RlclNldEVDSS5OQU1FX1RPX0VDSSA9IG5ldyBNYXAoKTtcXHJcXG4gICAgLy8gRW51bSBuYW1lIGlzIGEgSmF2YSBlbmNvZGluZyB2YWxpZCBmb3IgamF2YS5sYW5nIGFuZCBqYXZhLmlvXFxyXFxuICAgIC8vIFRZUEVTQ1JJUFRQT1JUOiBjaGFuZ2VkIHRoZSBtYWluIGxhYmVsIGZvciBJU08gYXMgdGhlIFRleHRFbmNvZGVyIGRpZCBub3QgcmVjb2duaXplZCB0aGVtIGluIHRoZSBmb3JtIGZyb20gamF2YVxcclxcbiAgICAvLyAoZWcgSVNPODg1OV8xIG11c3QgYmUgSVNPODg1OTEgb3IgSVNPODg1OS0xIG9yIElTTy04ODU5LTEpXFxyXFxuICAgIC8vIGxhdGVyIG9uOiB3ZWxsLCBleGNlcHQgMTYgd2ljaCBkb2VzIG5vdCB3b3JrIHdpdGggSVNPODg1OTE2IHNvIHVzZWQgSVNPLTg4NTktMSBmb3JtIGZvciBkZWZhdWx0XFxyXFxuICAgIENoYXJhY3RlclNldEVDSS5DcDQzNyA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5DcDQzNywgSW50MzJBcnJheS5mcm9tKFswLCAyXSksICdDcDQzNycpO1xcclxcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8xID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfMSwgSW50MzJBcnJheS5mcm9tKFsxLCAzXSksICdJU08tODg1OS0xJywgJ0lTTzg4NTkxJywgJ0lTTzg4NTlfMScpO1xcclxcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8yID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfMiwgNCwgJ0lTTy04ODU5LTInLCAnSVNPODg1OTInLCAnSVNPODg1OV8yJyk7XFxyXFxuICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzMgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV8zLCA1LCAnSVNPLTg4NTktMycsICdJU084ODU5MycsICdJU084ODU5XzMnKTtcXHJcXG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfNCA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzQsIDYsICdJU08tODg1OS00JywgJ0lTTzg4NTk0JywgJ0lTTzg4NTlfNCcpO1xcclxcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV81ID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfNSwgNywgJ0lTTy04ODU5LTUnLCAnSVNPODg1OTUnLCAnSVNPODg1OV81Jyk7XFxyXFxuICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzYgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV82LCA4LCAnSVNPLTg4NTktNicsICdJU084ODU5NicsICdJU084ODU5XzYnKTtcXHJcXG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfNyA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzcsIDksICdJU08tODg1OS03JywgJ0lTTzg4NTk3JywgJ0lTTzg4NTlfNycpO1xcclxcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV84ID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfOCwgMTAsICdJU08tODg1OS04JywgJ0lTTzg4NTk4JywgJ0lTTzg4NTlfOCcpO1xcclxcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV85ID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfOSwgMTEsICdJU08tODg1OS05JywgJ0lTTzg4NTk5JywgJ0lTTzg4NTlfOScpO1xcclxcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8xMCA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzEwLCAxMiwgJ0lTTy04ODU5LTEwJywgJ0lTTzg4NTkxMCcsICdJU084ODU5XzEwJyk7XFxyXFxuICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzExID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfMTEsIDEzLCAnSVNPLTg4NTktMTEnLCAnSVNPODg1OTExJywgJ0lTTzg4NTlfMTEnKTtcXHJcXG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfMTMgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV8xMywgMTUsICdJU08tODg1OS0xMycsICdJU084ODU5MTMnLCAnSVNPODg1OV8xMycpO1xcclxcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8xNCA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzE0LCAxNiwgJ0lTTy04ODU5LTE0JywgJ0lTTzg4NTkxNCcsICdJU084ODU5XzE0Jyk7XFxyXFxuICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzE1ID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfMTUsIDE3LCAnSVNPLTg4NTktMTUnLCAnSVNPODg1OTE1JywgJ0lTTzg4NTlfMTUnKTtcXHJcXG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfMTYgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV8xNiwgMTgsICdJU08tODg1OS0xNicsICdJU084ODU5MTYnLCAnSVNPODg1OV8xNicpO1xcclxcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuU0pJUyA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5TSklTLCAyMCwgJ1NKSVMnLCAnU2hpZnRfSklTJyk7XFxyXFxuICAgIENoYXJhY3RlclNldEVDSS5DcDEyNTAgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuQ3AxMjUwLCAyMSwgJ0NwMTI1MCcsICd3aW5kb3dzLTEyNTAnKTtcXHJcXG4gICAgQ2hhcmFjdGVyU2V0RUNJLkNwMTI1MSA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5DcDEyNTEsIDIyLCAnQ3AxMjUxJywgJ3dpbmRvd3MtMTI1MScpO1xcclxcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuQ3AxMjUyID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLkNwMTI1MiwgMjMsICdDcDEyNTInLCAnd2luZG93cy0xMjUyJyk7XFxyXFxuICAgIENoYXJhY3RlclNldEVDSS5DcDEyNTYgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuQ3AxMjU2LCAyNCwgJ0NwMTI1NicsICd3aW5kb3dzLTEyNTYnKTtcXHJcXG4gICAgQ2hhcmFjdGVyU2V0RUNJLlVuaWNvZGVCaWdVbm1hcmtlZCA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5Vbmljb2RlQmlnVW5tYXJrZWQsIDI1LCAnVW5pY29kZUJpZ1VubWFya2VkJywgJ1VURi0xNkJFJywgJ1VuaWNvZGVCaWcnKTtcXHJcXG4gICAgQ2hhcmFjdGVyU2V0RUNJLlVURjggPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuVVRGOCwgMjYsICdVVEY4JywgJ1VURi04Jyk7XFxyXFxuICAgIENoYXJhY3RlclNldEVDSS5BU0NJSSA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5BU0NJSSwgSW50MzJBcnJheS5mcm9tKFsyNywgMTcwXSksICdBU0NJSScsICdVUy1BU0NJSScpO1xcclxcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuQmlnNSA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5CaWc1LCAyOCwgJ0JpZzUnKTtcXHJcXG4gICAgQ2hhcmFjdGVyU2V0RUNJLkdCMTgwMzAgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuR0IxODAzMCwgMjksICdHQjE4MDMwJywgJ0dCMjMxMicsICdFVUNfQ04nLCAnR0JLJyk7XFxyXFxuICAgIENoYXJhY3RlclNldEVDSS5FVUNfS1IgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuRVVDX0tSLCAzMCwgJ0VVQ19LUicsICdFVUMtS1InKTtcXHJcXG4gICAgcmV0dXJuIENoYXJhY3RlclNldEVDSTtcXHJcXG59KCkpO1xcclxcbmV4cG9ydHMuZGVmYXVsdCA9IENoYXJhY3RlclNldEVDSTtcXHJcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9PWlNlYWxSZWNvZ25pdGlvbi8uL3NyYy9jb3JlL2NvbW1vbi9DaGFyYWN0ZXJTZXRFQ0kudHM/XCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKiovIH0pLFxyXG5cclxuICAgICAgICAgICAgLyoqKi8gXCIuL3NyYy9jb3JlL2NvbW1vbi9TdHJpbmdVdGlscy50c1wiOlxyXG4gICAgICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxyXG4gICAgICAgICAgICAgICEqKiogLi9zcmMvY29yZS9jb21tb24vU3RyaW5nVXRpbHMudHMgKioqIVxyXG4gICAgICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuICAgICAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXHJcbiAgICAgICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cclxuICAgICAgICAgICAgLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuICAgICAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgICAgICAgICAgICAgZXZhbChcIlxcclxcbi8qXFxyXFxuICogQ29weXJpZ2h0IChDKSAyMDEwIFpYaW5nIGF1dGhvcnNcXHJcXG4gKlxcclxcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcXFwiTGljZW5zZVxcXCIpO1xcclxcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cXHJcXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcXHJcXG4gKlxcclxcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXFxyXFxuICpcXHJcXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXFxyXFxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXFxcIkFTIElTXFxcIiBCQVNJUyxcXHJcXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cXHJcXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXFxyXFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXFxyXFxuICovXFxyXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcXHJcXG4vKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nLmNvbW1vbiB7Ki9cXHJcXG4vKmltcG9ydCBqYXZhLm5pby5jaGFyc2V0LkNoYXJzZXQ7Ki9cXHJcXG4vKmltcG9ydCBqYXZhLnV0aWwuTWFwOyovXFxyXFxudmFyIERlY29kZUhpbnRUeXBlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9EZWNvZGVIaW50VHlwZSAqLyBcXFwiLi9zcmMvY29yZS9EZWNvZGVIaW50VHlwZS50c1xcXCIpO1xcclxcbnZhciBDaGFyYWN0ZXJTZXRFQ0lfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vQ2hhcmFjdGVyU2V0RUNJICovIFxcXCIuL3NyYy9jb3JlL2NvbW1vbi9DaGFyYWN0ZXJTZXRFQ0kudHNcXFwiKTtcXHJcXG52YXIgU3RyaW5nRW5jb2RpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvU3RyaW5nRW5jb2RpbmcgKi8gXFxcIi4vc3JjL2NvcmUvdXRpbC9TdHJpbmdFbmNvZGluZy50c1xcXCIpO1xcclxcbi8qKlxcclxcbiAqIENvbW1vbiBzdHJpbmctcmVsYXRlZCBmdW5jdGlvbnMuXFxyXFxuICpcXHJcXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxcclxcbiAqIEBhdXRob3IgQWxleCBEdXByZVxcclxcbiAqL1xcclxcbnZhciBTdHJpbmdVdGlscyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgZnVuY3Rpb24gU3RyaW5nVXRpbHMoKSB7XFxyXFxuICAgIH1cXHJcXG4gICAgLy8gU0hJRlRfSklTLmVxdWFsc0lnbm9yZUNhc2UoUExBVEZPUk1fREVGQVVMVF9FTkNPRElORykgfHxcXHJcXG4gICAgLy8gRVVDX0pQLmVxdWFsc0lnbm9yZUNhc2UoUExBVEZPUk1fREVGQVVMVF9FTkNPRElORyk7XFxyXFxuICAgIFN0cmluZ1V0aWxzLmNhc3RBc05vblV0ZjhDaGFyID0gZnVuY3Rpb24gKGNvZGUsIGVuY29kaW5nKSB7XFxyXFxuICAgICAgICBpZiAoZW5jb2RpbmcgPT09IHZvaWQgMCkgeyBlbmNvZGluZyA9IG51bGw7IH1cXHJcXG4gICAgICAgIC8vIElTTyA4ODU5LTEgaXMgdGhlIEphdmEgZGVmYXVsdCBhcyBVVEYtOCBpcyBKYXZhU2NyaXB0c1xcclxcbiAgICAgICAgLy8geW91IGNhbiBzZWUgdGhpcyBtZXRob2QgYXMgYSBKYXZhIHZlcnNpb24gb2YgU3RyaW5nLmZyb21DaGFyQ29kZVxcclxcbiAgICAgICAgdmFyIGUgPSBlbmNvZGluZyA/IGVuY29kaW5nLmdldE5hbWUoKSA6IHRoaXMuSVNPODg1OTE7XFxyXFxuICAgICAgICAvLyB1c2UgcGFzc2VkIGZvcm1hdCAoZnJvbUNoYXJDb2RlIHdpbGwgcmV0dXJuIFVURjggZW5jb2RpbmcpXFxyXFxuICAgICAgICByZXR1cm4gU3RyaW5nRW5jb2RpbmdfMS5kZWZhdWx0LmRlY29kZShuZXcgVWludDhBcnJheShbY29kZV0pLCBlKTtcXHJcXG4gICAgfTtcXHJcXG4gICAgLyoqXFxyXFxuICAgICAqIEBwYXJhbSBieXRlcyBieXRlcyBlbmNvZGluZyBhIHN0cmluZywgd2hvc2UgZW5jb2Rpbmcgc2hvdWxkIGJlIGd1ZXNzZWRcXHJcXG4gICAgICogQHBhcmFtIGhpbnRzIGRlY29kZSBoaW50cyBpZiBhcHBsaWNhYmxlXFxyXFxuICAgICAqIEByZXR1cm4gbmFtZSBvZiBndWVzc2VkIGVuY29kaW5nOyBhdCB0aGUgbW9tZW50IHdpbGwgb25seSBndWVzcyBvbmUgb2Y6XFxyXFxuICAgICAqICB7QGxpbmsgI1NISUZUX0pJU30sIHtAbGluayAjVVRGOH0sIHtAbGluayAjSVNPODg1OTF9LCBvciB0aGUgcGxhdGZvcm1cXHJcXG4gICAgICogIGRlZmF1bHQgZW5jb2RpbmcgaWYgbm9uZSBvZiB0aGVzZSBjYW4gcG9zc2libHkgYmUgY29ycmVjdFxcclxcbiAgICAgKi9cXHJcXG4gICAgU3RyaW5nVXRpbHMuZ3Vlc3NFbmNvZGluZyA9IGZ1bmN0aW9uIChieXRlcywgaGludHMpIHtcXHJcXG4gICAgICAgIGlmIChoaW50cyAhPT0gbnVsbCAmJiBoaW50cyAhPT0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZCAhPT0gaGludHMuZ2V0KERlY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5DSEFSQUNURVJfU0VUKSkge1xcclxcbiAgICAgICAgICAgIHJldHVybiBoaW50cy5nZXQoRGVjb2RlSGludFR5cGVfMS5kZWZhdWx0LkNIQVJBQ1RFUl9TRVQpLnRvU3RyaW5nKCk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICAvLyBGb3Igbm93LCBtZXJlbHkgdHJpZXMgdG8gZGlzdGluZ3Vpc2ggSVNPLTg4NTktMSwgVVRGLTggYW5kIFNoaWZ0X0pJUyxcXHJcXG4gICAgICAgIC8vIHdoaWNoIHNob3VsZCBiZSBieSBmYXIgdGhlIG1vc3QgY29tbW9uIGVuY29kaW5ncy5cXHJcXG4gICAgICAgIHZhciBsZW5ndGggPSBieXRlcy5sZW5ndGg7XFxyXFxuICAgICAgICB2YXIgY2FuQmVJU084ODU5MSA9IHRydWU7XFxyXFxuICAgICAgICB2YXIgY2FuQmVTaGlmdEpJUyA9IHRydWU7XFxyXFxuICAgICAgICB2YXIgY2FuQmVVVEY4ID0gdHJ1ZTtcXHJcXG4gICAgICAgIHZhciB1dGY4Qnl0ZXNMZWZ0ID0gMDtcXHJcXG4gICAgICAgIC8vIGludCB1dGY4TG93Q2hhcnMgPSAwXFxyXFxuICAgICAgICB2YXIgdXRmMkJ5dGVzQ2hhcnMgPSAwO1xcclxcbiAgICAgICAgdmFyIHV0ZjNCeXRlc0NoYXJzID0gMDtcXHJcXG4gICAgICAgIHZhciB1dGY0Qnl0ZXNDaGFycyA9IDA7XFxyXFxuICAgICAgICB2YXIgc2ppc0J5dGVzTGVmdCA9IDA7XFxyXFxuICAgICAgICAvLyBpbnQgc2ppc0xvd0NoYXJzID0gMFxcclxcbiAgICAgICAgdmFyIHNqaXNLYXRha2FuYUNoYXJzID0gMDtcXHJcXG4gICAgICAgIC8vIGludCBzamlzRG91YmxlQnl0ZXNDaGFycyA9IDBcXHJcXG4gICAgICAgIHZhciBzamlzQ3VyS2F0YWthbmFXb3JkTGVuZ3RoID0gMDtcXHJcXG4gICAgICAgIHZhciBzamlzQ3VyRG91YmxlQnl0ZXNXb3JkTGVuZ3RoID0gMDtcXHJcXG4gICAgICAgIHZhciBzamlzTWF4S2F0YWthbmFXb3JkTGVuZ3RoID0gMDtcXHJcXG4gICAgICAgIHZhciBzamlzTWF4RG91YmxlQnl0ZXNXb3JkTGVuZ3RoID0gMDtcXHJcXG4gICAgICAgIC8vIGludCBpc29Mb3dDaGFycyA9IDBcXHJcXG4gICAgICAgIC8vIGludCBpc29IaWdoQ2hhcnMgPSAwXFxyXFxuICAgICAgICB2YXIgaXNvSGlnaE90aGVyID0gMDtcXHJcXG4gICAgICAgIHZhciB1dGY4Ym9tID0gYnl0ZXMubGVuZ3RoID4gMyAmJlxcclxcbiAgICAgICAgICAgIGJ5dGVzWzBdID09PSAvKihieXRlKSAqLyAweEVGICYmXFxyXFxuICAgICAgICAgICAgYnl0ZXNbMV0gPT09IC8qKGJ5dGUpICovIDB4QkIgJiZcXHJcXG4gICAgICAgICAgICBieXRlc1syXSA9PT0gLyooYnl0ZSkgKi8gMHhCRjtcXHJcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoICYmIChjYW5CZUlTTzg4NTkxIHx8IGNhbkJlU2hpZnRKSVMgfHwgY2FuQmVVVEY4KTsgaSsrKSB7XFxyXFxuICAgICAgICAgICAgdmFyIHZhbHVlID0gYnl0ZXNbaV0gJiAweEZGO1xcclxcbiAgICAgICAgICAgIC8vIFVURi04IHN0dWZmXFxyXFxuICAgICAgICAgICAgaWYgKGNhbkJlVVRGOCkge1xcclxcbiAgICAgICAgICAgICAgICBpZiAodXRmOEJ5dGVzTGVmdCA+IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICgodmFsdWUgJiAweDgwKSA9PT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbkJlVVRGOCA9IGZhbHNlO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdXRmOEJ5dGVzTGVmdC0tO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCh2YWx1ZSAmIDB4ODApICE9PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAoKHZhbHVlICYgMHg0MCkgPT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5CZVVURjggPSBmYWxzZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjhCeXRlc0xlZnQrKztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHZhbHVlICYgMHgyMCkgPT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRmMkJ5dGVzQ2hhcnMrKztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjhCeXRlc0xlZnQrKztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSAmIDB4MTApID09PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGYzQnl0ZXNDaGFycysrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRmOEJ5dGVzTGVmdCsrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSAmIDB4MDgpID09PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRmNEJ5dGVzQ2hhcnMrKztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbkJlVVRGOCA9IGZhbHNlO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICB9IC8vIGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAvLyB1dGY4TG93Q2hhcnMrK1xcclxcbiAgICAgICAgICAgICAgICAvLyB9XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIC8vIElTTy04ODU5LTEgc3R1ZmZcXHJcXG4gICAgICAgICAgICBpZiAoY2FuQmVJU084ODU5MSkge1xcclxcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiAweDdGICYmIHZhbHVlIDwgMHhBMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgY2FuQmVJU084ODU5MSA9IGZhbHNlO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID4gMHg5Rikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgMHhDMCB8fCB2YWx1ZSA9PT0gMHhENyB8fCB2YWx1ZSA9PT0gMHhGNykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzb0hpZ2hPdGhlcisrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfSAvLyBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzb0hpZ2hDaGFycysrXFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyB9XFxyXFxuICAgICAgICAgICAgICAgIH0gLy8gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgIC8vIGlzb0xvd0NoYXJzKytcXHJcXG4gICAgICAgICAgICAgICAgLy8gfVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAvLyBTaGlmdF9KSVMgc3R1ZmZcXHJcXG4gICAgICAgICAgICBpZiAoY2FuQmVTaGlmdEpJUykge1xcclxcbiAgICAgICAgICAgICAgICBpZiAoc2ppc0J5dGVzTGVmdCA+IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IDB4NDAgfHwgdmFsdWUgPT09IDB4N0YgfHwgdmFsdWUgPiAweEZDKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FuQmVTaGlmdEpJUyA9IGZhbHNlO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgc2ppc0J5dGVzTGVmdC0tO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSAweDgwIHx8IHZhbHVlID09PSAweEEwIHx8IHZhbHVlID4gMHhFRikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgY2FuQmVTaGlmdEpJUyA9IGZhbHNlO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID4gMHhBMCAmJiB2YWx1ZSA8IDB4RTApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHNqaXNLYXRha2FuYUNoYXJzKys7XFxyXFxuICAgICAgICAgICAgICAgICAgICBzamlzQ3VyRG91YmxlQnl0ZXNXb3JkTGVuZ3RoID0gMDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHNqaXNDdXJLYXRha2FuYVdvcmRMZW5ndGgrKztcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChzamlzQ3VyS2F0YWthbmFXb3JkTGVuZ3RoID4gc2ppc01heEthdGFrYW5hV29yZExlbmd0aCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNqaXNNYXhLYXRha2FuYVdvcmRMZW5ndGggPSBzamlzQ3VyS2F0YWthbmFXb3JkTGVuZ3RoO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID4gMHg3Rikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgc2ppc0J5dGVzTGVmdCsrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gc2ppc0RvdWJsZUJ5dGVzQ2hhcnMrK1xcclxcbiAgICAgICAgICAgICAgICAgICAgc2ppc0N1ckthdGFrYW5hV29yZExlbmd0aCA9IDA7XFxyXFxuICAgICAgICAgICAgICAgICAgICBzamlzQ3VyRG91YmxlQnl0ZXNXb3JkTGVuZ3RoKys7XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAoc2ppc0N1ckRvdWJsZUJ5dGVzV29yZExlbmd0aCA+IHNqaXNNYXhEb3VibGVCeXRlc1dvcmRMZW5ndGgpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBzamlzTWF4RG91YmxlQnl0ZXNXb3JkTGVuZ3RoID0gc2ppc0N1ckRvdWJsZUJ5dGVzV29yZExlbmd0aDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIHNqaXNMb3dDaGFycysrXFxyXFxuICAgICAgICAgICAgICAgICAgICBzamlzQ3VyS2F0YWthbmFXb3JkTGVuZ3RoID0gMDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHNqaXNDdXJEb3VibGVCeXRlc1dvcmRMZW5ndGggPSAwO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgaWYgKGNhbkJlVVRGOCAmJiB1dGY4Qnl0ZXNMZWZ0ID4gMCkge1xcclxcbiAgICAgICAgICAgIGNhbkJlVVRGOCA9IGZhbHNlO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgaWYgKGNhbkJlU2hpZnRKSVMgJiYgc2ppc0J5dGVzTGVmdCA+IDApIHtcXHJcXG4gICAgICAgICAgICBjYW5CZVNoaWZ0SklTID0gZmFsc2U7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICAvLyBFYXN5IC0tIGlmIHRoZXJlIGlzIEJPTSBvciBhdCBsZWFzdCAxIHZhbGlkIG5vdC1zaW5nbGUgYnl0ZSBjaGFyYWN0ZXIgKGFuZCBubyBldmlkZW5jZSBpdCBjYW4ndCBiZSBVVEYtOCksIGRvbmVcXHJcXG4gICAgICAgIGlmIChjYW5CZVVURjggJiYgKHV0Zjhib20gfHwgdXRmMkJ5dGVzQ2hhcnMgKyB1dGYzQnl0ZXNDaGFycyArIHV0ZjRCeXRlc0NoYXJzID4gMCkpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nVXRpbHMuVVRGODtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIC8vIEVhc3kgLS0gaWYgYXNzdW1pbmcgU2hpZnRfSklTIG9yIGF0IGxlYXN0IDMgdmFsaWQgY29uc2VjdXRpdmUgbm90LWFzY2lpIGNoYXJhY3RlcnMgKGFuZCBubyBldmlkZW5jZSBpdCBjYW4ndCBiZSksIGRvbmVcXHJcXG4gICAgICAgIGlmIChjYW5CZVNoaWZ0SklTICYmIChTdHJpbmdVdGlscy5BU1NVTUVfU0hJRlRfSklTIHx8IHNqaXNNYXhLYXRha2FuYVdvcmRMZW5ndGggPj0gMyB8fCBzamlzTWF4RG91YmxlQnl0ZXNXb3JkTGVuZ3RoID49IDMpKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZ1V0aWxzLlNISUZUX0pJUztcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIC8vIERpc3Rpbmd1aXNoaW5nIFNoaWZ0X0pJUyBhbmQgSVNPLTg4NTktMSBjYW4gYmUgYSBsaXR0bGUgdG91Z2ggZm9yIHNob3J0IHdvcmRzLiBUaGUgY3J1ZGUgaGV1cmlzdGljIGlzOlxcclxcbiAgICAgICAgLy8gLSBJZiB3ZSBzYXdcXHJcXG4gICAgICAgIC8vICAgLSBvbmx5IHR3byBjb25zZWN1dGl2ZSBrYXRha2FuYSBjaGFycyBpbiB0aGUgd2hvbGUgdGV4dCwgb3JcXHJcXG4gICAgICAgIC8vICAgLSBhdCBsZWFzdCAxMCUgb2YgYnl0ZXMgdGhhdCBjb3VsZCBiZSBcXFwidXBwZXJcXFwiIG5vdC1hbHBoYW51bWVyaWMgTGF0aW4xLFxcclxcbiAgICAgICAgLy8gLSB0aGVuIHdlIGNvbmNsdWRlIFNoaWZ0X0pJUywgZWxzZSBJU08tODg1OS0xXFxyXFxuICAgICAgICBpZiAoY2FuQmVJU084ODU5MSAmJiBjYW5CZVNoaWZ0SklTKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIChzamlzTWF4S2F0YWthbmFXb3JkTGVuZ3RoID09PSAyICYmIHNqaXNLYXRha2FuYUNoYXJzID09PSAyKSB8fCBpc29IaWdoT3RoZXIgKiAxMCA+PSBsZW5ndGhcXHJcXG4gICAgICAgICAgICAgICAgPyBTdHJpbmdVdGlscy5TSElGVF9KSVMgOiBTdHJpbmdVdGlscy5JU084ODU5MTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIC8vIE90aGVyd2lzZSwgdHJ5IGluIG9yZGVyIElTTy04ODU5LTEsIFNoaWZ0IEpJUywgVVRGLTggYW5kIGZhbGwgYmFjayB0byBkZWZhdWx0IHBsYXRmb3JtIGVuY29kaW5nXFxyXFxuICAgICAgICBpZiAoY2FuQmVJU084ODU5MSkge1xcclxcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmdVdGlscy5JU084ODU5MTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGlmIChjYW5CZVNoaWZ0SklTKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZ1V0aWxzLlNISUZUX0pJUztcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGlmIChjYW5CZVVURjgpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nVXRpbHMuVVRGODtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIC8vIE90aGVyd2lzZSwgd2UgdGFrZSBhIHdpbGQgZ3Vlc3Mgd2l0aCBwbGF0Zm9ybSBlbmNvZGluZ1xcclxcbiAgICAgICAgcmV0dXJuIFN0cmluZ1V0aWxzLlBMQVRGT1JNX0RFRkFVTFRfRU5DT0RJTkc7XFxyXFxuICAgIH07XFxyXFxuICAgIC8qKlxcclxcbiAgICAgKlxcclxcbiAgICAgKiBAc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMzQzOTcxMS80MzY3NjgzXFxyXFxuICAgICAqXFxyXFxuICAgICAqIEBwYXJhbSBhcHBlbmQgVGhlIG5ldyBzdHJpbmcgdG8gYXBwZW5kLlxcclxcbiAgICAgKiBAcGFyYW0gYXJncyBBcmd1bWV0cyB2YWx1ZXMgdG8gYmUgZm9ybWF0ZWQuXFxyXFxuICAgICAqL1xcclxcbiAgICBTdHJpbmdVdGlscy5mb3JtYXQgPSBmdW5jdGlvbiAoYXBwZW5kKSB7XFxyXFxuICAgICAgICB2YXIgYXJncyA9IFtdO1xcclxcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcXHJcXG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgdmFyIGkgPSAtMTtcXHJcXG4gICAgICAgIGZ1bmN0aW9uIGNhbGxiYWNrKGV4cCwgcDAsIHAxLCBwMiwgcDMsIHA0KSB7XFxyXFxuICAgICAgICAgICAgaWYgKGV4cCA9PT0gJyUlJylcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuICclJztcXHJcXG4gICAgICAgICAgICBpZiAoYXJnc1srK2ldID09PSB1bmRlZmluZWQpXFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XFxyXFxuICAgICAgICAgICAgZXhwID0gcDIgPyBwYXJzZUludChwMi5zdWJzdHIoMSkpIDogdW5kZWZpbmVkO1xcclxcbiAgICAgICAgICAgIHZhciBiYXNlID0gcDMgPyBwYXJzZUludChwMy5zdWJzdHIoMSkpIDogdW5kZWZpbmVkO1xcclxcbiAgICAgICAgICAgIHZhciB2YWw7XFxyXFxuICAgICAgICAgICAgc3dpdGNoIChwNCkge1xcclxcbiAgICAgICAgICAgICAgICBjYXNlICdzJzpcXHJcXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IGFyZ3NbaV07XFxyXFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICAgICAgY2FzZSAnYyc6XFxyXFxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBhcmdzW2ldWzBdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxcclxcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VGbG9hdChhcmdzW2ldKS50b0ZpeGVkKGV4cCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICAgICAgY2FzZSAncCc6XFxyXFxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KGFyZ3NbaV0pLnRvUHJlY2lzaW9uKGV4cCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICAgICAgY2FzZSAnZSc6XFxyXFxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KGFyZ3NbaV0pLnRvRXhwb25lbnRpYWwoZXhwKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgICAgICBjYXNlICd4JzpcXHJcXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHBhcnNlSW50KGFyZ3NbaV0pLnRvU3RyaW5nKGJhc2UgPyBiYXNlIDogMTYpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgICAgIGNhc2UgJ2QnOlxcclxcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VGbG9hdChwYXJzZUludChhcmdzW2ldLCBiYXNlID8gYmFzZSA6IDEwKS50b1ByZWNpc2lvbihleHApKS50b0ZpeGVkKDApO1xcclxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIHZhbCA9IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnID8gSlNPTi5zdHJpbmdpZnkodmFsKSA6ICgrdmFsKS50b1N0cmluZyhiYXNlKTtcXHJcXG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHBhcnNlSW50KHAxKTsgLyogcGFkZGluZyBzaXplICovXFxyXFxuICAgICAgICAgICAgdmFyIGNoID0gcDEgJiYgKHAxWzBdICsgJycpID09PSAnMCcgPyAnMCcgOiAnICc7IC8qIGlzbnVsbD8gKi9cXHJcXG4gICAgICAgICAgICB3aGlsZSAodmFsLmxlbmd0aCA8IHNpemUpXFxyXFxuICAgICAgICAgICAgICAgIHZhbCA9IHAwICE9PSB1bmRlZmluZWQgPyB2YWwgKyBjaCA6IGNoICsgdmFsOyAvKiBpc21pbnVzPyAqL1xcclxcbiAgICAgICAgICAgIHJldHVybiB2YWw7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICB2YXIgcmVnZXggPSAvJSgtKT8oMD9bMC05XSspPyhbLl1bMC05XSspPyhbI11bMC05XSspPyhbc2NmcGV4ZCVdKS9nO1xcclxcbiAgICAgICAgcmV0dXJuIGFwcGVuZC5yZXBsYWNlKHJlZ2V4LCBjYWxsYmFjayk7XFxyXFxuICAgIH07XFxyXFxuICAgIC8qKlxcclxcbiAgICAgKlxcclxcbiAgICAgKi9cXHJcXG4gICAgU3RyaW5nVXRpbHMuZ2V0Qnl0ZXMgPSBmdW5jdGlvbiAoc3RyLCBlbmNvZGluZykge1xcclxcbiAgICAgICAgcmV0dXJuIFN0cmluZ0VuY29kaW5nXzEuZGVmYXVsdC5lbmNvZGUoc3RyLCBlbmNvZGluZyk7XFxyXFxuICAgIH07XFxyXFxuICAgIC8qKlxcclxcbiAgICAgKiBSZXR1cm5zIHRoZSBjaGFyY29kZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4IG9yIGF0IGluZGV4IHplcm8uXFxyXFxuICAgICAqL1xcclxcbiAgICBTdHJpbmdVdGlscy5nZXRDaGFyQ29kZSA9IGZ1bmN0aW9uIChzdHIsIGluZGV4KSB7XFxyXFxuICAgICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkgeyBpbmRleCA9IDA7IH1cXHJcXG4gICAgICAgIHJldHVybiBzdHIuY2hhckNvZGVBdChpbmRleCk7XFxyXFxuICAgIH07XFxyXFxuICAgIC8qKlxcclxcbiAgICAgKiBSZXR1cm5zIGNoYXIgZm9yIGdpdmVuIGNoYXJjb2RlXFxyXFxuICAgICAqL1xcclxcbiAgICBTdHJpbmdVdGlscy5nZXRDaGFyQXQgPSBmdW5jdGlvbiAoY2hhckNvZGUpIHtcXHJcXG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcXHJcXG4gICAgfTtcXHJcXG4gICAgU3RyaW5nVXRpbHMuU0hJRlRfSklTID0gQ2hhcmFjdGVyU2V0RUNJXzEuZGVmYXVsdC5TSklTLmdldE5hbWUoKTsgLy8gXFxcIlNKSVNcXFwiXFxyXFxuICAgIFN0cmluZ1V0aWxzLkdCMjMxMiA9ICdHQjIzMTInO1xcclxcbiAgICBTdHJpbmdVdGlscy5JU084ODU5MSA9IENoYXJhY3RlclNldEVDSV8xLmRlZmF1bHQuSVNPODg1OV8xLmdldE5hbWUoKTsgLy8gXFxcIklTTzg4NTlfMVxcXCJcXHJcXG4gICAgU3RyaW5nVXRpbHMuRVVDX0pQID0gJ0VVQ19KUCc7XFxyXFxuICAgIFN0cmluZ1V0aWxzLlVURjggPSBDaGFyYWN0ZXJTZXRFQ0lfMS5kZWZhdWx0LlVURjguZ2V0TmFtZSgpOyAvLyBcXFwiVVRGOFxcXCJcXHJcXG4gICAgU3RyaW5nVXRpbHMuUExBVEZPUk1fREVGQVVMVF9FTkNPRElORyA9IFN0cmluZ1V0aWxzLlVURjg7IC8vIFxcXCJVVEY4XFxcIi8vQ2hhcnNldC5kZWZhdWx0Q2hhcnNldCgpLm5hbWUoKVxcclxcbiAgICBTdHJpbmdVdGlscy5BU1NVTUVfU0hJRlRfSklTID0gZmFsc2U7XFxyXFxuICAgIHJldHVybiBTdHJpbmdVdGlscztcXHJcXG59KCkpO1xcclxcbmV4cG9ydHMuZGVmYXVsdCA9IFN0cmluZ1V0aWxzO1xcclxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL09aU2VhbFJlY29nbml0aW9uLy4vc3JjL2NvcmUvY29tbW9uL1N0cmluZ1V0aWxzLnRzP1wiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKioqLyB9KSxcclxuXHJcbiAgICAgICAgICAgIC8qKiovIFwiLi9zcmMvY29yZS9jb21tb24vZGV0ZWN0b3IvTWF0aFV0aWxzLnRzXCI6XHJcbiAgICAgICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxyXG4gICAgICAgICAgICAgICEqKiogLi9zcmMvY29yZS9jb21tb24vZGV0ZWN0b3IvTWF0aFV0aWxzLnRzICoqKiFcclxuICAgICAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cclxuICAgICAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xyXG4gICAgICAgICAgICAvKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICAgICAgICAgICAgICBldmFsKFwiXFxyXFxuLypcXHJcXG4gKiBDb3B5cmlnaHQgMjAxMiBaWGluZyBhdXRob3JzXFxyXFxuICpcXHJcXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXFxcIkxpY2Vuc2VcXFwiKTtcXHJcXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXFxyXFxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XFxyXFxuICpcXHJcXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxcclxcbiAqXFxyXFxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxcclxcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFxcXCJBUyBJU1xcXCIgQkFTSVMsXFxyXFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXFxyXFxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxcclxcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxcclxcbiAqL1xcclxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHsgdmFsdWU6IHRydWUgfSk7XFxyXFxuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5jb21tb24uZGV0ZWN0b3IgeyovXFxyXFxuLyoqXFxyXFxuICogR2VuZXJhbCBtYXRoLXJlbGF0ZWQgYW5kIG51bWVyaWMgdXRpbGl0eSBmdW5jdGlvbnMuXFxyXFxuICovXFxyXFxudmFyIE1hdGhVdGlscyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgZnVuY3Rpb24gTWF0aFV0aWxzKCkge1xcclxcbiAgICB9XFxyXFxuICAgIE1hdGhVdGlscy5wcm90b3R5cGUuTWF0aFV0aWxzID0gZnVuY3Rpb24gKCkge1xcclxcbiAgICB9O1xcclxcbiAgICAvKipcXHJcXG4gICAgICogRW5kcyB1cCBiZWluZyBhIGJpdCBmYXN0ZXIgdGhhbiB7QGxpbmsgTWF0aCNyb3VuZChmbG9hdCl9LiBUaGlzIG1lcmVseSByb3VuZHMgaXRzXFxyXFxuICAgICAqIGFyZ3VtZW50IHRvIHRoZSBuZWFyZXN0IGludCwgd2hlcmUgeC41IHJvdW5kcyB1cCB0byB4KzEuIFNlbWFudGljcyBvZiB0aGlzIHNob3J0Y3V0XFxyXFxuICAgICAqIGRpZmZlciBzbGlnaHRseSBmcm9tIHtAbGluayBNYXRoI3JvdW5kKGZsb2F0KX0gaW4gdGhhdCBoYWxmIHJvdW5kcyBkb3duIGZvciBuZWdhdGl2ZVxcclxcbiAgICAgKiB2YWx1ZXMuIC0yLjUgcm91bmRzIHRvIC0zLCBub3QgLTIuIEZvciBwdXJwb3NlcyBoZXJlIGl0IG1ha2VzIG5vIGRpZmZlcmVuY2UuXFxyXFxuICAgICAqXFxyXFxuICAgICAqIEBwYXJhbSBkIHJlYWwgdmFsdWUgdG8gcm91bmRcXHJcXG4gICAgICogQHJldHVybiBuZWFyZXN0IHtAY29kZSBpbnR9XFxyXFxuICAgICAqL1xcclxcbiAgICBNYXRoVXRpbHMucm91bmQgPSBmdW5jdGlvbiAoZCAvKmZsb2F0Ki8pIHtcXHJcXG4gICAgICAgIGlmIChOYU4gPT09IGQpXFxyXFxuICAgICAgICAgICAgcmV0dXJuIDA7XFxyXFxuICAgICAgICBpZiAoZCA8PSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUilcXHJcXG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XFxyXFxuICAgICAgICBpZiAoZCA+PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUilcXHJcXG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XFxyXFxuICAgICAgICByZXR1cm4gLyooaW50KSAqLyAoZCArIChkIDwgMC4wID8gLTAuNSA6IDAuNSkpIHwgMDtcXHJcXG4gICAgfTtcXHJcXG4gICAgLy8gVFlQRVNDUklQVFBPUlQ6IG1heWJlIHJlbW92ZSByb3VuZCBtZXRob2QgYW5kIGNhbGwgZGlyZWN0bHkgTWF0aC5yb3VuZCwgaXQgbG9va3MgbGlrZSBpdCBkb2Vzbid0IG1ha2Ugc2Vuc2UgZm9yIGpzXFxyXFxuICAgIC8qKlxcclxcbiAgICAgKiBAcGFyYW0gYVggcG9pbnQgQSB4IGNvb3JkaW5hdGVcXHJcXG4gICAgICogQHBhcmFtIGFZIHBvaW50IEEgeSBjb29yZGluYXRlXFxyXFxuICAgICAqIEBwYXJhbSBiWCBwb2ludCBCIHggY29vcmRpbmF0ZVxcclxcbiAgICAgKiBAcGFyYW0gYlkgcG9pbnQgQiB5IGNvb3JkaW5hdGVcXHJcXG4gICAgICogQHJldHVybiBFdWNsaWRlYW4gZGlzdGFuY2UgYmV0d2VlbiBwb2ludHMgQSBhbmQgQlxcclxcbiAgICAgKi9cXHJcXG4gICAgTWF0aFV0aWxzLmRpc3RhbmNlID0gZnVuY3Rpb24gKGFYIC8qZmxvYXR8aW50Ki8sIGFZIC8qZmxvYXR8aW50Ki8sIGJYIC8qZmxvYXR8aW50Ki8sIGJZIC8qZmxvYXR8aW50Ki8pIHtcXHJcXG4gICAgICAgIHZhciB4RGlmZiA9IGFYIC0gYlg7XFxyXFxuICAgICAgICB2YXIgeURpZmYgPSBhWSAtIGJZO1xcclxcbiAgICAgICAgcmV0dXJuIC8qKGZsb2F0KSAqLyBNYXRoLnNxcnQoeERpZmYgKiB4RGlmZiArIHlEaWZmICogeURpZmYpO1xcclxcbiAgICB9O1xcclxcbiAgICAvKipcXHJcXG4gICAgICogQHBhcmFtIGFYIHBvaW50IEEgeCBjb29yZGluYXRlXFxyXFxuICAgICAqIEBwYXJhbSBhWSBwb2ludCBBIHkgY29vcmRpbmF0ZVxcclxcbiAgICAgKiBAcGFyYW0gYlggcG9pbnQgQiB4IGNvb3JkaW5hdGVcXHJcXG4gICAgICogQHBhcmFtIGJZIHBvaW50IEIgeSBjb29yZGluYXRlXFxyXFxuICAgICAqIEByZXR1cm4gRXVjbGlkZWFuIGRpc3RhbmNlIGJldHdlZW4gcG9pbnRzIEEgYW5kIEJcXHJcXG4gICAgICovXFxyXFxuICAgIC8vIHB1YmxpYyBzdGF0aWMgZGlzdGFuY2UoYVg6IG51bWJlciAvKmludCovLCBhWTogbnVtYmVyIC8qaW50Ki8sIGJYOiBudW1iZXIgLyppbnQqLywgYlk6IG51bWJlciAvKmludCovKTogZmxvYXQge1xcclxcbiAgICAvLyAgIGNvbnN0IHhEaWZmID0gYVggLSBiWFxcclxcbiAgICAvLyAgIGNvbnN0IHlEaWZmID0gYVkgLSBiWVxcclxcbiAgICAvLyAgIHJldHVybiAoZmxvYXQpIE1hdGguc3FydCh4RGlmZiAqIHhEaWZmICsgeURpZmYgKiB5RGlmZik7XFxyXFxuICAgIC8vIH1cXHJcXG4gICAgLyoqXFxyXFxuICAgICAqIEBwYXJhbSBhcnJheSB2YWx1ZXMgdG8gc3VtXFxyXFxuICAgICAqIEByZXR1cm4gc3VtIG9mIHZhbHVlcyBpbiBhcnJheVxcclxcbiAgICAgKi9cXHJcXG4gICAgTWF0aFV0aWxzLnN1bSA9IGZ1bmN0aW9uIChhcnJheSkge1xcclxcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcXHJcXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGhfMSA9IGFycmF5Lmxlbmd0aDsgaSAhPT0gbGVuZ3RoXzE7IGkrKykge1xcclxcbiAgICAgICAgICAgIHZhciBhID0gYXJyYXlbaV07XFxyXFxuICAgICAgICAgICAgY291bnQgKz0gYTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHJldHVybiBjb3VudDtcXHJcXG4gICAgfTtcXHJcXG4gICAgcmV0dXJuIE1hdGhVdGlscztcXHJcXG59KCkpO1xcclxcbmV4cG9ydHMuZGVmYXVsdCA9IE1hdGhVdGlscztcXHJcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9PWlNlYWxSZWNvZ25pdGlvbi8uL3NyYy9jb3JlL2NvbW1vbi9kZXRlY3Rvci9NYXRoVXRpbHMudHM/XCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKiovIH0pLFxyXG5cclxuICAgICAgICAgICAgLyoqKi8gXCIuL3NyYy9jb3JlL3FyY29kZS9kZXRlY3Rvci9PWlNlYWxGaW5kZXJQYXR0ZXJuLnRzXCI6XHJcbiAgICAgICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcclxuICAgICAgICAgICAgICAhKioqIC4vc3JjL2NvcmUvcXJjb2RlL2RldGVjdG9yL09aU2VhbEZpbmRlclBhdHRlcm4udHMgKioqIVxyXG4gICAgICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cclxuICAgICAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xyXG4gICAgICAgICAgICAvKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICAgICAgICAgICAgICBldmFsKFwiXFxyXFxuLypcXHJcXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXFxyXFxuICpcXHJcXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXFxcIkxpY2Vuc2VcXFwiKTtcXHJcXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXFxyXFxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XFxyXFxuICpcXHJcXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxcclxcbiAqXFxyXFxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxcclxcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFxcXCJBUyBJU1xcXCIgQkFTSVMsXFxyXFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXFxyXFxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxcclxcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxcclxcbiAqL1xcclxcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xcclxcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxcclxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcXHJcXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcXHJcXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xcclxcbiAgICB9O1xcclxcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcXHJcXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XFxyXFxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cXHJcXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcXHJcXG4gICAgfTtcXHJcXG59KSgpO1xcclxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHsgdmFsdWU6IHRydWUgfSk7XFxyXFxuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5xcmNvZGUuZGV0ZWN0b3IgeyovXFxyXFxudmFyIFJlc3VsdFBvaW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9SZXN1bHRQb2ludCAqLyBcXFwiLi9zcmMvY29yZS9SZXN1bHRQb2ludC50c1xcXCIpO1xcclxcbi8qKlxcclxcbiAqIDxwPkVuY2Fwc3VsYXRlcyBhIGZpbmRlciBwYXR0ZXJuLCB3aGljaCBhcmUgdGhlIHRocmVlIHNxdWFyZSBwYXR0ZXJucyBmb3VuZCBpblxcclxcbiAqIHRoZSBjb3JuZXJzIG9mIFFSIENvZGVzLiBJdCBhbHNvIGVuY2Fwc3VsYXRlcyBhIGNvdW50IG9mIHNpbWlsYXIgZmluZGVyIHBhdHRlcm5zLFxcclxcbiAqIGFzIGEgY29udmVuaWVuY2UgdG8gdGhlIGZpbmRlcidzIGJvb2trZWVwaW5nLjwvcD5cXHJcXG4gKlxcclxcbiAqIEBhdXRob3IgU2VhbiBPd2VuXFxyXFxuICovXFxyXFxudmFyIE9aU2VhbEZpbmRlclBhdHRlcm4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XFxyXFxuICAgIF9fZXh0ZW5kcyhPWlNlYWxGaW5kZXJQYXR0ZXJuLCBfc3VwZXIpO1xcclxcbiAgICAvLyBPWlNlYWxGaW5kZXJQYXR0ZXJuKHBvc1g6IG51bWJlci8qZmxvYXQqLywgcG9zWTogbnVtYmVyLypmbG9hdCovLCBlc3RpbWF0ZWRNb2R1bGVTaXplOiBudW1iZXIvKmZsb2F0Ki8pIHtcXHJcXG4gICAgLy8gICB0aGlzKHBvc1gsIHBvc1ksIGVzdGltYXRlZE1vZHVsZVNpemUsIDEpXFxyXFxuICAgIC8vIH1cXHJcXG4gICAgZnVuY3Rpb24gT1pTZWFsRmluZGVyUGF0dGVybihwb3NYIC8qZmxvYXQqLywgcG9zWSAvKmZsb2F0Ki8sIGVzdGltYXRlZE1vZHVsZVNpemUgLypmbG9hdCovLCBjb3VudCAvKmludCovKSB7XFxyXFxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwb3NYLCBwb3NZKSB8fCB0aGlzO1xcclxcbiAgICAgICAgX3RoaXMuZXN0aW1hdGVkTW9kdWxlU2l6ZSA9IGVzdGltYXRlZE1vZHVsZVNpemU7XFxyXFxuICAgICAgICBfdGhpcy5jb3VudCA9IGNvdW50O1xcclxcbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gY291bnQpIHtcXHJcXG4gICAgICAgICAgICBfdGhpcy5jb3VudCA9IDE7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICByZXR1cm4gX3RoaXM7XFxyXFxuICAgIH1cXHJcXG4gICAgT1pTZWFsRmluZGVyUGF0dGVybi5wcm90b3R5cGUuZ2V0RXN0aW1hdGVkTW9kdWxlU2l6ZSA9IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgIHJldHVybiB0aGlzLmVzdGltYXRlZE1vZHVsZVNpemU7XFxyXFxuICAgIH07XFxyXFxuICAgIE9aU2VhbEZpbmRlclBhdHRlcm4ucHJvdG90eXBlLmdldENvdW50ID0gZnVuY3Rpb24gKCkge1xcclxcbiAgICAgICAgcmV0dXJuIHRoaXMuY291bnQ7XFxyXFxuICAgIH07XFxyXFxuICAgIC8qXFxyXFxuICAgIHZvaWQgaW5jcmVtZW50Q291bnQoKSB7XFxyXFxuICAgICAgdGhpcy5jb3VudCsrXFxyXFxuICAgIH1cXHJcXG4gICAgICovXFxyXFxuICAgIC8qKlxcclxcbiAgICAgKiA8cD5EZXRlcm1pbmVzIGlmIHRoaXMgZmluZGVyIHBhdHRlcm4gXFxcImFib3V0IGVxdWFsc1xcXCIgYSBmaW5kZXIgcGF0dGVybiBhdCB0aGUgc3RhdGVkXFxyXFxuICAgICAqIHBvc2l0aW9uIGFuZCBzaXplIC0tIG1lYW5pbmcsIGl0IGlzIGF0IG5lYXJseSB0aGUgc2FtZSBjZW50ZXIgd2l0aCBuZWFybHkgdGhlIHNhbWUgc2l6ZS48L3A+XFxyXFxuICAgICAqL1xcclxcbiAgICBPWlNlYWxGaW5kZXJQYXR0ZXJuLnByb3RvdHlwZS5hYm91dEVxdWFscyA9IGZ1bmN0aW9uIChtb2R1bGVTaXplIC8qZmxvYXQqLywgaSAvKmZsb2F0Ki8sIGogLypmbG9hdCovKSB7XFxyXFxuICAgICAgICBpZiAoTWF0aC5hYnMoaSAtIHRoaXMuZ2V0WSgpKSA8PSBtb2R1bGVTaXplICYmIE1hdGguYWJzKGogLSB0aGlzLmdldFgoKSkgPD0gbW9kdWxlU2l6ZSkge1xcclxcbiAgICAgICAgICAgIHZhciBtb2R1bGVTaXplRGlmZiA9IE1hdGguYWJzKG1vZHVsZVNpemUgLSB0aGlzLmVzdGltYXRlZE1vZHVsZVNpemUpO1xcclxcbiAgICAgICAgICAgIHJldHVybiBtb2R1bGVTaXplRGlmZiA8PSAxLjAgfHwgbW9kdWxlU2l6ZURpZmYgPD0gdGhpcy5lc3RpbWF0ZWRNb2R1bGVTaXplO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcclxcbiAgICB9O1xcclxcbiAgICAvKipcXHJcXG4gICAgICogQ29tYmluZXMgdGhpcyBvYmplY3QncyBjdXJyZW50IGVzdGltYXRlIG9mIGEgZmluZGVyIHBhdHRlcm4gcG9zaXRpb24gYW5kIG1vZHVsZSBzaXplXFxyXFxuICAgICAqIHdpdGggYSBuZXcgZXN0aW1hdGUuIEl0IHJldHVybnMgYSBuZXcge0Bjb2RlIE9aU2VhbEZpbmRlclBhdHRlcm59IGNvbnRhaW5pbmcgYSB3ZWlnaHRlZCBhdmVyYWdlXFxyXFxuICAgICAqIGJhc2VkIG9uIGNvdW50LlxcclxcbiAgICAgKi9cXHJcXG4gICAgT1pTZWFsRmluZGVyUGF0dGVybi5wcm90b3R5cGUuY29tYmluZUVzdGltYXRlID0gZnVuY3Rpb24gKGkgLypmbG9hdCovLCBqIC8qZmxvYXQqLywgbmV3TW9kdWxlU2l6ZSAvKmZsb2F0Ki8pIHtcXHJcXG4gICAgICAgIHZhciBjb21iaW5lZENvdW50ID0gdGhpcy5jb3VudCArIDE7XFxyXFxuICAgICAgICB2YXIgY29tYmluZWRYID0gKHRoaXMuY291bnQgKiB0aGlzLmdldFgoKSArIGopIC8gY29tYmluZWRDb3VudDtcXHJcXG4gICAgICAgIHZhciBjb21iaW5lZFkgPSAodGhpcy5jb3VudCAqIHRoaXMuZ2V0WSgpICsgaSkgLyBjb21iaW5lZENvdW50O1xcclxcbiAgICAgICAgdmFyIGNvbWJpbmVkTW9kdWxlU2l6ZSA9ICh0aGlzLmNvdW50ICogdGhpcy5lc3RpbWF0ZWRNb2R1bGVTaXplICsgbmV3TW9kdWxlU2l6ZSkgLyBjb21iaW5lZENvdW50O1xcclxcbiAgICAgICAgcmV0dXJuIG5ldyBPWlNlYWxGaW5kZXJQYXR0ZXJuKGNvbWJpbmVkWCwgY29tYmluZWRZLCBjb21iaW5lZE1vZHVsZVNpemUsIGNvbWJpbmVkQ291bnQpO1xcclxcbiAgICB9O1xcclxcbiAgICByZXR1cm4gT1pTZWFsRmluZGVyUGF0dGVybjtcXHJcXG59KFJlc3VsdFBvaW50XzEuZGVmYXVsdCkpO1xcclxcbmV4cG9ydHMuZGVmYXVsdCA9IE9aU2VhbEZpbmRlclBhdHRlcm47XFxyXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vT1pTZWFsUmVjb2duaXRpb24vLi9zcmMvY29yZS9xcmNvZGUvZGV0ZWN0b3IvT1pTZWFsRmluZGVyUGF0dGVybi50cz9cIik7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqKi8gfSksXHJcblxyXG4gICAgICAgICAgICAvKioqLyBcIi4vc3JjL2NvcmUvcXJjb2RlL2RldGVjdG9yL09aU2VhbEZpbmRlclBhdHRlcm5GaW5kZXIudHNcIjpcclxuICAgICAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxyXG4gICAgICAgICAgICAgICEqKiogLi9zcmMvY29yZS9xcmNvZGUvZGV0ZWN0b3IvT1pTZWFsRmluZGVyUGF0dGVybkZpbmRlci50cyAqKiohXHJcbiAgICAgICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgICAgICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xyXG4gICAgICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXHJcbiAgICAgICAgICAgIC8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbiAgICAgICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgICAgICAgICAgICAgIGV2YWwoXCJcXHJcXG4vKlxcclxcbiAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcXHJcXG4gKlxcclxcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcXFwiTGljZW5zZVxcXCIpO1xcclxcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cXHJcXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcXHJcXG4gKlxcclxcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXFxyXFxuICpcXHJcXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXFxyXFxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXFxcIkFTIElTXFxcIiBCQVNJUyxcXHJcXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cXHJcXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXFxyXFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXFxyXFxuICovXFxyXFxudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xcclxcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcXHJcXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XFxyXFxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXFxcIm51bWJlclxcXCIpIHJldHVybiB7XFxyXFxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcXHJcXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XFxyXFxuICAgICAgICB9XFxyXFxuICAgIH07XFxyXFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFxcXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlxcXCIgOiBcXFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlxcXCIpO1xcclxcbn07XFxyXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcXHJcXG52YXIgT1pTZWFsRmluZGVyUGF0dGVybl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9PWlNlYWxGaW5kZXJQYXR0ZXJuICovIFxcXCIuL3NyYy9jb3JlL3FyY29kZS9kZXRlY3Rvci9PWlNlYWxGaW5kZXJQYXR0ZXJuLnRzXFxcIik7XFxyXFxudmFyIE5vdEZvdW5kRXhjZXB0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9Ob3RGb3VuZEV4Y2VwdGlvbiAqLyBcXFwiLi9zcmMvY29yZS9Ob3RGb3VuZEV4Y2VwdGlvbi50c1xcXCIpO1xcclxcbi8qaW1wb3J0IGphdmEuaW8uU2VyaWFsaXphYmxlOyovXFxyXFxuLyppbXBvcnQgamF2YS51dGlsLkFycmF5TGlzdDsqL1xcclxcbi8qaW1wb3J0IGphdmEudXRpbC5Db2xsZWN0aW9uczsqL1xcclxcbi8qaW1wb3J0IGphdmEudXRpbC5Db21wYXJhdG9yOyovXFxyXFxuLyppbXBvcnQgamF2YS51dGlsLkxpc3Q7Ki9cXHJcXG4vKmltcG9ydCBqYXZhLnV0aWwuTWFwOyovXFxyXFxuLyoqXFxyXFxuICogPHA+VGhpcyBjbGFzcyBhdHRlbXB0cyB0byBmaW5kIGZpbmRlciBwYXR0ZXJucyBpbiBhIFFSIENvZGUuIEZpbmRlciBwYXR0ZXJucyBhcmUgdGhlIHNxdWFyZVxcclxcbiAqIG1hcmtlcnMgYXQgdGhyZWUgY29ybmVycyBvZiBhIFFSIENvZGUuPC9wPlxcclxcbiAqXFxyXFxuICogPHA+VGhpcyBjbGFzcyBpcyB0aHJlYWQtc2FmZSBidXQgbm90IHJlZW50cmFudC4gRWFjaCB0aHJlYWQgbXVzdCBhbGxvY2F0ZSBpdHMgb3duIG9iamVjdC5cXHJcXG4gKlxcclxcbiAqIEBhdXRob3IgU2VhbiBPd2VuXFxyXFxuICovXFxyXFxudmFyIE9aU2VhbEZpbmRlclBhdHRlcm5GaW5kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XFxyXFxuICAgIC8qKlxcclxcbiAgICAgKiA8cD5DcmVhdGVzIGEgZmluZGVyIHRoYXQgd2lsbCBzZWFyY2ggdGhlIGltYWdlIGZvciB0aHJlZSBmaW5kZXIgcGF0dGVybnMuPC9wPlxcclxcbiAgICAgKlxcclxcbiAgICAgKiBAcGFyYW0gaW1hZ2UgaW1hZ2UgdG8gc2VhcmNoXFxyXFxuICAgICAqL1xcclxcbiAgICAvLyBwdWJsaWMgY29uc3RydWN0b3IoaW1hZ2U6IEJpdE1hdHJpeCkge1xcclxcbiAgICAvLyAgIHRoaXMoaW1hZ2UsIG51bGwpXFxyXFxuICAgIC8vIH1cXHJcXG4gICAgZnVuY3Rpb24gT1pTZWFsRmluZGVyUGF0dGVybkZpbmRlcihpbWFnZSkge1xcclxcbiAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xcclxcbiAgICAgICAgdGhpcy5wb3NzaWJsZUNlbnRlcnMgPSBbXTtcXHJcXG4gICAgICAgIHRoaXMuY3Jvc3NDaGVja1N0YXRlQ291bnQgPSBuZXcgSW50MzJBcnJheSg1KTtcXHJcXG4gICAgfVxcclxcbiAgICBPWlNlYWxGaW5kZXJQYXR0ZXJuRmluZGVyLnByb3RvdHlwZS5nZXRJbWFnZSA9IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlO1xcclxcbiAgICB9O1xcclxcbiAgICBPWlNlYWxGaW5kZXJQYXR0ZXJuRmluZGVyLnByb3RvdHlwZS5nZXRQb3NzaWJsZUNlbnRlcnMgPSBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICByZXR1cm4gdGhpcy5wb3NzaWJsZUNlbnRlcnM7XFxyXFxuICAgIH07XFxyXFxuICAgIE9aU2VhbEZpbmRlclBhdHRlcm5GaW5kZXIucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAocGF0dGVybnMpIHtcXHJcXG4gICAgICAgIHZhciB0cnlIYXJkZXIgPSBmYWxzZTtcXHJcXG4gICAgICAgIHZhciBpbWFnZSA9IHRoaXMuaW1hZ2U7XFxyXFxuICAgICAgICB2YXIgbWF4SSA9IGltYWdlLmdldEhlaWdodCgpO1xcclxcbiAgICAgICAgdmFyIG1heEogPSBpbWFnZS5nZXRXaWR0aCgpO1xcclxcbiAgICAgICAgLy8gV2UgYXJlIGxvb2tpbmcgZm9yIGJsYWNrL3doaXRlL2JsYWNrL3doaXRlL2JsYWNrIG1vZHVsZXMgaW5cXHJcXG4gICAgICAgIC8vIDE6MTozOjE6MSByYXRpbzsgdGhpcyB0cmFja3MgdGhlIG51bWJlciBvZiBzdWNoIG1vZHVsZXMgc2VlbiBzbyBmYXJcXHJcXG4gICAgICAgIC8vIExldCdzIGFzc3VtZSB0aGF0IHRoZSBtYXhpbXVtIHZlcnNpb24gUVIgQ29kZSB3ZSBzdXBwb3J0IHRha2VzIHVwIDEvNCB0aGUgaGVpZ2h0IG9mIHRoZVxcclxcbiAgICAgICAgLy8gaW1hZ2UsIGFuZCB0aGVuIGFjY291bnQgZm9yIHRoZSBjZW50ZXIgYmVpbmcgMyBtb2R1bGVzIGluIHNpemUuIFRoaXMgZ2l2ZXMgdGhlIHNtYWxsZXN0XFxyXFxuICAgICAgICAvLyBudW1iZXIgb2YgcGl4ZWxzIHRoZSBjZW50ZXIgY291bGQgYmUsIHNvIHNraXAgdGhpcyBvZnRlbi4gV2hlbiB0cnlpbmcgaGFyZGVyLCBsb29rIGZvciBhbGxcXHJcXG4gICAgICAgIC8vIFFSIHZlcnNpb25zIHJlZ2FyZGxlc3Mgb2YgaG93IGRlbnNlIHRoZXkgYXJlLlxcclxcbiAgICAgICAgdmFyIGlTa2lwID0gTWF0aC5mbG9vcigoMyAqIG1heEkpIC8gKDQgKiBPWlNlYWxGaW5kZXJQYXR0ZXJuRmluZGVyLk1BWF9NT0RVTEVTKSk7XFxyXFxuICAgICAgICBpZiAoaVNraXAgPCBPWlNlYWxGaW5kZXJQYXR0ZXJuRmluZGVyLk1JTl9TS0lQIHx8IHRyeUhhcmRlcikge1xcclxcbiAgICAgICAgICAgIGlTa2lwID0gT1pTZWFsRmluZGVyUGF0dGVybkZpbmRlci5NSU5fU0tJUDtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHZhciBkb25lID0gZmFsc2U7XFxyXFxuICAgICAgICB2YXIgc3RhdGVDb3VudCA9IG5ldyBJbnQzMkFycmF5KDUpO1xcclxcbiAgICAgICAgZm9yICh2YXIgaSA9IGlTa2lwIC0gMTsgaSA8IG1heEkgJiYgIWRvbmU7IGkgKz0gaVNraXApIHtcXHJcXG4gICAgICAgICAgICAvLyBHZXQgYSByb3cgb2YgYmxhY2svd2hpdGUgdmFsdWVzXFxyXFxuICAgICAgICAgICAgc3RhdGVDb3VudFswXSA9IDA7XFxyXFxuICAgICAgICAgICAgc3RhdGVDb3VudFsxXSA9IDA7XFxyXFxuICAgICAgICAgICAgc3RhdGVDb3VudFsyXSA9IDA7XFxyXFxuICAgICAgICAgICAgc3RhdGVDb3VudFszXSA9IDA7XFxyXFxuICAgICAgICAgICAgc3RhdGVDb3VudFs0XSA9IDA7XFxyXFxuICAgICAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IDA7XFxyXFxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXhKOyBqKyspIHtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKGltYWdlLmdldChqLCBpKSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gQmxhY2sgcGl4ZWxcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICgoY3VycmVudFN0YXRlICYgMSkgPT09IDEpIHsgLy8gQ291bnRpbmcgd2hpdGUgcGl4ZWxzXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0YXRlKys7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50W2N1cnJlbnRTdGF0ZV0rKztcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICBlbHNlIHsgLy8gV2hpdGUgcGl4ZWxcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICgoY3VycmVudFN0YXRlICYgMSkgPT09IDApIHsgLy8gQ291bnRpbmcgYmxhY2sgcGl4ZWxzXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gNCkgeyAvLyBBIHdpbm5lcj9cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9aU2VhbEZpbmRlclBhdHRlcm5GaW5kZXIuZm91bmRQYXR0ZXJuQ3Jvc3Moc3RhdGVDb3VudCkpIHsgLy8gWWVzXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uZmlybWVkID0gdGhpcy5oYW5kbGVQb3NzaWJsZUNlbnRlcihzdGF0ZUNvdW50LCBpLCBqKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maXJtZWQgPT09IHRydWUpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGFydCBleGFtaW5pbmcgZXZlcnkgb3RoZXIgbGluZS4gQ2hlY2tpbmcgZWFjaCBsaW5lIHR1cm5lZCBvdXQgdG8gYmUgdG9vXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhwZW5zaXZlIGFuZCBkaWRuJ3QgaW1wcm92ZSBwZXJmb3JtYW5jZS5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpU2tpcCA9IDI7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzU2tpcHBlZCA9PT0gdHJ1ZSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2RvbmUgPSB0aGlzLmhhdmVNdWx0aXBseUNvbmZpcm1lZENlbnRlcnMoKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc3Qgcm93U2tpcCA9IHRoaXMuZmluZFJvd1NraXAoKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiAocm93U2tpcCA+IHN0YXRlQ291bnRbMl0pIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCByb3dzIGJldHdlZW4gcm93IG9mIGxvd2VyIGNvbmZpcm1lZCBjZW50ZXJcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRvcCBvZiBwcmVzdW1lZCB0aGlyZCBjb25maXJtZWQgY2VudGVyXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBiYWNrIHVwIGEgYml0IHRvIGdldCBhIGZ1bGwgY2hhbmNlIG9mIGRldGVjdGluZ1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCwgZW50aXJlIHdpZHRoIG9mIGNlbnRlciBvZiBmaW5kZXIgcGF0dGVyblxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIGJ5IHJvd1NraXAsIGJ1dCBiYWNrIG9mZiBieSBzdGF0ZUNvdW50WzJdIChzaXplIG9mIGxhc3QgY2VudGVyXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIHBhdHRlcm4gd2Ugc2F3KSB0byBiZSBjb25zZXJ2YXRpdmUsIGFuZCBhbHNvIGJhY2sgb2ZmIGJ5IGlTa2lwIHdoaWNoXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIGFib3V0IHRvIGJlIHJlLWFkZGVkXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaSArPSByb3dTa2lwIC0gc3RhdGVDb3VudFsyXSAtIGlTa2lwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ogPSBtYXhKIC0gMTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy99XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFswXSA9IHN0YXRlQ291bnRbMl07XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsxXSA9IHN0YXRlQ291bnRbM107XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsyXSA9IHN0YXRlQ291bnRbNF07XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFszXSA9IDE7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFs0XSA9IDA7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0YXRlID0gMztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsZWFyIHN0YXRlIHRvIHN0YXJ0IGxvb2tpbmcgYWdhaW5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IDA7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzBdID0gMDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMV0gPSAwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsyXSA9IDA7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzNdID0gMDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbNF0gPSAwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBObywgc2hpZnQgY291bnRzIGJhY2sgYnkgdHdvXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzBdID0gc3RhdGVDb3VudFsyXTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMV0gPSBzdGF0ZUNvdW50WzNdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsyXSA9IHN0YXRlQ291bnRbNF07XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzNdID0gMTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbNF0gPSAwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0YXRlID0gMztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsrK2N1cnJlbnRTdGF0ZV0rKztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICBlbHNlIHsgLy8gQ291bnRpbmcgd2hpdGUgcGl4ZWxzXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFtjdXJyZW50U3RhdGVdKys7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgaWYgKE9aU2VhbEZpbmRlclBhdHRlcm5GaW5kZXIuZm91bmRQYXR0ZXJuQ3Jvc3Moc3RhdGVDb3VudCkpIHtcXHJcXG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpcm1lZCA9IHRoaXMuaGFuZGxlUG9zc2libGVDZW50ZXIoc3RhdGVDb3VudCwgaSwgbWF4Sik7XFxyXFxuICAgICAgICAgICAgICAgIGlmIChjb25maXJtZWQgPT09IHRydWUpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlTa2lwID0gc3RhdGVDb3VudFswXTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1NraXBwZWQpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3VuZCBhIHRoaXJkIG9uZVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZG9uZSA9IHRoaXMuaGF2ZU11bHRpcGx5Q29uZmlybWVkQ2VudGVycygpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgaWYgKHRoaXMucG9zc2libGVDZW50ZXJzLmxlbmd0aCA+IDApIHtcXHJcXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucG9zc2libGVDZW50ZXJzLmxlbmd0aDsgaSsrKSB7XFxyXFxuICAgICAgICAgICAgICAgIHBhdHRlcm5zLnB1c2godGhpcy5wb3NzaWJsZUNlbnRlcnNbaV0pO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIC8vY29uc3QgcGF0dGVybkluZm86IEZpbmRlclBhdHRlcm5bXSA9IHRoaXMuc2VsZWN0QmVzdFBhdHRlcm5zKCk7XFxyXFxuICAgICAgICAvL1Jlc3VsdFBvaW50Lm9yZGVyQmVzdFBhdHRlcm5zKHBhdHRlcm5JbmZvKTtcXHJcXG4gICAgICAgIHJldHVybiBwYXR0ZXJucy5sZW5ndGggPiAwO1xcclxcbiAgICB9O1xcclxcbiAgICAvKipcXHJcXG4gICAgICogR2l2ZW4gYSBjb3VudCBvZiBibGFjay93aGl0ZS9ibGFjay93aGl0ZS9ibGFjayBwaXhlbHMganVzdCBzZWVuIGFuZCBhbiBlbmQgcG9zaXRpb24sXFxyXFxuICAgICAqIGZpZ3VyZXMgdGhlIGxvY2F0aW9uIG9mIHRoZSBjZW50ZXIgb2YgdGhpcyBydW4uXFxyXFxuICAgICAqL1xcclxcbiAgICBPWlNlYWxGaW5kZXJQYXR0ZXJuRmluZGVyLmNlbnRlckZyb21FbmQgPSBmdW5jdGlvbiAoc3RhdGVDb3VudCwgZW5kIC8qaW50Ki8pIHtcXHJcXG4gICAgICAgIHJldHVybiAoZW5kIC0gc3RhdGVDb3VudFs0XSAtIHN0YXRlQ291bnRbM10pIC0gc3RhdGVDb3VudFsyXSAvIDIuMDtcXHJcXG4gICAgfTtcXHJcXG4gICAgLyoqXFxyXFxuICAgICAqIEBwYXJhbSBzdGF0ZUNvdW50IGNvdW50IG9mIGJsYWNrL3doaXRlL2JsYWNrL3doaXRlL2JsYWNrIHBpeGVscyBqdXN0IHJlYWRcXHJcXG4gICAgICogQHJldHVybiB0cnVlIGlmZiB0aGUgcHJvcG9ydGlvbnMgb2YgdGhlIGNvdW50cyBpcyBjbG9zZSBlbm91Z2ggdG8gdGhlIDEvMS8zLzEvMSByYXRpb3NcXHJcXG4gICAgICogICAgICAgICB1c2VkIGJ5IGZpbmRlciBwYXR0ZXJucyB0byBiZSBjb25zaWRlcmVkIGEgbWF0Y2hcXHJcXG4gICAgICovXFxyXFxuICAgIE9aU2VhbEZpbmRlclBhdHRlcm5GaW5kZXIuZm91bmRQYXR0ZXJuQ3Jvc3MgPSBmdW5jdGlvbiAoc3RhdGVDb3VudCkge1xcclxcbiAgICAgICAgdmFyIHRvdGFsTW9kdWxlU2l6ZSA9IDA7XFxyXFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDU7IGkrKykge1xcclxcbiAgICAgICAgICAgIHZhciBjb3VudCA9IHN0YXRlQ291bnRbaV07XFxyXFxuICAgICAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgdG90YWxNb2R1bGVTaXplICs9IGNvdW50O1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgaWYgKHRvdGFsTW9kdWxlU2l6ZSA8IDcpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICB2YXIgbW9kdWxlU2l6ZSA9IHRvdGFsTW9kdWxlU2l6ZSAvIDcuMDtcXHJcXG4gICAgICAgIHZhciBtYXhWYXJpYW5jZSA9IG1vZHVsZVNpemUgLyAyLjA7XFxyXFxuICAgICAgICAvLyBBbGxvdyBsZXNzIHRoYW4gNTAlIHZhcmlhbmNlIGZyb20gMS0xLTMtMS0xIHByb3BvcnRpb25zXFxyXFxuICAgICAgICByZXR1cm4gTWF0aC5hYnMobW9kdWxlU2l6ZSAtIHN0YXRlQ291bnRbMF0pIDwgbWF4VmFyaWFuY2UgJiZcXHJcXG4gICAgICAgICAgICBNYXRoLmFicyhtb2R1bGVTaXplIC0gc3RhdGVDb3VudFsxXSkgPCBtYXhWYXJpYW5jZSAmJlxcclxcbiAgICAgICAgICAgIE1hdGguYWJzKDMuMCAqIG1vZHVsZVNpemUgLSBzdGF0ZUNvdW50WzJdKSA8IDMgKiBtYXhWYXJpYW5jZSAmJlxcclxcbiAgICAgICAgICAgIE1hdGguYWJzKG1vZHVsZVNpemUgLSBzdGF0ZUNvdW50WzNdKSA8IG1heFZhcmlhbmNlICYmXFxyXFxuICAgICAgICAgICAgTWF0aC5hYnMobW9kdWxlU2l6ZSAtIHN0YXRlQ291bnRbNF0pIDwgbWF4VmFyaWFuY2U7XFxyXFxuICAgIH07XFxyXFxuICAgIE9aU2VhbEZpbmRlclBhdHRlcm5GaW5kZXIucHJvdG90eXBlLmdldENyb3NzQ2hlY2tTdGF0ZUNvdW50ID0gZnVuY3Rpb24gKCkge1xcclxcbiAgICAgICAgdmFyIGNyb3NzQ2hlY2tTdGF0ZUNvdW50ID0gdGhpcy5jcm9zc0NoZWNrU3RhdGVDb3VudDtcXHJcXG4gICAgICAgIGNyb3NzQ2hlY2tTdGF0ZUNvdW50WzBdID0gMDtcXHJcXG4gICAgICAgIGNyb3NzQ2hlY2tTdGF0ZUNvdW50WzFdID0gMDtcXHJcXG4gICAgICAgIGNyb3NzQ2hlY2tTdGF0ZUNvdW50WzJdID0gMDtcXHJcXG4gICAgICAgIGNyb3NzQ2hlY2tTdGF0ZUNvdW50WzNdID0gMDtcXHJcXG4gICAgICAgIGNyb3NzQ2hlY2tTdGF0ZUNvdW50WzRdID0gMDtcXHJcXG4gICAgICAgIHJldHVybiBjcm9zc0NoZWNrU3RhdGVDb3VudDtcXHJcXG4gICAgfTtcXHJcXG4gICAgLyoqXFxyXFxuICAgICAqIEFmdGVyIGEgdmVydGljYWwgYW5kIGhvcml6b250YWwgc2NhbiBmaW5kcyBhIHBvdGVudGlhbCBmaW5kZXIgcGF0dGVybiwgdGhpcyBtZXRob2RcXHJcXG4gICAgICogXFxcImNyb3NzLWNyb3NzLWNyb3NzLWNoZWNrc1xcXCIgYnkgc2Nhbm5pbmcgZG93biBkaWFnb25hbGx5IHRocm91Z2ggdGhlIGNlbnRlciBvZiB0aGUgcG9zc2libGVcXHJcXG4gICAgICogZmluZGVyIHBhdHRlcm4gdG8gc2VlIGlmIHRoZSBzYW1lIHByb3BvcnRpb24gaXMgZGV0ZWN0ZWQuXFxyXFxuICAgICAqXFxyXFxuICAgICAqIEBwYXJhbSBzdGFydEkgcm93IHdoZXJlIGEgZmluZGVyIHBhdHRlcm4gd2FzIGRldGVjdGVkXFxyXFxuICAgICAqIEBwYXJhbSBjZW50ZXJKIGNlbnRlciBvZiB0aGUgc2VjdGlvbiB0aGF0IGFwcGVhcnMgdG8gY3Jvc3MgYSBmaW5kZXIgcGF0dGVyblxcclxcbiAgICAgKiBAcGFyYW0gbWF4Q291bnQgbWF4aW11bSByZWFzb25hYmxlIG51bWJlciBvZiBtb2R1bGVzIHRoYXQgc2hvdWxkIGJlXFxyXFxuICAgICAqICBvYnNlcnZlZCBpbiBhbnkgcmVhZGluZyBzdGF0ZSwgYmFzZWQgb24gdGhlIHJlc3VsdHMgb2YgdGhlIGhvcml6b250YWwgc2NhblxcclxcbiAgICAgKiBAcGFyYW0gb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwgVGhlIG9yaWdpbmFsIHN0YXRlIGNvdW50IHRvdGFsLlxcclxcbiAgICAgKiBAcmV0dXJuIHRydWUgaWYgcHJvcG9ydGlvbnMgYXJlIHdpdGhpbmcgZXhwZWN0ZWQgbGltaXRzXFxyXFxuICAgICAqL1xcclxcbiAgICBPWlNlYWxGaW5kZXJQYXR0ZXJuRmluZGVyLnByb3RvdHlwZS5jcm9zc0NoZWNrRGlhZ29uYWwgPSBmdW5jdGlvbiAoc3RhcnRJIC8qaW50Ki8sIGNlbnRlckogLyppbnQqLywgbWF4Q291bnQgLyppbnQqLywgb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwgLyppbnQqLykge1xcclxcbiAgICAgICAgdmFyIHN0YXRlQ291bnQgPSB0aGlzLmdldENyb3NzQ2hlY2tTdGF0ZUNvdW50KCk7XFxyXFxuICAgICAgICAvLyBTdGFydCBjb3VudGluZyB1cCwgbGVmdCBmcm9tIGNlbnRlciBmaW5kaW5nIGJsYWNrIGNlbnRlciBtYXNzXFxyXFxuICAgICAgICB2YXIgaSA9IDA7XFxyXFxuICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xcclxcbiAgICAgICAgd2hpbGUgKHN0YXJ0SSA+PSBpICYmIGNlbnRlckogPj0gaSAmJiBpbWFnZS5nZXQoY2VudGVySiAtIGksIHN0YXJ0SSAtIGkpKSB7XFxyXFxuICAgICAgICAgICAgc3RhdGVDb3VudFsyXSsrO1xcclxcbiAgICAgICAgICAgIGkrKztcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGlmIChzdGFydEkgPCBpIHx8IGNlbnRlckogPCBpKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgLy8gQ29udGludWUgdXAsIGxlZnQgZmluZGluZyB3aGl0ZSBzcGFjZVxcclxcbiAgICAgICAgd2hpbGUgKHN0YXJ0SSA+PSBpICYmIGNlbnRlckogPj0gaSAmJiAhaW1hZ2UuZ2V0KGNlbnRlckogLSBpLCBzdGFydEkgLSBpKSAmJlxcclxcbiAgICAgICAgICAgIHN0YXRlQ291bnRbMV0gPD0gbWF4Q291bnQpIHtcXHJcXG4gICAgICAgICAgICBzdGF0ZUNvdW50WzFdKys7XFxyXFxuICAgICAgICAgICAgaSsrO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgLy8gSWYgYWxyZWFkeSB0b28gbWFueSBtb2R1bGVzIGluIHRoaXMgc3RhdGUgb3IgcmFuIG9mZiB0aGUgZWRnZTpcXHJcXG4gICAgICAgIGlmIChzdGFydEkgPCBpIHx8IGNlbnRlckogPCBpIHx8IHN0YXRlQ291bnRbMV0gPiBtYXhDb3VudCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIC8vIENvbnRpbnVlIHVwLCBsZWZ0IGZpbmRpbmcgYmxhY2sgYm9yZGVyXFxyXFxuICAgICAgICB3aGlsZSAoc3RhcnRJID49IGkgJiYgY2VudGVySiA+PSBpICYmIGltYWdlLmdldChjZW50ZXJKIC0gaSwgc3RhcnRJIC0gaSkgJiZcXHJcXG4gICAgICAgICAgICBzdGF0ZUNvdW50WzBdIDw9IG1heENvdW50KSB7XFxyXFxuICAgICAgICAgICAgc3RhdGVDb3VudFswXSsrO1xcclxcbiAgICAgICAgICAgIGkrKztcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGlmIChzdGF0ZUNvdW50WzBdID4gbWF4Q291bnQpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICB2YXIgbWF4SSA9IGltYWdlLmdldEhlaWdodCgpO1xcclxcbiAgICAgICAgdmFyIG1heEogPSBpbWFnZS5nZXRXaWR0aCgpO1xcclxcbiAgICAgICAgLy8gTm93IGFsc28gY291bnQgZG93biwgcmlnaHQgZnJvbSBjZW50ZXJcXHJcXG4gICAgICAgIGkgPSAxO1xcclxcbiAgICAgICAgd2hpbGUgKHN0YXJ0SSArIGkgPCBtYXhJICYmIGNlbnRlckogKyBpIDwgbWF4SiAmJiBpbWFnZS5nZXQoY2VudGVySiArIGksIHN0YXJ0SSArIGkpKSB7XFxyXFxuICAgICAgICAgICAgc3RhdGVDb3VudFsyXSsrO1xcclxcbiAgICAgICAgICAgIGkrKztcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIC8vIFJhbiBvZmYgdGhlIGVkZ2U/XFxyXFxuICAgICAgICBpZiAoc3RhcnRJICsgaSA+PSBtYXhJIHx8IGNlbnRlckogKyBpID49IG1heEopIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICB3aGlsZSAoc3RhcnRJICsgaSA8IG1heEkgJiYgY2VudGVySiArIGkgPCBtYXhKICYmICFpbWFnZS5nZXQoY2VudGVySiArIGksIHN0YXJ0SSArIGkpICYmXFxyXFxuICAgICAgICAgICAgc3RhdGVDb3VudFszXSA8IG1heENvdW50KSB7XFxyXFxuICAgICAgICAgICAgc3RhdGVDb3VudFszXSsrO1xcclxcbiAgICAgICAgICAgIGkrKztcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGlmIChzdGFydEkgKyBpID49IG1heEkgfHwgY2VudGVySiArIGkgPj0gbWF4SiB8fCBzdGF0ZUNvdW50WzNdID49IG1heENvdW50KSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgd2hpbGUgKHN0YXJ0SSArIGkgPCBtYXhJICYmIGNlbnRlckogKyBpIDwgbWF4SiAmJiBpbWFnZS5nZXQoY2VudGVySiArIGksIHN0YXJ0SSArIGkpICYmXFxyXFxuICAgICAgICAgICAgc3RhdGVDb3VudFs0XSA8IG1heENvdW50KSB7XFxyXFxuICAgICAgICAgICAgc3RhdGVDb3VudFs0XSsrO1xcclxcbiAgICAgICAgICAgIGkrKztcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGlmIChzdGF0ZUNvdW50WzRdID49IG1heENvdW50KSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgLy8gSWYgd2UgZm91bmQgYSBmaW5kZXItcGF0dGVybi1saWtlIHNlY3Rpb24sIGJ1dCBpdHMgc2l6ZSBpcyBtb3JlIHRoYW4gMTAwJSBkaWZmZXJlbnQgdGhhblxcclxcbiAgICAgICAgLy8gdGhlIG9yaWdpbmFsLCBhc3N1bWUgaXQncyBhIGZhbHNlIHBvc2l0aXZlXFxyXFxuICAgICAgICB2YXIgc3RhdGVDb3VudFRvdGFsID0gc3RhdGVDb3VudFswXSArIHN0YXRlQ291bnRbMV0gKyBzdGF0ZUNvdW50WzJdICsgc3RhdGVDb3VudFszXSArIHN0YXRlQ291bnRbNF07XFxyXFxuICAgICAgICByZXR1cm4gTWF0aC5hYnMoc3RhdGVDb3VudFRvdGFsIC0gb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwpIDwgMiAqIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsICYmXFxyXFxuICAgICAgICAgICAgT1pTZWFsRmluZGVyUGF0dGVybkZpbmRlci5mb3VuZFBhdHRlcm5Dcm9zcyhzdGF0ZUNvdW50KTtcXHJcXG4gICAgfTtcXHJcXG4gICAgLyoqXFxyXFxuICAgICAqIDxwPkFmdGVyIGEgaG9yaXpvbnRhbCBzY2FuIGZpbmRzIGEgcG90ZW50aWFsIGZpbmRlciBwYXR0ZXJuLCB0aGlzIG1ldGhvZFxcclxcbiAgICAgKiBcXFwiY3Jvc3MtY2hlY2tzXFxcIiBieSBzY2FubmluZyBkb3duIHZlcnRpY2FsbHkgdGhyb3VnaCB0aGUgY2VudGVyIG9mIHRoZSBwb3NzaWJsZVxcclxcbiAgICAgKiBmaW5kZXIgcGF0dGVybiB0byBzZWUgaWYgdGhlIHNhbWUgcHJvcG9ydGlvbiBpcyBkZXRlY3RlZC48L3A+XFxyXFxuICAgICAqXFxyXFxuICAgICAqIEBwYXJhbSBzdGFydEkgcm93IHdoZXJlIGEgZmluZGVyIHBhdHRlcm4gd2FzIGRldGVjdGVkXFxyXFxuICAgICAqIEBwYXJhbSBjZW50ZXJKIGNlbnRlciBvZiB0aGUgc2VjdGlvbiB0aGF0IGFwcGVhcnMgdG8gY3Jvc3MgYSBmaW5kZXIgcGF0dGVyblxcclxcbiAgICAgKiBAcGFyYW0gbWF4Q291bnQgbWF4aW11bSByZWFzb25hYmxlIG51bWJlciBvZiBtb2R1bGVzIHRoYXQgc2hvdWxkIGJlXFxyXFxuICAgICAqIG9ic2VydmVkIGluIGFueSByZWFkaW5nIHN0YXRlLCBiYXNlZCBvbiB0aGUgcmVzdWx0cyBvZiB0aGUgaG9yaXpvbnRhbCBzY2FuXFxyXFxuICAgICAqIEByZXR1cm4gdmVydGljYWwgY2VudGVyIG9mIGZpbmRlciBwYXR0ZXJuLCBvciB7QGxpbmsgRmxvYXQjTmFOfSBpZiBub3QgZm91bmRcXHJcXG4gICAgICovXFxyXFxuICAgIE9aU2VhbEZpbmRlclBhdHRlcm5GaW5kZXIucHJvdG90eXBlLmNyb3NzQ2hlY2tWZXJ0aWNhbCA9IGZ1bmN0aW9uIChzdGFydEkgLyppbnQqLywgY2VudGVySiAvKmludCovLCBtYXhDb3VudCAvKmludCovLCBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCAvKmludCovKSB7XFxyXFxuICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xcclxcbiAgICAgICAgdmFyIG1heEkgPSBpbWFnZS5nZXRIZWlnaHQoKTtcXHJcXG4gICAgICAgIHZhciBzdGF0ZUNvdW50ID0gdGhpcy5nZXRDcm9zc0NoZWNrU3RhdGVDb3VudCgpO1xcclxcbiAgICAgICAgLy8gU3RhcnQgY291bnRpbmcgdXAgZnJvbSBjZW50ZXJcXHJcXG4gICAgICAgIHZhciBpID0gc3RhcnRJO1xcclxcbiAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiBpbWFnZS5nZXQoY2VudGVySiwgaSkpIHtcXHJcXG4gICAgICAgICAgICBzdGF0ZUNvdW50WzJdKys7XFxyXFxuICAgICAgICAgICAgaS0tO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgaWYgKGkgPCAwKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIE5hTjtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgIWltYWdlLmdldChjZW50ZXJKLCBpKSAmJiBzdGF0ZUNvdW50WzFdIDw9IG1heENvdW50KSB7XFxyXFxuICAgICAgICAgICAgc3RhdGVDb3VudFsxXSsrO1xcclxcbiAgICAgICAgICAgIGktLTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIC8vIElmIGFscmVhZHkgdG9vIG1hbnkgbW9kdWxlcyBpbiB0aGlzIHN0YXRlIG9yIHJhbiBvZmYgdGhlIGVkZ2U6XFxyXFxuICAgICAgICBpZiAoaSA8IDAgfHwgc3RhdGVDb3VudFsxXSA+IG1heENvdW50KSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIE5hTjtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgaW1hZ2UuZ2V0KGNlbnRlckosIGkpICYmIHN0YXRlQ291bnRbMF0gPD0gbWF4Q291bnQpIHtcXHJcXG4gICAgICAgICAgICBzdGF0ZUNvdW50WzBdKys7XFxyXFxuICAgICAgICAgICAgaS0tO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgaWYgKHN0YXRlQ291bnRbMF0gPiBtYXhDb3VudCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiBOYU47XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICAvLyBOb3cgYWxzbyBjb3VudCBkb3duIGZyb20gY2VudGVyXFxyXFxuICAgICAgICBpID0gc3RhcnRJICsgMTtcXHJcXG4gICAgICAgIHdoaWxlIChpIDwgbWF4SSAmJiBpbWFnZS5nZXQoY2VudGVySiwgaSkpIHtcXHJcXG4gICAgICAgICAgICBzdGF0ZUNvdW50WzJdKys7XFxyXFxuICAgICAgICAgICAgaSsrO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgaWYgKGkgPT09IG1heEkpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4gTmFOO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgd2hpbGUgKGkgPCBtYXhJICYmICFpbWFnZS5nZXQoY2VudGVySiwgaSkgJiYgc3RhdGVDb3VudFszXSA8IG1heENvdW50KSB7XFxyXFxuICAgICAgICAgICAgc3RhdGVDb3VudFszXSsrO1xcclxcbiAgICAgICAgICAgIGkrKztcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGlmIChpID09PSBtYXhJIHx8IHN0YXRlQ291bnRbM10gPj0gbWF4Q291bnQpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4gTmFOO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgd2hpbGUgKGkgPCBtYXhJICYmIGltYWdlLmdldChjZW50ZXJKLCBpKSAmJiBzdGF0ZUNvdW50WzRdIDwgbWF4Q291bnQpIHtcXHJcXG4gICAgICAgICAgICBzdGF0ZUNvdW50WzRdKys7XFxyXFxuICAgICAgICAgICAgaSsrO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgaWYgKHN0YXRlQ291bnRbNF0gPj0gbWF4Q291bnQpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4gTmFOO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgLy8gSWYgd2UgZm91bmQgYSBmaW5kZXItcGF0dGVybi1saWtlIHNlY3Rpb24sIGJ1dCBpdHMgc2l6ZSBpcyBtb3JlIHRoYW4gNDAlIGRpZmZlcmVudCB0aGFuXFxyXFxuICAgICAgICAvLyB0aGUgb3JpZ2luYWwsIGFzc3VtZSBpdCdzIGEgZmFsc2UgcG9zaXRpdmVcXHJcXG4gICAgICAgIHZhciBzdGF0ZUNvdW50VG90YWwgPSBzdGF0ZUNvdW50WzBdICsgc3RhdGVDb3VudFsxXSArIHN0YXRlQ291bnRbMl0gKyBzdGF0ZUNvdW50WzNdICtcXHJcXG4gICAgICAgICAgICBzdGF0ZUNvdW50WzRdO1xcclxcbiAgICAgICAgaWYgKDUgKiBNYXRoLmFicyhzdGF0ZUNvdW50VG90YWwgLSBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCkgPj0gMiAqIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIE5hTjtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHJldHVybiBPWlNlYWxGaW5kZXJQYXR0ZXJuRmluZGVyLmZvdW5kUGF0dGVybkNyb3NzKHN0YXRlQ291bnQpID8gT1pTZWFsRmluZGVyUGF0dGVybkZpbmRlci5jZW50ZXJGcm9tRW5kKHN0YXRlQ291bnQsIGkpIDogTmFOO1xcclxcbiAgICB9O1xcclxcbiAgICAvKipcXHJcXG4gICAgICogPHA+TGlrZSB7QGxpbmsgI2Nyb3NzQ2hlY2tWZXJ0aWNhbChpbnQsIGludCwgaW50LCBpbnQpfSwgYW5kIGluIGZhY3QgaXMgYmFzaWNhbGx5IGlkZW50aWNhbCxcXHJcXG4gICAgICogZXhjZXB0IGl0IHJlYWRzIGhvcml6b250YWxseSBpbnN0ZWFkIG9mIHZlcnRpY2FsbHkuIFRoaXMgaXMgdXNlZCB0byBjcm9zcy1jcm9zc1xcclxcbiAgICAgKiBjaGVjayBhIHZlcnRpY2FsIGNyb3NzIGNoZWNrIGFuZCBsb2NhdGUgdGhlIHJlYWwgY2VudGVyIG9mIHRoZSBhbGlnbm1lbnQgcGF0dGVybi48L3A+XFxyXFxuICAgICAqL1xcclxcbiAgICBPWlNlYWxGaW5kZXJQYXR0ZXJuRmluZGVyLnByb3RvdHlwZS5jcm9zc0NoZWNrSG9yaXpvbnRhbCA9IGZ1bmN0aW9uIChzdGFydEogLyppbnQqLywgY2VudGVySSAvKmludCovLCBtYXhDb3VudCAvKmludCovLCBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCAvKmludCovKSB7XFxyXFxuICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xcclxcbiAgICAgICAgdmFyIG1heEogPSBpbWFnZS5nZXRXaWR0aCgpO1xcclxcbiAgICAgICAgdmFyIHN0YXRlQ291bnQgPSB0aGlzLmdldENyb3NzQ2hlY2tTdGF0ZUNvdW50KCk7XFxyXFxuICAgICAgICB2YXIgaiA9IHN0YXJ0SjtcXHJcXG4gICAgICAgIHdoaWxlIChqID49IDAgJiYgaW1hZ2UuZ2V0KGosIGNlbnRlckkpKSB7XFxyXFxuICAgICAgICAgICAgc3RhdGVDb3VudFsyXSsrO1xcclxcbiAgICAgICAgICAgIGotLTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGlmIChqIDwgMCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiBOYU47XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICB3aGlsZSAoaiA+PSAwICYmICFpbWFnZS5nZXQoaiwgY2VudGVySSkgJiYgc3RhdGVDb3VudFsxXSA8PSBtYXhDb3VudCkge1xcclxcbiAgICAgICAgICAgIHN0YXRlQ291bnRbMV0rKztcXHJcXG4gICAgICAgICAgICBqLS07XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBpZiAoaiA8IDAgfHwgc3RhdGVDb3VudFsxXSA+IG1heENvdW50KSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIE5hTjtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHdoaWxlIChqID49IDAgJiYgaW1hZ2UuZ2V0KGosIGNlbnRlckkpICYmIHN0YXRlQ291bnRbMF0gPD0gbWF4Q291bnQpIHtcXHJcXG4gICAgICAgICAgICBzdGF0ZUNvdW50WzBdKys7XFxyXFxuICAgICAgICAgICAgai0tO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgaWYgKHN0YXRlQ291bnRbMF0gPiBtYXhDb3VudCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiBOYU47XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBqID0gc3RhcnRKICsgMTtcXHJcXG4gICAgICAgIHdoaWxlIChqIDwgbWF4SiAmJiBpbWFnZS5nZXQoaiwgY2VudGVySSkpIHtcXHJcXG4gICAgICAgICAgICBzdGF0ZUNvdW50WzJdKys7XFxyXFxuICAgICAgICAgICAgaisrO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgaWYgKGogPT09IG1heEopIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4gTmFOO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgd2hpbGUgKGogPCBtYXhKICYmICFpbWFnZS5nZXQoaiwgY2VudGVySSkgJiYgc3RhdGVDb3VudFszXSA8IG1heENvdW50KSB7XFxyXFxuICAgICAgICAgICAgc3RhdGVDb3VudFszXSsrO1xcclxcbiAgICAgICAgICAgIGorKztcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGlmIChqID09PSBtYXhKIHx8IHN0YXRlQ291bnRbM10gPj0gbWF4Q291bnQpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4gTmFOO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgd2hpbGUgKGogPCBtYXhKICYmIGltYWdlLmdldChqLCBjZW50ZXJJKSAmJiBzdGF0ZUNvdW50WzRdIDwgbWF4Q291bnQpIHtcXHJcXG4gICAgICAgICAgICBzdGF0ZUNvdW50WzRdKys7XFxyXFxuICAgICAgICAgICAgaisrO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgaWYgKHN0YXRlQ291bnRbNF0gPj0gbWF4Q291bnQpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4gTmFOO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgLy8gSWYgd2UgZm91bmQgYSBmaW5kZXItcGF0dGVybi1saWtlIHNlY3Rpb24sIGJ1dCBpdHMgc2l6ZSBpcyBzaWduaWZpY2FudGx5IGRpZmZlcmVudCB0aGFuXFxyXFxuICAgICAgICAvLyB0aGUgb3JpZ2luYWwsIGFzc3VtZSBpdCdzIGEgZmFsc2UgcG9zaXRpdmVcXHJcXG4gICAgICAgIHZhciBzdGF0ZUNvdW50VG90YWwgPSBzdGF0ZUNvdW50WzBdICsgc3RhdGVDb3VudFsxXSArIHN0YXRlQ291bnRbMl0gKyBzdGF0ZUNvdW50WzNdICtcXHJcXG4gICAgICAgICAgICBzdGF0ZUNvdW50WzRdO1xcclxcbiAgICAgICAgaWYgKDUgKiBNYXRoLmFicyhzdGF0ZUNvdW50VG90YWwgLSBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCkgPj0gb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4gTmFOO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgcmV0dXJuIE9aU2VhbEZpbmRlclBhdHRlcm5GaW5kZXIuZm91bmRQYXR0ZXJuQ3Jvc3Moc3RhdGVDb3VudCkgPyBPWlNlYWxGaW5kZXJQYXR0ZXJuRmluZGVyLmNlbnRlckZyb21FbmQoc3RhdGVDb3VudCwgaikgOiBOYU47XFxyXFxuICAgIH07XFxyXFxuICAgIC8qKlxcclxcbiAgICAgKiA8cD5UaGlzIGlzIGNhbGxlZCB3aGVuIGEgaG9yaXpvbnRhbCBzY2FuIGZpbmRzIGEgcG9zc2libGUgYWxpZ25tZW50IHBhdHRlcm4uIEl0IHdpbGxcXHJcXG4gICAgICogY3Jvc3MgY2hlY2sgd2l0aCBhIHZlcnRpY2FsIHNjYW4sIGFuZCBpZiBzdWNjZXNzZnVsLCB3aWxsLCBhaCwgY3Jvc3MtY3Jvc3MtY2hlY2tcXHJcXG4gICAgICogd2l0aCBhbm90aGVyIGhvcml6b250YWwgc2Nhbi4gVGhpcyBpcyBuZWVkZWQgcHJpbWFyaWx5IHRvIGxvY2F0ZSB0aGUgcmVhbCBob3Jpem9udGFsXFxyXFxuICAgICAqIGNlbnRlciBvZiB0aGUgcGF0dGVybiBpbiBjYXNlcyBvZiBleHRyZW1lIHNrZXcuXFxyXFxuICAgICAqIEFuZCB0aGVuIHdlIGNyb3NzLWNyb3NzLWNyb3NzIGNoZWNrIHdpdGggYW5vdGhlciBkaWFnb25hbCBzY2FuLjwvcD5cXHJcXG4gICAgICpcXHJcXG4gICAgICogPHA+SWYgdGhhdCBzdWNjZWVkcyB0aGUgZmluZGVyIHBhdHRlcm4gbG9jYXRpb24gaXMgYWRkZWQgdG8gYSBsaXN0IHRoYXQgdHJhY2tzXFxyXFxuICAgICAqIHRoZSBudW1iZXIgb2YgdGltZXMgZWFjaCBsb2NhdGlvbiBoYXMgYmVlbiBuZWFybHktbWF0Y2hlZCBhcyBhIGZpbmRlciBwYXR0ZXJuLlxcclxcbiAgICAgKiBFYWNoIGFkZGl0aW9uYWwgZmluZCBpcyBtb3JlIGV2aWRlbmNlIHRoYXQgdGhlIGxvY2F0aW9uIGlzIGluIGZhY3QgYSBmaW5kZXJcXHJcXG4gICAgICogcGF0dGVybiBjZW50ZXJcXHJcXG4gICAgICpcXHJcXG4gICAgICogQHBhcmFtIHN0YXRlQ291bnQgcmVhZGluZyBzdGF0ZSBtb2R1bGUgY291bnRzIGZyb20gaG9yaXpvbnRhbCBzY2FuXFxyXFxuICAgICAqIEBwYXJhbSBpIHJvdyB3aGVyZSBmaW5kZXIgcGF0dGVybiBtYXkgYmUgZm91bmRcXHJcXG4gICAgICogQHBhcmFtIGogZW5kIG9mIHBvc3NpYmxlIGZpbmRlciBwYXR0ZXJuIGluIHJvd1xcclxcbiAgICAgKiBAcGFyYW0gcHVyZUJhcmNvZGUgdHJ1ZSBpZiBpbiBcXFwicHVyZSBiYXJjb2RlXFxcIiBtb2RlXFxyXFxuICAgICAqIEByZXR1cm4gdHJ1ZSBpZiBhIGZpbmRlciBwYXR0ZXJuIGNhbmRpZGF0ZSB3YXMgZm91bmQgdGhpcyB0aW1lXFxyXFxuICAgICAqL1xcclxcbiAgICBPWlNlYWxGaW5kZXJQYXR0ZXJuRmluZGVyLnByb3RvdHlwZS5oYW5kbGVQb3NzaWJsZUNlbnRlciA9IGZ1bmN0aW9uIChzdGF0ZUNvdW50LCBpIC8qaW50Ki8sIGogLyppbnQqLykge1xcclxcbiAgICAgICAgdmFyIHN0YXRlQ291bnRUb3RhbCA9IHN0YXRlQ291bnRbMF0gKyBzdGF0ZUNvdW50WzFdICsgc3RhdGVDb3VudFsyXSArIHN0YXRlQ291bnRbM10gK1xcclxcbiAgICAgICAgICAgIHN0YXRlQ291bnRbNF07XFxyXFxuICAgICAgICB2YXIgY2VudGVySiA9IE9aU2VhbEZpbmRlclBhdHRlcm5GaW5kZXIuY2VudGVyRnJvbUVuZChzdGF0ZUNvdW50LCBqKTtcXHJcXG4gICAgICAgIHZhciBjZW50ZXJJID0gdGhpcy5jcm9zc0NoZWNrVmVydGljYWwoaSwgLyooaW50KSAqLyBNYXRoLmZsb29yKGNlbnRlckopLCBzdGF0ZUNvdW50WzJdLCBzdGF0ZUNvdW50VG90YWwpO1xcclxcbiAgICAgICAgaWYgKCFpc05hTihjZW50ZXJJKSkge1xcclxcbiAgICAgICAgICAgIC8vIFJlLWNyb3NzIGNoZWNrXFxyXFxuICAgICAgICAgICAgY2VudGVySiA9IHRoaXMuY3Jvc3NDaGVja0hvcml6b250YWwoLyooaW50KSAqLyBNYXRoLmZsb29yKGNlbnRlckopLCAvKihpbnQpICovIE1hdGguZmxvb3IoY2VudGVySSksIHN0YXRlQ291bnRbMl0sIHN0YXRlQ291bnRUb3RhbCk7XFxyXFxuICAgICAgICAgICAgaWYgKCFpc05hTihjZW50ZXJKKSAmJlxcclxcbiAgICAgICAgICAgICAgICAodGhpcy5jcm9zc0NoZWNrRGlhZ29uYWwoLyooaW50KSAqLyBNYXRoLmZsb29yKGNlbnRlckkpLCAvKihpbnQpICovIE1hdGguZmxvb3IoY2VudGVySiksIHN0YXRlQ291bnRbMl0sIHN0YXRlQ291bnRUb3RhbCkpKSB7XFxyXFxuICAgICAgICAgICAgICAgIHZhciBlc3RpbWF0ZWRNb2R1bGVTaXplID0gc3RhdGVDb3VudFRvdGFsIC8gNy4wO1xcclxcbiAgICAgICAgICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcXHJcXG4gICAgICAgICAgICAgICAgdmFyIHBvc3NpYmxlQ2VudGVycyA9IHRoaXMucG9zc2libGVDZW50ZXJzO1xcclxcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aF8xID0gcG9zc2libGVDZW50ZXJzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGhfMTsgaW5kZXgrKykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbnRlciA9IHBvc3NpYmxlQ2VudGVyc1tpbmRleF07XFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBMb29rIGZvciBhYm91dCB0aGUgc2FtZSBjZW50ZXIgYW5kIG1vZHVsZSBzaXplOlxcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbnRlci5hYm91dEVxdWFscyhlc3RpbWF0ZWRNb2R1bGVTaXplLCBjZW50ZXJJLCBjZW50ZXJKKSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlQ2VudGVyc1tpbmRleF0gPSBjZW50ZXIuY29tYmluZUVzdGltYXRlKGNlbnRlckksIGNlbnRlckosIGVzdGltYXRlZE1vZHVsZVNpemUpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBuZXcgT1pTZWFsRmluZGVyUGF0dGVybl8xLmRlZmF1bHQoY2VudGVySiwgY2VudGVySSwgZXN0aW1hdGVkTW9kdWxlU2l6ZSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZUNlbnRlcnMucHVzaChwb2ludCk7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcclxcbiAgICB9O1xcclxcbiAgICAvKipcXHJcXG4gICAgICogQHJldHVybiBudW1iZXIgb2Ygcm93cyB3ZSBjb3VsZCBzYWZlbHkgc2tpcCBkdXJpbmcgc2Nhbm5pbmcsIGJhc2VkIG9uIHRoZSBmaXJzdFxcclxcbiAgICAgKiAgICAgICAgIHR3byBmaW5kZXIgcGF0dGVybnMgdGhhdCBoYXZlIGJlZW4gbG9jYXRlZC4gSW4gc29tZSBjYXNlcyB0aGVpciBwb3NpdGlvbiB3aWxsXFxyXFxuICAgICAqICAgICAgICAgYWxsb3cgdXMgdG8gaW5mZXIgdGhhdCB0aGUgdGhpcmQgcGF0dGVybiBtdXN0IGxpZSBiZWxvdyBhIGNlcnRhaW4gcG9pbnQgZmFydGhlclxcclxcbiAgICAgKiAgICAgICAgIGRvd24gaW4gdGhlIGltYWdlLlxcclxcbiAgICAgKi9cXHJcXG4gICAgT1pTZWFsRmluZGVyUGF0dGVybkZpbmRlci5wcm90b3R5cGUuZmluZFJvd1NraXAgPSBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICB2YXIgZV8xLCBfYTtcXHJcXG4gICAgICAgIHZhciBtYXggPSB0aGlzLnBvc3NpYmxlQ2VudGVycy5sZW5ndGg7XFxyXFxuICAgICAgICBpZiAobWF4IDw9IDEpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4gMDtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHZhciBmaXJzdENvbmZpcm1lZENlbnRlciA9IG51bGw7XFxyXFxuICAgICAgICB0cnkge1xcclxcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5wb3NzaWJsZUNlbnRlcnMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XFxyXFxuICAgICAgICAgICAgICAgIHZhciBjZW50ZXIgPSBfYy52YWx1ZTtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKGNlbnRlci5nZXRDb3VudCgpID49IE9aU2VhbEZpbmRlclBhdHRlcm5GaW5kZXIuQ0VOVEVSX1FVT1JVTSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0Q29uZmlybWVkQ2VudGVyID09IG51bGwpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdENvbmZpcm1lZENlbnRlciA9IGNlbnRlcjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdHdvIGNvbmZpcm1lZCBjZW50ZXJzXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSG93IGZhciBkb3duIGNhbiB3ZSBza2lwIGJlZm9yZSByZXN1bWluZyBsb29raW5nIGZvciB0aGUgbmV4dFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhdHRlcm4/IEluIHRoZSB3b3JzdCBjYXNlLCBvbmx5IHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlmZmVyZW5jZSBpbiB0aGUgeCAvIHkgY29vcmRpbmF0ZXMgb2YgdGhlIHR3byBjZW50ZXJzLlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGNhc2Ugd2hlcmUgeW91IGZpbmQgdG9wIGxlZnQgbGFzdC5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhc1NraXBwZWQgPSB0cnVlO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAvKihpbnQpICovIE1hdGguZmxvb3IoKE1hdGguYWJzKGZpcnN0Q29uZmlybWVkQ2VudGVyLmdldFgoKSAtIGNlbnRlci5nZXRYKCkpIC1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoZmlyc3RDb25maXJtZWRDZW50ZXIuZ2V0WSgpIC0gY2VudGVyLmdldFkoKSkpIC8gMik7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxcclxcbiAgICAgICAgZmluYWxseSB7XFxyXFxuICAgICAgICAgICAgdHJ5IHtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICByZXR1cm4gMDtcXHJcXG4gICAgfTtcXHJcXG4gICAgLyoqXFxyXFxuICAgICAqIEByZXR1cm4gdHJ1ZSBpZmYgd2UgaGF2ZSBmb3VuZCBhdCBsZWFzdCAzIGZpbmRlciBwYXR0ZXJucyB0aGF0IGhhdmUgYmVlbiBkZXRlY3RlZFxcclxcbiAgICAgKiAgICAgICAgIGF0IGxlYXN0IHtAbGluayAjQ0VOVEVSX1FVT1JVTX0gdGltZXMgZWFjaCwgYW5kLCB0aGUgZXN0aW1hdGVkIG1vZHVsZSBzaXplIG9mIHRoZVxcclxcbiAgICAgKiAgICAgICAgIGNhbmRpZGF0ZXMgaXMgXFxcInByZXR0eSBzaW1pbGFyXFxcIlxcclxcbiAgICAgKi9cXHJcXG4gICAgT1pTZWFsRmluZGVyUGF0dGVybkZpbmRlci5wcm90b3R5cGUuaGF2ZU11bHRpcGx5Q29uZmlybWVkQ2VudGVycyA9IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgIHZhciBlXzIsIF9hLCBlXzMsIF9iO1xcclxcbiAgICAgICAgdmFyIGNvbmZpcm1lZENvdW50ID0gMDtcXHJcXG4gICAgICAgIHZhciB0b3RhbE1vZHVsZVNpemUgPSAwLjA7XFxyXFxuICAgICAgICB2YXIgbWF4ID0gdGhpcy5wb3NzaWJsZUNlbnRlcnMubGVuZ3RoO1xcclxcbiAgICAgICAgdHJ5IHtcXHJcXG4gICAgICAgICAgICBmb3IgKHZhciBfYyA9IF9fdmFsdWVzKHRoaXMucG9zc2libGVDZW50ZXJzKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xcclxcbiAgICAgICAgICAgICAgICB2YXIgcGF0dGVybiA9IF9kLnZhbHVlO1xcclxcbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybi5nZXRDb3VudCgpID49IE9aU2VhbEZpbmRlclBhdHRlcm5GaW5kZXIuQ0VOVEVSX1FVT1JVTSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlybWVkQ291bnQrKztcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsTW9kdWxlU2l6ZSArPSBwYXR0ZXJuLmdldEVzdGltYXRlZE1vZHVsZVNpemUoKTtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XFxyXFxuICAgICAgICBmaW5hbGx5IHtcXHJcXG4gICAgICAgICAgICB0cnkge1xcclxcbiAgICAgICAgICAgICAgICBpZiAoX2QgJiYgIV9kLmRvbmUgJiYgKF9hID0gX2MucmV0dXJuKSkgX2EuY2FsbChfYyk7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGlmIChjb25maXJtZWRDb3VudCA8IDMpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICAvLyBPSywgd2UgaGF2ZSBhdCBsZWFzdCAzIGNvbmZpcm1lZCBjZW50ZXJzLCBidXQsIGl0J3MgcG9zc2libGUgdGhhdCBvbmUgaXMgYSBcXFwiZmFsc2UgcG9zaXRpdmVcXFwiXFxyXFxuICAgICAgICAvLyBhbmQgdGhhdCB3ZSBuZWVkIHRvIGtlZXAgbG9va2luZy4gV2UgZGV0ZWN0IHRoaXMgYnkgYXNraW5nIGlmIHRoZSBlc3RpbWF0ZWQgbW9kdWxlIHNpemVzXFxyXFxuICAgICAgICAvLyB2YXJ5IHRvbyBtdWNoLiBXZSBhcmJpdHJhcmlseSBzYXkgdGhhdCB3aGVuIHRoZSB0b3RhbCBkZXZpYXRpb24gZnJvbSBhdmVyYWdlIGV4Y2VlZHNcXHJcXG4gICAgICAgIC8vIDUlIG9mIHRoZSB0b3RhbCBtb2R1bGUgc2l6ZSBlc3RpbWF0ZXMsIGl0J3MgdG9vIG11Y2guXFxyXFxuICAgICAgICB2YXIgYXZlcmFnZSA9IHRvdGFsTW9kdWxlU2l6ZSAvIG1heDtcXHJcXG4gICAgICAgIHZhciB0b3RhbERldmlhdGlvbiA9IDAuMDtcXHJcXG4gICAgICAgIHRyeSB7XFxyXFxuICAgICAgICAgICAgZm9yICh2YXIgX2UgPSBfX3ZhbHVlcyh0aGlzLnBvc3NpYmxlQ2VudGVycyksIF9mID0gX2UubmV4dCgpOyAhX2YuZG9uZTsgX2YgPSBfZS5uZXh0KCkpIHtcXHJcXG4gICAgICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBfZi52YWx1ZTtcXHJcXG4gICAgICAgICAgICAgICAgdG90YWxEZXZpYXRpb24gKz0gTWF0aC5hYnMocGF0dGVybi5nZXRFc3RpbWF0ZWRNb2R1bGVTaXplKCkgLSBhdmVyYWdlKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxcclxcbiAgICAgICAgZmluYWxseSB7XFxyXFxuICAgICAgICAgICAgdHJ5IHtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKF9mICYmICFfZi5kb25lICYmIChfYiA9IF9lLnJldHVybikpIF9iLmNhbGwoX2UpO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICByZXR1cm4gdG90YWxEZXZpYXRpb24gPD0gMC4wNSAqIHRvdGFsTW9kdWxlU2l6ZTtcXHJcXG4gICAgfTtcXHJcXG4gICAgLyoqXFxyXFxuICAgICAqIEByZXR1cm4gdGhlIDMgYmVzdCB7QGxpbmsgRmluZGVyUGF0dGVybn1zIGZyb20gb3VyIGxpc3Qgb2YgY2FuZGlkYXRlcy4gVGhlIFxcXCJiZXN0XFxcIiBhcmVcXHJcXG4gICAgICogICAgICAgICB0aG9zZSB0aGF0IGhhdmUgYmVlbiBkZXRlY3RlZCBhdCBsZWFzdCB7QGxpbmsgI0NFTlRFUl9RVU9SVU19IHRpbWVzLCBhbmQgd2hvc2UgbW9kdWxlXFxyXFxuICAgICAqICAgICAgICAgc2l6ZSBkaWZmZXJzIGZyb20gdGhlIGF2ZXJhZ2UgYW1vbmcgdGhvc2UgcGF0dGVybnMgdGhlIGxlYXN0XFxyXFxuICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgMyBzdWNoIGZpbmRlciBwYXR0ZXJucyBkbyBub3QgZXhpc3RcXHJcXG4gICAgICovXFxyXFxuICAgIE9aU2VhbEZpbmRlclBhdHRlcm5GaW5kZXIucHJvdG90eXBlLnNlbGVjdEJlc3RQYXR0ZXJucyA9IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgIHZhciBlXzQsIF9hLCBlXzUsIF9iO1xcclxcbiAgICAgICAgdmFyIHN0YXJ0U2l6ZSA9IHRoaXMucG9zc2libGVDZW50ZXJzLmxlbmd0aDtcXHJcXG4gICAgICAgIGlmIChzdGFydFNpemUgPCAzKSB7XFxyXFxuICAgICAgICAgICAgLy8gQ291bGRuJ3QgZmluZCBlbm91Z2ggZmluZGVyIHBhdHRlcm5zXFxyXFxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgdmFyIHBvc3NpYmxlQ2VudGVycyA9IHRoaXMucG9zc2libGVDZW50ZXJzO1xcclxcbiAgICAgICAgdmFyIGF2ZXJhZ2U7XFxyXFxuICAgICAgICAvLyBGaWx0ZXIgb3V0bGllciBwb3NzaWJpbGl0aWVzIHdob3NlIG1vZHVsZSBzaXplIGlzIHRvbyBkaWZmZXJlbnRcXHJcXG4gICAgICAgIGlmIChzdGFydFNpemUgPiAzKSB7XFxyXFxuICAgICAgICAgICAgLy8gQnV0IHdlIGNhbiBvbmx5IGFmZm9yZCB0byBkbyBzbyBpZiB3ZSBoYXZlIGF0IGxlYXN0IDQgcG9zc2liaWxpdGllcyB0byBjaG9vc2UgZnJvbVxcclxcbiAgICAgICAgICAgIHZhciB0b3RhbE1vZHVsZVNpemUgPSAwLjA7XFxyXFxuICAgICAgICAgICAgdmFyIHNxdWFyZSA9IDAuMDtcXHJcXG4gICAgICAgICAgICB0cnkge1xcclxcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYyA9IF9fdmFsdWVzKHRoaXMucG9zc2libGVDZW50ZXJzKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbnRlciA9IF9kLnZhbHVlO1xcclxcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpemUgPSBjZW50ZXIuZ2V0RXN0aW1hdGVkTW9kdWxlU2l6ZSgpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgdG90YWxNb2R1bGVTaXplICs9IHNpemU7XFxyXFxuICAgICAgICAgICAgICAgICAgICBzcXVhcmUgKz0gc2l6ZSAqIHNpemU7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgY2F0Y2ggKGVfNF8xKSB7IGVfNCA9IHsgZXJyb3I6IGVfNF8xIH07IH1cXHJcXG4gICAgICAgICAgICBmaW5hbGx5IHtcXHJcXG4gICAgICAgICAgICAgICAgdHJ5IHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChfZCAmJiAhX2QuZG9uZSAmJiAoX2EgPSBfYy5yZXR1cm4pKSBfYS5jYWxsKF9jKTtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yOyB9XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIGF2ZXJhZ2UgPSB0b3RhbE1vZHVsZVNpemUgLyBzdGFydFNpemU7XFxyXFxuICAgICAgICAgICAgdmFyIHN0ZERldiA9IE1hdGguc3FydChzcXVhcmUgLyBzdGFydFNpemUgLSBhdmVyYWdlICogYXZlcmFnZSk7XFxyXFxuICAgICAgICAgICAgcG9zc2libGVDZW50ZXJzLnNvcnQoXFxyXFxuICAgICAgICAgICAgLyoqXFxyXFxuICAgICAgICAgICAgICogPHA+T3JkZXJzIGJ5IGZ1cnRoZXN0IGZyb20gYXZlcmFnZTwvcD5cXHJcXG4gICAgICAgICAgICAgKi9cXHJcXG4gICAgICAgICAgICAvLyBGdXJ0aGVzdEZyb21BdmVyYWdlQ29tcGFyYXRvciBpbXBsZW1lbnRzIENvbXBhcmF0b3I8RmluZGVyUGF0dGVybj5cXHJcXG4gICAgICAgICAgICBmdW5jdGlvbiAoY2VudGVyMSwgY2VudGVyMikge1xcclxcbiAgICAgICAgICAgICAgICB2YXIgZEEgPSBNYXRoLmFicyhjZW50ZXIyLmdldEVzdGltYXRlZE1vZHVsZVNpemUoKSAtIGF2ZXJhZ2UpO1xcclxcbiAgICAgICAgICAgICAgICB2YXIgZEIgPSBNYXRoLmFicyhjZW50ZXIxLmdldEVzdGltYXRlZE1vZHVsZVNpemUoKSAtIGF2ZXJhZ2UpO1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gZEEgPCBkQiA/IC0xIDogZEEgPiBkQiA/IDEgOiAwO1xcclxcbiAgICAgICAgICAgIH0pO1xcclxcbiAgICAgICAgICAgIHZhciBsaW1pdCA9IE1hdGgubWF4KDAuMiAqIGF2ZXJhZ2UsIHN0ZERldik7XFxyXFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3NzaWJsZUNlbnRlcnMubGVuZ3RoICYmIHBvc3NpYmxlQ2VudGVycy5sZW5ndGggPiAzOyBpKyspIHtcXHJcXG4gICAgICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBwb3NzaWJsZUNlbnRlcnNbaV07XFxyXFxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhwYXR0ZXJuLmdldEVzdGltYXRlZE1vZHVsZVNpemUoKSAtIGF2ZXJhZ2UpID4gbGltaXQpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlQ2VudGVycy5zcGxpY2UoaSwgMSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBpLS07XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBpZiAocG9zc2libGVDZW50ZXJzLmxlbmd0aCA+IDMpIHtcXHJcXG4gICAgICAgICAgICAvLyBUaHJvdyBhd2F5IGFsbCBidXQgdGhvc2UgZmlyc3Qgc2l6ZSBjYW5kaWRhdGUgcG9pbnRzIHdlIGZvdW5kLlxcclxcbiAgICAgICAgICAgIHZhciB0b3RhbE1vZHVsZVNpemUgPSAwLjA7XFxyXFxuICAgICAgICAgICAgdHJ5IHtcXHJcXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcG9zc2libGVDZW50ZXJzXzEgPSBfX3ZhbHVlcyhwb3NzaWJsZUNlbnRlcnMpLCBwb3NzaWJsZUNlbnRlcnNfMV8xID0gcG9zc2libGVDZW50ZXJzXzEubmV4dCgpOyAhcG9zc2libGVDZW50ZXJzXzFfMS5kb25lOyBwb3NzaWJsZUNlbnRlcnNfMV8xID0gcG9zc2libGVDZW50ZXJzXzEubmV4dCgpKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zc2libGVDZW50ZXIgPSBwb3NzaWJsZUNlbnRlcnNfMV8xLnZhbHVlO1xcclxcbiAgICAgICAgICAgICAgICAgICAgdG90YWxNb2R1bGVTaXplICs9IHBvc3NpYmxlQ2VudGVyLmdldEVzdGltYXRlZE1vZHVsZVNpemUoKTtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICBjYXRjaCAoZV81XzEpIHsgZV81ID0geyBlcnJvcjogZV81XzEgfTsgfVxcclxcbiAgICAgICAgICAgIGZpbmFsbHkge1xcclxcbiAgICAgICAgICAgICAgICB0cnkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlQ2VudGVyc18xXzEgJiYgIXBvc3NpYmxlQ2VudGVyc18xXzEuZG9uZSAmJiAoX2IgPSBwb3NzaWJsZUNlbnRlcnNfMS5yZXR1cm4pKSBfYi5jYWxsKHBvc3NpYmxlQ2VudGVyc18xKTtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNSkgdGhyb3cgZV81LmVycm9yOyB9XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIGF2ZXJhZ2UgPSB0b3RhbE1vZHVsZVNpemUgLyBwb3NzaWJsZUNlbnRlcnMubGVuZ3RoO1xcclxcbiAgICAgICAgICAgIHBvc3NpYmxlQ2VudGVycy5zb3J0KFxcclxcbiAgICAgICAgICAgIC8qKlxcclxcbiAgICAgICAgICAgICAqIDxwPk9yZGVycyBieSB7QGxpbmsgRmluZGVyUGF0dGVybiNnZXRDb3VudCgpfSwgZGVzY2VuZGluZy48L3A+XFxyXFxuICAgICAgICAgICAgICovXFxyXFxuICAgICAgICAgICAgLy8gQ2VudGVyQ29tcGFyYXRvciBpbXBsZW1lbnRzIENvbXBhcmF0b3I8RmluZGVyUGF0dGVybj5cXHJcXG4gICAgICAgICAgICBmdW5jdGlvbiAoY2VudGVyMSwgY2VudGVyMikge1xcclxcbiAgICAgICAgICAgICAgICBpZiAoY2VudGVyMi5nZXRDb3VudCgpID09PSBjZW50ZXIxLmdldENvdW50KCkpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHZhciBkQSA9IE1hdGguYWJzKGNlbnRlcjIuZ2V0RXN0aW1hdGVkTW9kdWxlU2l6ZSgpIC0gYXZlcmFnZSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB2YXIgZEIgPSBNYXRoLmFicyhjZW50ZXIxLmdldEVzdGltYXRlZE1vZHVsZVNpemUoKSAtIGF2ZXJhZ2UpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRBIDwgZEIgPyAxIDogZEEgPiBkQiA/IC0xIDogMDtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjZW50ZXIyLmdldENvdW50KCkgLSBjZW50ZXIxLmdldENvdW50KCk7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9KTtcXHJcXG4gICAgICAgICAgICBwb3NzaWJsZUNlbnRlcnMuc3BsaWNlKDMpOyAvLyB0aGlzIGlzIG5vdCByZWFseSBuZWNlc3NhcnkgYXMgd2Ugb25seSByZXR1cm4gZmlyc3QgMyBhbnl3YXlcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHJldHVybiBbXFxyXFxuICAgICAgICAgICAgcG9zc2libGVDZW50ZXJzWzBdLFxcclxcbiAgICAgICAgICAgIHBvc3NpYmxlQ2VudGVyc1sxXSxcXHJcXG4gICAgICAgICAgICBwb3NzaWJsZUNlbnRlcnNbMl1cXHJcXG4gICAgICAgIF07XFxyXFxuICAgIH07XFxyXFxuICAgIE9aU2VhbEZpbmRlclBhdHRlcm5GaW5kZXIuQ0VOVEVSX1FVT1JVTSA9IDI7XFxyXFxuICAgIE9aU2VhbEZpbmRlclBhdHRlcm5GaW5kZXIuTUlOX1NLSVAgPSAzOyAvLyAxIHBpeGVsL21vZHVsZSB0aW1lcyAzIG1vZHVsZXMvY2VudGVyXFxyXFxuICAgIE9aU2VhbEZpbmRlclBhdHRlcm5GaW5kZXIuTUFYX01PRFVMRVMgPSA1NzsgLy8gc3VwcG9ydCB1cCB0byB2ZXJzaW9uIDEwIGZvciBtb2JpbGUgY2xpZW50c1xcclxcbiAgICByZXR1cm4gT1pTZWFsRmluZGVyUGF0dGVybkZpbmRlcjtcXHJcXG59KCkpO1xcclxcbmV4cG9ydHMuZGVmYXVsdCA9IE9aU2VhbEZpbmRlclBhdHRlcm5GaW5kZXI7XFxyXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vT1pTZWFsUmVjb2duaXRpb24vLi9zcmMvY29yZS9xcmNvZGUvZGV0ZWN0b3IvT1pTZWFsRmluZGVyUGF0dGVybkZpbmRlci50cz9cIik7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqKi8gfSksXHJcblxyXG4gICAgICAgICAgICAvKioqLyBcIi4vc3JjL2NvcmUvdXRpbC9GbG9hdC50c1wiOlxyXG4gICAgICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcclxuICAgICAgICAgICAgICAhKioqIC4vc3JjL2NvcmUvdXRpbC9GbG9hdC50cyAqKiohXHJcbiAgICAgICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuICAgICAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXHJcbiAgICAgICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cclxuICAgICAgICAgICAgLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuICAgICAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgICAgICAgICAgICAgZXZhbChcIlxcclxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHsgdmFsdWU6IHRydWUgfSk7XFxyXFxuLyoqXFxyXFxuICogUG9ueWZpbGwgZm9yIEphdmEncyBGbG9hdCBjbGFzcy5cXHJcXG4gKi9cXHJcXG52YXIgRmxvYXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XFxyXFxuICAgIGZ1bmN0aW9uIEZsb2F0KCkge1xcclxcbiAgICB9XFxyXFxuICAgIC8qKlxcclxcbiAgICAgKiBTaW5jVFMgaGFzIG5vIGRpZmZlcmVuY2UgYmV0d2VlbiBpbnQgYW5kIGZsb2F0LCB0aGVyZSdzIGFsbCBudW1iZXJzLFxcclxcbiAgICAgKiB0aGlzIGlzIHVzZWQgb25seSB0byBwb2x5ZmlsbCBKYXZhIGNvZGUuXFxyXFxuICAgICAqL1xcclxcbiAgICBGbG9hdC5mbG9hdFRvSW50Qml0cyA9IGZ1bmN0aW9uIChmKSB7XFxyXFxuICAgICAgICByZXR1cm4gZjtcXHJcXG4gICAgfTtcXHJcXG4gICAgLyoqXFxyXFxuICAgICAqIFRoZSBmbG9hdCBtYXggdmFsdWUgaW4gSlMgaXMgdGhlIG51bWJlciBtYXggdmFsdWUuXFxyXFxuICAgICAqL1xcclxcbiAgICBGbG9hdC5NQVhfVkFMVUUgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcXHJcXG4gICAgcmV0dXJuIEZsb2F0O1xcclxcbn0oKSk7XFxyXFxuZXhwb3J0cy5kZWZhdWx0ID0gRmxvYXQ7XFxyXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vT1pTZWFsUmVjb2duaXRpb24vLi9zcmMvY29yZS91dGlsL0Zsb2F0LnRzP1wiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKioqLyB9KSxcclxuXHJcbiAgICAgICAgICAgIC8qKiovIFwiLi9zcmMvY29yZS91dGlsL1N0cmluZ0VuY29kaW5nLnRzXCI6XHJcbiAgICAgICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxyXG4gICAgICAgICAgICAgICEqKiogLi9zcmMvY29yZS91dGlsL1N0cmluZ0VuY29kaW5nLnRzICoqKiFcclxuICAgICAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cclxuICAgICAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xyXG4gICAgICAgICAgICAvKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICAgICAgICAgICAgICBldmFsKFwiXFxyXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcXHJcXG52YXIgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL1Vuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uICovIFxcXCIuL3NyYy9jb3JlL1Vuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uLnRzXFxcIik7XFxyXFxudmFyIENoYXJhY3RlclNldEVDSV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vY29tbW9uL0NoYXJhY3RlclNldEVDSSAqLyBcXFwiLi9zcmMvY29yZS9jb21tb24vQ2hhcmFjdGVyU2V0RUNJLnRzXFxcIik7XFxyXFxuLyoqXFxyXFxuICogUmVzcG9uc2libGUgZm9yIGVuL2RlY29kaW5nIHN0cmluZ3MuXFxyXFxuICovXFxyXFxudmFyIFN0cmluZ0VuY29kaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xcclxcbiAgICBmdW5jdGlvbiBTdHJpbmdFbmNvZGluZygpIHtcXHJcXG4gICAgfVxcclxcbiAgICAvKipcXHJcXG4gICAgICogRGVjb2RlcyBzb21lIFVpbnQ4QXJyYXkgdG8gYSBzdHJpbmcgZm9ybWF0LlxcclxcbiAgICAgKi9cXHJcXG4gICAgU3RyaW5nRW5jb2RpbmcuZGVjb2RlID0gZnVuY3Rpb24gKGJ5dGVzLCBlbmNvZGluZykge1xcclxcbiAgICAgICAgdmFyIGVuY29kaW5nTmFtZSA9IHRoaXMuZW5jb2RpbmdOYW1lKGVuY29kaW5nKTtcXHJcXG4gICAgICAgIGlmICh0aGlzLmN1c3RvbURlY29kZXIpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21EZWNvZGVyKGJ5dGVzLCBlbmNvZGluZ05hbWUpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgLy8gSW5jcmVhc2VzIGJyb3dzZXIgc3VwcG9ydC5cXHJcXG4gICAgICAgIGlmICh0eXBlb2YgVGV4dERlY29kZXIgPT09ICd1bmRlZmluZWQnIHx8IHRoaXMuc2hvdWxkRGVjb2RlT25GYWxsYmFjayhlbmNvZGluZ05hbWUpKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlRmFsbGJhY2soYnl0ZXMsIGVuY29kaW5nTmFtZSk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKGVuY29kaW5nTmFtZSkuZGVjb2RlKGJ5dGVzKTtcXHJcXG4gICAgfTtcXHJcXG4gICAgLyoqXFxyXFxuICAgICAqIENoZWNrcyBpZiB0aGUgZGVjb2RpbmcgbWV0aG9kIHNob3VsZCB1c2UgdGhlIGZhbGxiYWNrIGZvciBkZWNvZGluZ1xcclxcbiAgICAgKiBvbmNlIE5vZGUgVGV4dERlY29kZXIgZG9lc24ndCBzdXBwb3J0IGFsbCBlbmNvZGluZyBmb3JtYXRzLlxcclxcbiAgICAgKlxcclxcbiAgICAgKiBAcGFyYW0gZW5jb2RpbmdOYW1lXFxyXFxuICAgICAqL1xcclxcbiAgICBTdHJpbmdFbmNvZGluZy5zaG91bGREZWNvZGVPbkZhbGxiYWNrID0gZnVuY3Rpb24gKGVuY29kaW5nTmFtZSkge1xcclxcbiAgICAgICAgcmV0dXJuICFTdHJpbmdFbmNvZGluZy5pc0Jyb3dzZXIoKSAmJiBlbmNvZGluZ05hbWUgPT09ICdJU08tODg1OS0xJztcXHJcXG4gICAgfTtcXHJcXG4gICAgLyoqXFxyXFxuICAgICAqIEVuY29kZXMgc29tZSBzdHJpbmcgaW50byBhIFVpbnQ4QXJyYXkuXFxyXFxuICAgICAqL1xcclxcbiAgICBTdHJpbmdFbmNvZGluZy5lbmNvZGUgPSBmdW5jdGlvbiAocywgZW5jb2RpbmcpIHtcXHJcXG4gICAgICAgIHZhciBlbmNvZGluZ05hbWUgPSB0aGlzLmVuY29kaW5nTmFtZShlbmNvZGluZyk7XFxyXFxuICAgICAgICBpZiAodGhpcy5jdXN0b21FbmNvZGVyKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VzdG9tRW5jb2RlcihzLCBlbmNvZGluZ05hbWUpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgLy8gSW5jcmVhc2VzIGJyb3dzZXIgc3VwcG9ydC5cXHJcXG4gICAgICAgIGlmICh0eXBlb2YgVGV4dEVuY29kZXIgPT09ICd1bmRlZmluZWQnKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlRmFsbGJhY2socyk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICAvLyBUZXh0RW5jb2RlciBvbmx5IGVuY29kZXMgdG8gVVRGOCBieSBkZWZhdWx0IGFzIHNwZWNpZmllZCBieSBlbmNvZGluZy5zcGVjLndoYXR3Zy5vcmdcXHJcXG4gICAgICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocyk7XFxyXFxuICAgIH07XFxyXFxuICAgIFN0cmluZ0VuY29kaW5nLmlzQnJvd3NlciA9IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgIHJldHVybiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYge30udG9TdHJpbmcuY2FsbCh3aW5kb3cpID09PSAnW29iamVjdCBXaW5kb3ddJyk7XFxyXFxuICAgIH07XFxyXFxuICAgIC8qKlxcclxcbiAgICAgKiBSZXR1cm5zIHRoZSBzdHJpbmcgdmFsdWUgZnJvbSBzb21lIGVuY29kaW5nIGNoYXJhY3RlciBzZXQuXFxyXFxuICAgICAqL1xcclxcbiAgICBTdHJpbmdFbmNvZGluZy5lbmNvZGluZ05hbWUgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcXHJcXG4gICAgICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXFxyXFxuICAgICAgICAgICAgPyBlbmNvZGluZ1xcclxcbiAgICAgICAgICAgIDogZW5jb2RpbmcuZ2V0TmFtZSgpO1xcclxcbiAgICB9O1xcclxcbiAgICAvKipcXHJcXG4gICAgICogUmV0dXJucyBjaGFyYWN0ZXIgc2V0IGZyb20gc29tZSBlbmNvZGluZyBjaGFyYWN0ZXIgc2V0LlxcclxcbiAgICAgKi9cXHJcXG4gICAgU3RyaW5nRW5jb2RpbmcuZW5jb2RpbmdDaGFyYWN0ZXJTZXQgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcXHJcXG4gICAgICAgIGlmIChlbmNvZGluZyBpbnN0YW5jZW9mIENoYXJhY3RlclNldEVDSV8xLmRlZmF1bHQpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4gZW5jb2Rpbmc7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICByZXR1cm4gQ2hhcmFjdGVyU2V0RUNJXzEuZGVmYXVsdC5nZXRDaGFyYWN0ZXJTZXRFQ0lCeU5hbWUoZW5jb2RpbmcpO1xcclxcbiAgICB9O1xcclxcbiAgICAvKipcXHJcXG4gICAgICogUnVucyBhIGZhbGxiYWNrIGZvciB0aGUgbmF0aXZlIGRlY29kaW5nIGZ1bmNpb24uXFxyXFxuICAgICAqL1xcclxcbiAgICBTdHJpbmdFbmNvZGluZy5kZWNvZGVGYWxsYmFjayA9IGZ1bmN0aW9uIChieXRlcywgZW5jb2RpbmcpIHtcXHJcXG4gICAgICAgIHZhciBjaGFyYWN0ZXJTZXQgPSB0aGlzLmVuY29kaW5nQ2hhcmFjdGVyU2V0KGVuY29kaW5nKTtcXHJcXG4gICAgICAgIGlmIChTdHJpbmdFbmNvZGluZy5pc0RlY29kZUZhbGxiYWNrU3VwcG9ydGVkKGNoYXJhY3RlclNldCkpIHtcXHJcXG4gICAgICAgICAgICB2YXIgcyA9ICcnO1xcclxcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGhfMSA9IGJ5dGVzLmxlbmd0aDsgaSA8IGxlbmd0aF8xOyBpKyspIHtcXHJcXG4gICAgICAgICAgICAgICAgdmFyIGggPSBieXRlc1tpXS50b1N0cmluZygxNik7XFxyXFxuICAgICAgICAgICAgICAgIGlmIChoLmxlbmd0aCA8IDIpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGggPSAnMCcgKyBoO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIHMgKz0gJyUnICsgaDtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGlmIChjaGFyYWN0ZXJTZXQuZXF1YWxzKENoYXJhY3RlclNldEVDSV8xLmRlZmF1bHQuVW5pY29kZUJpZ1VubWFya2VkKSkge1xcclxcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50MTZBcnJheShieXRlcy5idWZmZXIpKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbl8xLmRlZmF1bHQoXFxcIkVuY29kaW5nIFxcXCIgKyB0aGlzLmVuY29kaW5nTmFtZShlbmNvZGluZykgKyBcXFwiIG5vdCBzdXBwb3J0ZWQgYnkgZmFsbGJhY2suXFxcIik7XFxyXFxuICAgIH07XFxyXFxuICAgIFN0cmluZ0VuY29kaW5nLmlzRGVjb2RlRmFsbGJhY2tTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoY2hhcmFjdGVyU2V0KSB7XFxyXFxuICAgICAgICByZXR1cm4gY2hhcmFjdGVyU2V0LmVxdWFscyhDaGFyYWN0ZXJTZXRFQ0lfMS5kZWZhdWx0LlVURjgpIHx8XFxyXFxuICAgICAgICAgICAgY2hhcmFjdGVyU2V0LmVxdWFscyhDaGFyYWN0ZXJTZXRFQ0lfMS5kZWZhdWx0LklTTzg4NTlfMSkgfHxcXHJcXG4gICAgICAgICAgICBjaGFyYWN0ZXJTZXQuZXF1YWxzKENoYXJhY3RlclNldEVDSV8xLmRlZmF1bHQuQVNDSUkpO1xcclxcbiAgICB9O1xcclxcbiAgICAvKipcXHJcXG4gICAgICogUnVucyBhIGZhbGxiYWNrIGZvciB0aGUgbmF0aXZlIGVuY29kaW5nIGZ1bmNpb24uXFxyXFxuICAgICAqXFxyXFxuICAgICAqIEBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE3MTkyODQ1LzQzNjc2ODNcXHJcXG4gICAgICovXFxyXFxuICAgIFN0cmluZ0VuY29kaW5nLmVuY29kZUZhbGxiYWNrID0gZnVuY3Rpb24gKHMpIHtcXHJcXG4gICAgICAgIHZhciBlbmNvZGVkVVJJc3RyaW5nID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQocykpKTtcXHJcXG4gICAgICAgIHZhciBjaGFyTGlzdCA9IGVuY29kZWRVUklzdHJpbmcuc3BsaXQoJycpO1xcclxcbiAgICAgICAgdmFyIHVpbnRBcnJheSA9IFtdO1xcclxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFyTGlzdC5sZW5ndGg7IGkrKykge1xcclxcbiAgICAgICAgICAgIHVpbnRBcnJheS5wdXNoKGNoYXJMaXN0W2ldLmNoYXJDb2RlQXQoMCkpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHVpbnRBcnJheSk7XFxyXFxuICAgIH07XFxyXFxuICAgIHJldHVybiBTdHJpbmdFbmNvZGluZztcXHJcXG59KCkpO1xcclxcbmV4cG9ydHMuZGVmYXVsdCA9IFN0cmluZ0VuY29kaW5nO1xcclxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL09aU2VhbFJlY29nbml0aW9uLy4vc3JjL2NvcmUvdXRpbC9TdHJpbmdFbmNvZGluZy50cz9cIik7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqKi8gfSksXHJcblxyXG4gICAgICAgICAgICAvKioqLyBcIi4vc3JjL2luZGV4LnRzXCI6XHJcbiAgICAgICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKiohKlxcXHJcbiAgICAgICAgICAgICAgISoqKiAuL3NyYy9pbmRleC50cyAqKiohXHJcbiAgICAgICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cclxuICAgICAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xyXG4gICAgICAgICAgICAvKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICAgICAgICAgICAgICBldmFsKFwiXFxyXFxuLy9leHBvcnQgKiBmcm9tICcuL2Jyb3dzZXInO1xcclxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHsgdmFsdWU6IHRydWUgfSk7XFxyXFxuLy8vLyBFeGNlcHRpb25zXFxyXFxuLy9leHBvcnQgeyBkZWZhdWx0IGFzIEFyZ3VtZW50RXhjZXB0aW9uIH0gZnJvbSAnLi9jb3JlL0FyZ3VtZW50RXhjZXB0aW9uJztcXHJcXG4vL2V4cG9ydCB7IGRlZmF1bHQgYXMgQXJpdGhtZXRpY0V4Y2VwdGlvbiB9IGZyb20gJy4vY29yZS9Bcml0aG1ldGljRXhjZXB0aW9uJztcXHJcXG4vL2V4cG9ydCB7IGRlZmF1bHQgYXMgQ2hlY2tzdW1FeGNlcHRpb24gfSBmcm9tICcuL2NvcmUvQ2hlY2tzdW1FeGNlcHRpb24nO1xcclxcbi8vZXhwb3J0IHsgZGVmYXVsdCBhcyBFeGNlcHRpb24gfSBmcm9tICcuL2NvcmUvRXhjZXB0aW9uJztcXHJcXG4vL2V4cG9ydCB7IGRlZmF1bHQgYXMgRm9ybWF0RXhjZXB0aW9uIH0gZnJvbSAnLi9jb3JlL0Zvcm1hdEV4Y2VwdGlvbic7XFxyXFxuLy9leHBvcnQgeyBkZWZhdWx0IGFzIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiB9IGZyb20gJy4vY29yZS9JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24nO1xcclxcbi8vZXhwb3J0IHsgZGVmYXVsdCBhcyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24gfSBmcm9tICcuL2NvcmUvSWxsZWdhbFN0YXRlRXhjZXB0aW9uJztcXHJcXG4vL2V4cG9ydCB7IGRlZmF1bHQgYXMgTm90Rm91bmRFeGNlcHRpb24gfSBmcm9tICcuL2NvcmUvTm90Rm91bmRFeGNlcHRpb24nO1xcclxcbi8vZXhwb3J0IHsgZGVmYXVsdCBhcyBSZWFkZXJFeGNlcHRpb24gfSBmcm9tICcuL2NvcmUvUmVhZGVyRXhjZXB0aW9uJztcXHJcXG4vL2V4cG9ydCB7IGRlZmF1bHQgYXMgUmVlZFNvbG9tb25FeGNlcHRpb24gfSBmcm9tICcuL2NvcmUvUmVlZFNvbG9tb25FeGNlcHRpb24nO1xcclxcbi8vZXhwb3J0IHsgZGVmYXVsdCBhcyBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbiB9IGZyb20gJy4vY29yZS9VbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbic7XFxyXFxuLy9leHBvcnQgeyBkZWZhdWx0IGFzIFdyaXRlckV4Y2VwdGlvbiB9IGZyb20gJy4vY29yZS9Xcml0ZXJFeGNlcHRpb24nO1xcclxcbi8vLy8gY29yZVxcclxcbi8vZXhwb3J0IHsgZGVmYXVsdCBhcyBCYXJjb2RlRm9ybWF0IH0gZnJvbSAnLi9jb3JlL0JhcmNvZGVGb3JtYXQnO1xcclxcbi8vZXhwb3J0IHsgZGVmYXVsdCBhcyBCaW5hcml6ZXIgfSBmcm9tICcuL2NvcmUvQmluYXJpemVyJztcXHJcXG4vL2V4cG9ydCB7IGRlZmF1bHQgYXMgQmluYXJ5Qml0bWFwIH0gZnJvbSAnLi9jb3JlL0JpbmFyeUJpdG1hcCc7XFxyXFxuLy9leHBvcnQgeyBkZWZhdWx0IGFzIERlY29kZUhpbnRUeXBlIH0gZnJvbSAnLi9jb3JlL0RlY29kZUhpbnRUeXBlJztcXHJcXG4vL2V4cG9ydCB7IGRlZmF1bHQgYXMgSW52ZXJ0ZWRMdW1pbmFuY2VTb3VyY2UgfSBmcm9tICcuL2NvcmUvSW52ZXJ0ZWRMdW1pbmFuY2VTb3VyY2UnO1xcclxcbi8vZXhwb3J0IHsgZGVmYXVsdCBhcyBMdW1pbmFuY2VTb3VyY2UgfSBmcm9tICcuL2NvcmUvTHVtaW5hbmNlU291cmNlJztcXHJcXG4vL2V4cG9ydCB7IGRlZmF1bHQgYXMgTXVsdGlGb3JtYXRSZWFkZXIgfSBmcm9tICcuL2NvcmUvTXVsdGlGb3JtYXRSZWFkZXInO1xcclxcbi8vZXhwb3J0IHsgZGVmYXVsdCBhcyBNdWx0aUZvcm1hdFdyaXRlciB9IGZyb20gJy4vY29yZS9NdWx0aUZvcm1hdFdyaXRlcic7XFxyXFxuLy9leHBvcnQgeyBkZWZhdWx0IGFzIFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZSB9IGZyb20gJy4vY29yZS9QbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UnO1xcclxcbi8vZXhwb3J0IHsgZGVmYXVsdCBhcyBSZWFkZXIgfSBmcm9tICcuL2NvcmUvUmVhZGVyJztcXHJcXG4vL2V4cG9ydCB7IGRlZmF1bHQgYXMgUmVzdWx0IH0gZnJvbSAnLi9jb3JlL1Jlc3VsdCc7XFxyXFxuLy9leHBvcnQgeyBkZWZhdWx0IGFzIFJlc3VsdE1ldGFkYXRhVHlwZSB9IGZyb20gJy4vY29yZS9SZXN1bHRNZXRhZGF0YVR5cGUnO1xcclxcbi8vZXhwb3J0IHsgZGVmYXVsdCBhcyBSZXN1bHRQb2ludENhbGxiYWNrIH0gZnJvbSAnLi9jb3JlL1Jlc3VsdFBvaW50Q2FsbGJhY2snO1xcclxcbi8vZXhwb3J0IHsgZGVmYXVsdCBhcyBSR0JMdW1pbmFuY2VTb3VyY2UgfSBmcm9tICcuL2NvcmUvUkdCTHVtaW5hbmNlU291cmNlJztcXHJcXG4vL2V4cG9ydCB7IGRlZmF1bHQgYXMgV3JpdGVyIH0gZnJvbSAnLi9jb3JlL1dyaXRlcic7XFxyXFxuLy8vLyBjb3JlL2NvbW1vblxcclxcbi8vZXhwb3J0IHsgZGVmYXVsdCBhcyBCaXRBcnJheSB9IGZyb20gJy4vY29yZS9jb21tb24vQml0QXJyYXknO1xcclxcbi8vZXhwb3J0IHsgZGVmYXVsdCBhcyBCaXRNYXRyaXggfSBmcm9tICcuL2NvcmUvY29tbW9uL0JpdE1hdHJpeCc7XFxyXFxuLy9leHBvcnQgeyBkZWZhdWx0IGFzIEJpdFNvdXJjZSB9IGZyb20gJy4vY29yZS9jb21tb24vQml0U291cmNlJztcXHJcXG4vL2V4cG9ydCB7IGRlZmF1bHQgYXMgQ2hhcmFjdGVyU2V0RUNJIH0gZnJvbSAnLi9jb3JlL2NvbW1vbi9DaGFyYWN0ZXJTZXRFQ0knO1xcclxcbi8vZXhwb3J0IHsgZGVmYXVsdCBhcyBEZWNvZGVyUmVzdWx0IH0gZnJvbSAnLi9jb3JlL2NvbW1vbi9EZWNvZGVyUmVzdWx0JztcXHJcXG4vL2V4cG9ydCB7IGRlZmF1bHQgYXMgRGVmYXVsdEdyaWRTYW1wbGVyIH0gZnJvbSAnLi9jb3JlL2NvbW1vbi9EZWZhdWx0R3JpZFNhbXBsZXInO1xcclxcbi8vZXhwb3J0IHsgZGVmYXVsdCBhcyBEZXRlY3RvclJlc3VsdCB9IGZyb20gJy4vY29yZS9jb21tb24vRGV0ZWN0b3JSZXN1bHQnO1xcclxcbi8vZXhwb3J0IHsgZGVmYXVsdCBhcyBFbmNvZGVIaW50VHlwZSB9IGZyb20gJy4vY29yZS9FbmNvZGVIaW50VHlwZSc7XFxyXFxuLy9leHBvcnQgeyBkZWZhdWx0IGFzIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplciB9IGZyb20gJy4vY29yZS9jb21tb24vR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyJztcXHJcXG4vL2V4cG9ydCB7IGRlZmF1bHQgYXMgR3JpZFNhbXBsZXIgfSBmcm9tICcuL2NvcmUvY29tbW9uL0dyaWRTYW1wbGVyJztcXHJcXG4vL2V4cG9ydCB7IGRlZmF1bHQgYXMgR3JpZFNhbXBsZXJJbnN0YW5jZSB9IGZyb20gJy4vY29yZS9jb21tb24vR3JpZFNhbXBsZXJJbnN0YW5jZSc7XFxyXFxuLy9leHBvcnQgeyBkZWZhdWx0IGFzIEh5YnJpZEJpbmFyaXplciB9IGZyb20gJy4vY29yZS9jb21tb24vSHlicmlkQmluYXJpemVyJztcXHJcXG4vL2V4cG9ydCB7IGRlZmF1bHQgYXMgUGVyc3BlY3RpdmVUcmFuc2Zvcm0gfSBmcm9tICcuL2NvcmUvY29tbW9uL1BlcnNwZWN0aXZlVHJhbnNmb3JtJztcXHJcXG4vL2V4cG9ydCB7IGRlZmF1bHQgYXMgU3RyaW5nVXRpbHMgfSBmcm9tICcuL2NvcmUvY29tbW9uL1N0cmluZ1V0aWxzJztcXHJcXG4vLy8vIGNvcmUvY29tbW9uL2RldGVjdG9yXFxyXFxuLy9leHBvcnQgeyBkZWZhdWx0IGFzIE1hdGhVdGlscyB9IGZyb20gJy4vY29yZS9jb21tb24vZGV0ZWN0b3IvTWF0aFV0aWxzJztcXHJcXG4vLy8vIGV4cG9ydCB7IGRlZmF1bHQgYXMgTW9ub2Nocm9tZVJlY3RhbmdsZURldGVjdG9yIH0gZnJvbSAnLi9jb3JlL2NvbW1vbi9kZXRlY3Rvci9Nb25vY2hyb21lUmVjdGFuZ2xlRGV0ZWN0b3InO1xcclxcbi8vZXhwb3J0IHsgZGVmYXVsdCBhcyBXaGl0ZVJlY3RhbmdsZURldGVjdG9yIH0gZnJvbSAnLi9jb3JlL2NvbW1vbi9kZXRlY3Rvci9XaGl0ZVJlY3RhbmdsZURldGVjdG9yJztcXHJcXG4vLy8vIGNvcmUvY29tbW9uL3JlZWRzb2xvbW9uXFxyXFxuLy9leHBvcnQgeyBkZWZhdWx0IGFzIEdlbmVyaWNHRiB9IGZyb20gJy4vY29yZS9jb21tb24vcmVlZHNvbG9tb24vR2VuZXJpY0dGJztcXHJcXG4vL2V4cG9ydCB7IGRlZmF1bHQgYXMgR2VuZXJpY0dGUG9seSB9IGZyb20gJy4vY29yZS9jb21tb24vcmVlZHNvbG9tb24vR2VuZXJpY0dGUG9seSc7XFxyXFxuLy9leHBvcnQgeyBkZWZhdWx0IGFzIFJlZWRTb2xvbW9uRGVjb2RlciB9IGZyb20gJy4vY29yZS9jb21tb24vcmVlZHNvbG9tb24vUmVlZFNvbG9tb25EZWNvZGVyJztcXHJcXG4vL2V4cG9ydCB7IGRlZmF1bHQgYXMgUmVlZFNvbG9tb25FbmNvZGVyIH0gZnJvbSAnLi9jb3JlL2NvbW1vbi9yZWVkc29sb21vbi9SZWVkU29sb21vbkVuY29kZXInO1xcclxcbi8vLy8gY29yZS9kYXRhbWF0cml4XFxyXFxuLy9leHBvcnQgeyBkZWZhdWx0IGFzIERhdGFNYXRyaXhSZWFkZXIgfSBmcm9tICcuL2NvcmUvZGF0YW1hdHJpeC9EYXRhTWF0cml4UmVhZGVyJztcXHJcXG4vLy8vIGNvcmUvdHdvZC9xcmNvZGVcXHJcXG4vL2V4cG9ydCB7IGRlZmF1bHQgYXMgUVJDb2RlUmVhZGVyIH0gZnJvbSAnLi9jb3JlL3FyY29kZS9RUkNvZGVSZWFkZXInO1xcclxcbi8vZXhwb3J0IHsgZGVmYXVsdCBhcyBRUkNvZGVXcml0ZXIgfSBmcm9tICcuL2NvcmUvcXJjb2RlL1FSQ29kZVdyaXRlcic7XFxyXFxuLy9leHBvcnQgeyBkZWZhdWx0IGFzIFFSQ29kZURlY29kZXJFcnJvckNvcnJlY3Rpb25MZXZlbCB9IGZyb20gJy4vY29yZS9xcmNvZGUvZGVjb2Rlci9FcnJvckNvcnJlY3Rpb25MZXZlbCc7XFxyXFxuLy9leHBvcnQgeyBkZWZhdWx0IGFzIFFSQ29kZUVuY29kZXIgfSBmcm9tICcuL2NvcmUvcXJjb2RlL2VuY29kZXIvRW5jb2Rlcic7XFxyXFxuLy9leHBvcnQgeyBkZWZhdWx0IGFzIFFSQ29kZUVuY29kZXJRUkNvZGUgfSBmcm9tICcuL2NvcmUvcXJjb2RlL2VuY29kZXIvUVJDb2RlJztcXHJcXG4vLy8vIGNvcmUvdHdvZC9henRlY1xcclxcbi8vZXhwb3J0IHsgZGVmYXVsdCBhcyBBenRlY0NvZGVSZWFkZXIgfSBmcm9tICcuL2NvcmUvYXp0ZWMvQXp0ZWNSZWFkZXInO1xcclxcbi8vLy8gY29yZS9vbmVkXFxyXFxuLy9leHBvcnQgeyBkZWZhdWx0IGFzIE9uZURSZWFkZXIgfSBmcm9tICcuL2NvcmUvb25lZC9PbmVEUmVhZGVyJztcXHJcXG4vL2V4cG9ydCB7IGRlZmF1bHQgYXMgRUFOMTNSZWFkZXIgfSBmcm9tICcuL2NvcmUvb25lZC9FQU4xM1JlYWRlcic7XFxyXFxuLy9leHBvcnQgeyBkZWZhdWx0IGFzIENvZGUxMjhSZWFkZXIgfSBmcm9tICcuL2NvcmUvb25lZC9Db2RlMTI4UmVhZGVyJztcXHJcXG4vL2V4cG9ydCB7IGRlZmF1bHQgYXMgSVRGUmVhZGVyIH0gZnJvbSAnLi9jb3JlL29uZWQvSVRGUmVhZGVyJztcXHJcXG4vL2V4cG9ydCB7IGRlZmF1bHQgYXMgQ29kZTM5UmVhZGVyIH0gZnJvbSAnLi9jb3JlL29uZWQvQ29kZTM5UmVhZGVyJztcXHJcXG4vL2V4cG9ydCB7IGRlZmF1bHQgYXMgUlNTMTRSZWFkZXIgfSBmcm9tICcuL2NvcmUvb25lZC9yc3MvUlNTMTRSZWFkZXInO1xcclxcbi8vZXhwb3J0IHsgZGVmYXVsdCBhcyBSU1NFeHBhbmRlZFJlYWRlciB9IGZyb20gJy4vY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9SU1NFeHBhbmRlZFJlYWRlcic7XFxyXFxuLy9leHBvcnQgeyBkZWZhdWx0IGFzIE11bHRpZm9ybWF0UmVhZGVyIH0gZnJvbSAnLi9jb3JlL29uZWQvTXVsdGlGb3JtYXRPbmVEUmVhZGVyJztcXHJcXG4vLyBPWl9TZWFsX1JlY29nbml0aW9uXFxyXFxudmFyIE9aU2VhbEZpbmRlclBhdHRlcm5GaW5kZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29yZS9xcmNvZGUvZGV0ZWN0b3IvT1pTZWFsRmluZGVyUGF0dGVybkZpbmRlciAqLyBcXFwiLi9zcmMvY29yZS9xcmNvZGUvZGV0ZWN0b3IvT1pTZWFsRmluZGVyUGF0dGVybkZpbmRlci50c1xcXCIpO1xcclxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiT1pTZWFsRmluZGVyUGF0dGVybkZpbmRlclxcXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBPWlNlYWxGaW5kZXJQYXR0ZXJuRmluZGVyXzEuZGVmYXVsdDsgfSB9KTtcXHJcXG52YXIgU3RyaW5nVXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29yZS9jb21tb24vU3RyaW5nVXRpbHMgKi8gXFxcIi4vc3JjL2NvcmUvY29tbW9uL1N0cmluZ1V0aWxzLnRzXFxcIik7XFxyXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJTdHJpbmdVdGlsc1xcXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBTdHJpbmdVdGlsc18xLmRlZmF1bHQ7IH0gfSk7XFxyXFxuLy8gT1pfU2VhbF9SZWNvZ25pdGlvbl9aWGluZyDsoJzsmbjtlZwg67KE7KCEXFxyXFxuLy9leHBvcnQgeyBkZWZhdWx0IGFzIE9aU2VhbEZpbmRlclBhdHRlcm4gfSBmcm9tICcuL2NvcmUvcXJjb2RlL2RldGVjdG9yL09aU2VhbEZpbmRlclBhdHRlcm4nO1xcclxcbi8vZXhwb3J0IHsgZGVmYXVsdCBhcyBCaW5hcnlCaXRtYXAgfSBmcm9tICcuL2NvcmUvQmluYXJ5Qml0bWFwJztcXHJcXG4vL2V4cG9ydCB7IGRlZmF1bHQgYXMgRGVjb2RlSGludFR5cGUgfSBmcm9tICcuL2NvcmUvRGVjb2RlSGludFR5cGUnO1xcclxcbi8vZXhwb3J0IHsgZGVmYXVsdCBhcyBSZXN1bHQgfSBmcm9tICcuL2NvcmUvUmVzdWx0JztcXHJcXG4vL2V4cG9ydCB7IGRlZmF1bHQgYXMgQmFyY29kZUZvcm1hdCB9IGZyb20gJy4vY29yZS9CYXJjb2RlRm9ybWF0JztcXHJcXG4vL2V4cG9ydCB7IGRlZmF1bHQgYXMgQ29kZTEyOFJlYWRlciB9IGZyb20gJy4vY29yZS9vbmVkL0NvZGUxMjhSZWFkZXInO1xcclxcbi8vZXhwb3J0IHsgZGVmYXVsdCBhcyBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZSB9IGZyb20gJy4vY29yZS9JbnZlcnRlZEx1bWluYW5jZVNvdXJjZSc7XFxyXFxuLy9leHBvcnQgeyBkZWZhdWx0IGFzIEx1bWluYW5jZVNvdXJjZSB9IGZyb20gJy4vY29yZS9MdW1pbmFuY2VTb3VyY2UnO1xcclxcbi8vZXhwb3J0IHsgZGVmYXVsdCBhcyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24gfSBmcm9tICcuL2NvcmUvSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uJztcXHJcXG4vL2V4cG9ydCB7IGRlZmF1bHQgYXMgQml0TWF0cml4IH0gZnJvbSAnLi9jb3JlL2NvbW1vbi9CaXRNYXRyaXgnO1xcclxcbi8vZXhwb3J0IHsgZGVmYXVsdCBhcyBOb3RGb3VuZEV4Y2VwdGlvbiB9IGZyb20gJy4vY29yZS9Ob3RGb3VuZEV4Y2VwdGlvbic7XFxyXFxuLy9leHBvcnQgeyBkZWZhdWx0IGFzIEJpbmFyaXplciB9IGZyb20gJy4vY29yZS9CaW5hcml6ZXInO1xcclxcbi8vZXhwb3J0IHsgZGVmYXVsdCBhcyBCaXRBcnJheSB9IGZyb20gJy4vY29yZS9jb21tb24vQml0QXJyYXknO1xcclxcbi8vZXhwb3J0IHsgZGVmYXVsdCBhcyBSZXN1bHRNZXRhZGF0YVR5cGUgfSBmcm9tICcuL2NvcmUvUmVzdWx0TWV0YWRhdGFUeXBlJztcXHJcXG4vL2V4cG9ydCB7IGRlZmF1bHQgYXMgUmVhZGVyIH0gZnJvbSAnLi9jb3JlL1JlYWRlcic7XFxyXFxuLy9leHBvcnQgeyBkZWZhdWx0IGFzIE9uZURSZWFkZXIgfSBmcm9tICcuL2NvcmUvb25lZC9PbmVEUmVhZGVyJztcXHJcXG4vL2V4cG9ydCB7IGRlZmF1bHQgYXMgRm9ybWF0RXhjZXB0aW9uIH0gZnJvbSAnLi9jb3JlL0Zvcm1hdEV4Y2VwdGlvbic7XFxyXFxuLy9leHBvcnQgeyBkZWZhdWx0IGFzIENoZWNrc3VtRXhjZXB0aW9uIH0gZnJvbSAnLi9jb3JlL0NoZWNrc3VtRXhjZXB0aW9uJztcXHJcXG4vL2V4cG9ydCB7IGRlZmF1bHQgYXMgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24gfSBmcm9tICcuL2NvcmUvVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24nO1xcclxcbi8vZXhwb3J0IHsgZGVmYXVsdCBhcyBFeGNlcHRpb24gfSBmcm9tICcuL2NvcmUvRXhjZXB0aW9uJztcXHJcXG4vL2V4cG9ydCB7IGRlZmF1bHQgYXMgQ2hhcmFjdGVyU2V0RUNJIH0gZnJvbSAnLi9jb3JlL2NvbW1vbi9DaGFyYWN0ZXJTZXRFQ0knO1xcclxcbi8vZXhwb3J0IHsgZGVmYXVsdCBhcyBIeWJyaWRCaW5hcml6ZXIgfSBmcm9tICcuL2NvcmUvY29tbW9uL0h5YnJpZEJpbmFyaXplcic7XFxyXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vT1pTZWFsUmVjb2duaXRpb24vLi9zcmMvaW5kZXgudHM/XCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKiovIH0pLFxyXG5cclxuICAgICAgICAgICAgLyoqKi8gMDpcclxuICAgICAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcclxuICAgICAgICAgICAgICAhKioqIG11bHRpIC4vc3JjL2luZGV4LnRzICoqKiFcclxuICAgICAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgICAgICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xyXG4gICAgICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXHJcbiAgICAgICAgICAgIC8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbiAgICAgICAgICAgICAgICBldmFsKFwibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9pbmRleC50cyAqL1xcXCIuL3NyYy9pbmRleC50c1xcXCIpO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL09aU2VhbFJlY29nbml0aW9uL211bHRpXy4vc3JjL2luZGV4LnRzP1wiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKioqLyB9KVxyXG5cclxuICAgICAgICAgICAgLyoqKioqKi8gfSk7XHJcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/OZSealRecognition.js\n");

/***/ }),

/***/ "./src/OZSealRecognizer.js":
/*!*********************************!*\
  !*** ./src/OZSealRecognizer.js ***!
  \*********************************/
/***/ (() => {

eval("const OZSealRecognizer = window[\"OZSealRecognizer\"] = function() {    \r\n    const _this = OZSealRecognizer.prototype;\r\n    this.m_codeReader = new window[\"ZXing\"][\"BrowserMultiFormatReader\"](new Map().set(window[\"ZXing\"][\"DecodeHintType\"][\"POSSIBLE_FORMATS\"], [window[\"ZXing\"][\"BarcodeFormat\"][\"CODE_128\"]]), 0);\r\n\r\n    _this.ready = function(nDPI, pHiddenCanvas, pHiddenMeta, targetMat) {\r\n        this.m_nDPI = nDPI;\r\n        this.m_pHiddenCanvas = pHiddenCanvas;\r\n        this.m_pHiddenMeta = pHiddenMeta;\r\n        this.m_binaryBitmap = null;\r\n        this.m_rectangle = [];\r\n        this.m_specBarcode = {};\r\n        this.m_isFoundPattern = false;\r\n        this.m_isFoundRectangle = false;\r\n        this.m_isFoundSpecBarcode = false;\r\n        this.m_targetMat = targetMat;\r\n        this.m_resultMat = null;\r\n\r\n        return true;\r\n    };\r\n\r\n    _this.dispose = function() {\r\n        if (this.m_resultMat) {\r\n            this.m_resultMat[\"delete\"]();\r\n            this.m_resultMat = null;\r\n        }\r\n        this.m_targetMat = null;\r\n        this.m_nDPI = null;\r\n        this.m_pHiddenCanvas = null;\r\n        this.m_pHiddenMeta = null;\r\n        this.m_binaryBitmap = null;\r\n        this.m_rectangle = null;\r\n        this.m_specBarcode = null;\r\n        this.m_isFoundPattern = null;\r\n        this.m_isFoundRectangle = null;\r\n        this.m_isFoundSpecBarcode = null;\r\n        this.m_codeReader = null;\r\n        \r\n    };\r\n\r\n    _this.binarization = function() {\r\n        try {\r\n            const luminanceSource = new window[\"ZXing\"][\"HTMLCanvasElementLuminanceSource\"](this.m_pHiddenCanvas);\r\n            const hybridBinarizer = new window[\"ZXing\"][\"HybridBinarizer\"](luminanceSource);\r\n            this.m_binaryBitmap = new window[\"ZXing\"][\"BinaryBitmap\"](hybridBinarizer);\r\n        } catch (e) {\r\n            window[\"OZRecognitionPack\"].trace(e);\r\n        }\r\n    };\r\n\r\n    _this.findPatternArea = function() {\r\n    \tvar _pts = [];\r\n        var patternCount = 0;\r\n\r\n        this.binarization();\r\n        \r\n        // 1. 인식 패턴 탐색\r\n        if (!this.findPattern(_pts)) return false;\r\n        patternCount = _pts.length;\r\n        if (patternCount < 12) return false;\r\n\r\n        // 2. 패턴에 대응하는 rect 탐색\r\n        if(!this.findRectangle(_pts)) return false;\r\n        for(let i=0; i<4; i++) {\r\n            cv[\"line\"](this.m_targetMat, this.m_rectangle[i], this.m_rectangle[(i + 1) % 4], new cv[\"Scalar\"](0, 255, 64, 255), 2, cv[\"LINE_AA\"], 0);\r\n        }\r\n        \r\n        // 3. 메타 바코드 검증\r\n        if(!this.checkSpecBarcode()) return false;\r\n        for(let i=0; i<4; i++) {\r\n            cv[\"line\"](this.m_targetMat, this.m_rectangle[i], this.m_rectangle[(i + 1) % 4], new cv[\"Scalar\"](255, 100, 0, 255), 2, cv[\"LINE_AA\"], 0);\r\n        }\r\n\r\n        return true;\r\n    };\r\n\r\n    _this.findPattern = function(patterns) {\r\n        try {\r\n            const finder = new window[\"OZSealRecognition\"][\"OZSealFinderPatternFinder\"](this.m_binaryBitmap[\"getBlackMatrix\"]());\r\n            this.m_isFoundPattern = finder[\"find\"](patterns);\r\n            for(var i=0; i<patterns.length; i++) {\r\n                cv[\"circle\"](this.m_targetMat, new cv[\"Point\"](patterns[i].x, patterns[i].y), patterns[i][\"estimatedModuleSize\"], new cv[\"Scalar\"](255, 196, 50, 255), patterns[i][\"estimatedModuleSize\"]);\r\n            }\r\n        } catch (e) {\r\n            window[\"OZRecognitionPack\"].trace(e);\r\n        }\r\n        return this.m_isFoundPattern;\r\n    };\r\n\r\n    _this.findRectangle = function(pts) {\r\n        if (pts.length < 3) return false;\r\n\r\n        let pts2 = [];\r\n        let pattern;\r\n        if (pts2.length != 4) {\r\n            pts2 = [];\r\n            for(let i=0; i<pts.length; i++) {\r\n                pattern = pts[i];\r\n                if (this.findNearPoints(pts, i, pattern[\"estimatedModuleSize\"] * 5, pattern[\"estimatedModuleSize\"] * 8.5) >= 2) {\r\n                    pts2.push(new cv[\"Point\"](pattern.x, pattern.y));\r\n                }\r\n            }\r\n        }\r\n        if (pts2.length != 4) {\r\n            pts2 = [];\r\n            for(let i=0; i<pts.length; i++) {\r\n                pattern = pts[i];\r\n                if (this.findNearPoints(pts, i, pattern[\"estimatedModuleSize\"] * 5, pattern[\"estimatedModuleSize\"] * 7) >= 2) {\r\n                    pts2.push(new cv[\"Point\"](pattern.x, pattern.y));\r\n                }\r\n            }\r\n        }\r\n        \r\n        if (pts2.length != 4) return false;\r\n\r\n        let hull = null;\r\n        let pts3 = null;\r\n        try {\r\n            hull = new cv[\"Mat\"]();\r\n            pts3 = cv[\"matFromArray\"](4, 1, cv[\"CV_32FC2\"], [\r\n                pts2[0].x, pts2[0].y, \r\n                pts2[1].x, pts2[1].y,\r\n                pts2[2].x, pts2[2].y,\r\n                pts2[3].x, pts2[3].y\r\n            ]);\r\n    \r\n            cv[\"convexHull\"](pts3, hull);\r\n            cv[\"approxPolyDP\"](hull, hull, cv[\"arcLength\"](hull, true) * 0.007 * 2, true);\r\n    \r\n            let hullSize = hull[\"data32F\"].length;\r\n            if (hullSize >= 4) {\r\n                let minDist = 99999;\r\n                let minIndex = 0;\r\n                for (let i=0; i<hullSize; i += 2) {\r\n                    let dist = this.getDistance(0, 0, hull[\"data32F\"][i], hull[\"data32F\"][i+1]);\r\n                    if (minDist > dist) {\r\n                        minDist = dist;\r\n                        minIndex = i;\r\n                    }\r\n                }\r\n    \r\n                this.m_rectangle = [];\r\n                this.m_rectangle.push(new cv[\"Point\"](hull[\"data32F\"][(minIndex + 0) % 8], hull[\"data32F\"][(minIndex + 1) % 8]));\r\n                this.m_rectangle.push(new cv[\"Point\"](hull[\"data32F\"][(minIndex + 2) % 8], hull[\"data32F\"][(minIndex + 3) % 8]));\r\n                this.m_rectangle.push(new cv[\"Point\"](hull[\"data32F\"][(minIndex + 4) % 8], hull[\"data32F\"][(minIndex + 5) % 8]));\r\n                this.m_rectangle.push(new cv[\"Point\"](hull[\"data32F\"][(minIndex + 6) % 8], hull[\"data32F\"][(minIndex + 7) % 8]));\r\n    \r\n                this.m_isFoundRectangle = true;\r\n                return true;\r\n            }\r\n        } finally {\r\n            hull[\"delete\"]();\r\n            hull = null;\r\n\r\n            pts3[\"delete\"]();\r\n            pts3 = null;\r\n        }\r\n        return false;\r\n    };\r\n\r\n    _this.getDistance = function(x1, y1, x2, y2) {\r\n        const dx = x2 - x1;\r\n        const dy = y2 - y1;\r\n        return Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n\r\n    _this.findNearPoints = function(pts, index, minDistance, maxDistance) {\r\n        const pivot = pts[index];\r\n        let resultCount = 0;\r\n\r\n        for(let i=0; i<pts.length; i++) {\r\n            if (i == index) continue;\r\n            const pattern = pts[i];\r\n            const distance = this.getDistance(pivot.x, pivot.y, pattern.x, pattern.y);\r\n            if (distance >= minDistance && distance <= maxDistance) {\r\n                resultCount++;\r\n            }\r\n        }\r\n        return resultCount;\r\n    };\r\n\r\n    _this.checkSpecBarcode = function() {\r\n        let result = null;\r\n        let barcode = null;\r\n        try {\r\n            for(let i=0;i<4;i++) {\r\n                barcode = this.copyRectangle(this.m_targetMat, 300, 3.6, 3.6, 2.2, 0.4, 0.0, 3.6); // bottom barcode\r\n                cv[\"threshold\"](barcode, barcode, 112, 255, cv[\"THRESH_BINARY\"]);\r\n                this.m_pHiddenMeta.width = barcode.cols;\r\n                this.m_pHiddenMeta.height = barcode.rows;\r\n                cv[\"imshow\"](this.m_pHiddenMeta, barcode);\r\n                barcode[\"delete\"]();\r\n                barcode = null;\r\n    \r\n                const luminanceSource = new window[\"ZXing\"][\"HTMLCanvasElementLuminanceSource\"](this.m_pHiddenMeta);\r\n                const hybridBinarizer = new window[\"ZXing\"][\"HybridBinarizer\"](luminanceSource);\r\n                const binaryBitmap = new window[\"ZXing\"][\"BinaryBitmap\"](hybridBinarizer);\r\n                \r\n                try {\r\n                    result = this.m_codeReader[\"decodeBitmap\"](binaryBitmap);\r\n                    if (result) {\r\n                        if (this.decodePaperSpec(result.text)) {\r\n                            this.m_isFoundSpecBarcode = true;\r\n                            return true;\r\n                        }\r\n                    }\r\n                } catch (e) {\r\n                    // window[\"OZRecognitionPack\"].trace(e);\r\n                }\r\n                this.rotateLeft();\r\n            }\r\n        } finally {\r\n            if (result) result = null;\r\n            if (barcode) {\r\n                barcode[\"delete\"]();\r\n                barcode = null;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    };\r\n    _this.rotateLeft = function() {\r\n        let tmp = [];\r\n        for(let i=0;i<this.m_rectangle.length;i++) {\r\n            tmp.push(this.m_rectangle[i]);\r\n        }\r\n        for(let i=1;i<this.m_rectangle.length;i++) {\r\n            this.m_rectangle[i] = tmp[i - 1];\r\n        }\r\n        this.m_rectangle[0] = tmp[this.m_rectangle.length - 1];\r\n    };\r\n\r\n    _this.decodePaperSpec = function(strMeta) {\r\n        const len = strMeta.charAt(0);\r\n        const multiply = strMeta.charAt(1);\r\n        const barcodeLength = strMeta.length;\r\n\r\n        if (barcodeLength <= 2) return false;\r\n        if (barcodeLength != 2 + len * 2) return false;\r\n\r\n        const paperWidth = strMeta.substr(2, len) * multiply / 10.0;\r\n        const areaWidth = strMeta.substr(2 + parseInt(len), len) * multiply / 10.0;\r\n\r\n        this.m_specBarcode[\"paperWidth\"] = paperWidth;\r\n        this.m_specBarcode[\"areaWidth\"] = areaWidth;\r\n        return true;\r\n    };\r\n\r\n    _this.cm2px = function(dpi, cm) {\r\n        return cm / 2.54 * dpi;\r\n    };\r\n\r\n    _this.copyRectangle = function(image, dpi, totalSizeW, totalSizeH, captureSizeW, captureSizeH, offsetX = 0, offsetY = 0) {\r\n        const width = this.cm2px(dpi, captureSizeW);\r\n        const height = this.cm2px(dpi, captureSizeH);\r\n\r\n        let result = new cv[\"Mat\"][\"zeros\"](width, height, cv[\"CV_8UC3\"]);\r\n        const marginL = this.cm2px(dpi, (totalSizeW - captureSizeW + offsetX) / 2.0);\r\n        const marginT = this.cm2px(dpi, (totalSizeH - captureSizeH + offsetY) / 2.0);\r\n        const marginR = this.cm2px(dpi, (totalSizeW - captureSizeW - offsetX) / 2.0);\r\n        const marginB = this.cm2px(dpi, (totalSizeH - captureSizeH - offsetY) / 2.0);\r\n\r\n        let srcQuad = null;\r\n        let dstQuad = null;\r\n        try {\r\n            srcQuad = cv[\"matFromArray\"](4, 1, cv[\"CV_32FC2\"], [ // crop할 영역\r\n                this.m_rectangle[0].x, this.m_rectangle[0].y, \r\n                this.m_rectangle[1].x, this.m_rectangle[1].y,\r\n                this.m_rectangle[3].x, this.m_rectangle[3].y,\r\n                this.m_rectangle[2].x, this.m_rectangle[2].y\r\n            ]);\r\n    \r\n            dstQuad = cv[\"matFromArray\"](4, 1, cv[\"CV_32FC2\"], [ // dsize crop 결과물 크기\r\n                0  - marginL, 0 - marginT, \r\n                width  + marginR, 0 - marginT,\r\n                0 - marginL, height + marginB,\r\n                width + marginR, height + marginB\r\n            ]);\r\n    \r\n            const warpMatix = cv[\"getPerspectiveTransform\"](srcQuad, dstQuad);\r\n            cv[\"warpPerspective\"](image, result, warpMatix, new cv[\"Size\"](width, height));\r\n        } finally {\r\n            srcQuad[\"delete\"]();\r\n            srcQuad = null;\r\n            dstQuad[\"delete\"]();\r\n            dstQuad = null;\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    _this.capture = function() {\r\n        if (this.m_isFoundPattern && this.m_isFoundRectangle && this.m_isFoundSpecBarcode) {\r\n            const resultSize = this.m_specBarcode[\"areaWidth\"];\r\n            const areaSize = this.m_specBarcode[\"paperWidth\"];\r\n            this.m_resultMat = this.copyRectangle(this.m_targetMat, this.m_nDPI, areaSize, areaSize, resultSize, resultSize);\r\n            return true;\r\n        }\r\n        return false;\r\n   };\r\n\r\n   _this.getResult = function() {\r\n       return this.m_resultMat;\r\n   };\r\n\r\n   _this.getSpecBarcode = function() {\r\n       return this.m_specBarcode;\r\n   };\r\n\r\n    _this.IsFoundPattern = function() {\r\n        return this.m_isFoundPattern;\r\n    };\r\n\r\n    _this.IsFoundRectangle = function() {\r\n        return this.m_isFoundRectangle;\r\n    };\r\n\r\n    _this.IsFoundSpecBarcode = function() {\r\n        return this.m_isFoundSpecBarcode;\r\n    };\r\n};\r\n\r\nOZSealRecognizer.NONE = 0;\r\nOZSealRecognizer.BLACK_AND_WHITE = 1;\r\nOZSealRecognizer.BLACK_AND_BLANK = 2;\r\nOZSealRecognizer.GRAYSCALE = 3;\r\nOZSealRecognizer.RED_AND_WHITE = 4;\r\nOZSealRecognizer.RED_AND_BLANK = 5;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvT1pTZWFsUmVjb2duaXplci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsS0FBSztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEtBQUs7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGNBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixjQUFjO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixZQUFZO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixJQUFJO0FBQzVCLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9PWlNlYWxSZWNvZ25pdGlvbi8uL3NyYy9PWlNlYWxSZWNvZ25pemVyLmpzPzljMmUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgT1pTZWFsUmVjb2duaXplciA9IHdpbmRvd1tcIk9aU2VhbFJlY29nbml6ZXJcIl0gPSBmdW5jdGlvbigpIHsgICAgXHJcbiAgICBjb25zdCBfdGhpcyA9IE9aU2VhbFJlY29nbml6ZXIucHJvdG90eXBlO1xyXG4gICAgdGhpcy5tX2NvZGVSZWFkZXIgPSBuZXcgd2luZG93W1wiWlhpbmdcIl1bXCJCcm93c2VyTXVsdGlGb3JtYXRSZWFkZXJcIl0obmV3IE1hcCgpLnNldCh3aW5kb3dbXCJaWGluZ1wiXVtcIkRlY29kZUhpbnRUeXBlXCJdW1wiUE9TU0lCTEVfRk9STUFUU1wiXSwgW3dpbmRvd1tcIlpYaW5nXCJdW1wiQmFyY29kZUZvcm1hdFwiXVtcIkNPREVfMTI4XCJdXSksIDApO1xyXG5cclxuICAgIF90aGlzLnJlYWR5ID0gZnVuY3Rpb24obkRQSSwgcEhpZGRlbkNhbnZhcywgcEhpZGRlbk1ldGEsIHRhcmdldE1hdCkge1xyXG4gICAgICAgIHRoaXMubV9uRFBJID0gbkRQSTtcclxuICAgICAgICB0aGlzLm1fcEhpZGRlbkNhbnZhcyA9IHBIaWRkZW5DYW52YXM7XHJcbiAgICAgICAgdGhpcy5tX3BIaWRkZW5NZXRhID0gcEhpZGRlbk1ldGE7XHJcbiAgICAgICAgdGhpcy5tX2JpbmFyeUJpdG1hcCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tX3JlY3RhbmdsZSA9IFtdO1xyXG4gICAgICAgIHRoaXMubV9zcGVjQmFyY29kZSA9IHt9O1xyXG4gICAgICAgIHRoaXMubV9pc0ZvdW5kUGF0dGVybiA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubV9pc0ZvdW5kUmVjdGFuZ2xlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5tX2lzRm91bmRTcGVjQmFyY29kZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubV90YXJnZXRNYXQgPSB0YXJnZXRNYXQ7XHJcbiAgICAgICAgdGhpcy5tX3Jlc3VsdE1hdCA9IG51bGw7XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBfdGhpcy5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubV9yZXN1bHRNYXQpIHtcclxuICAgICAgICAgICAgdGhpcy5tX3Jlc3VsdE1hdFtcImRlbGV0ZVwiXSgpO1xyXG4gICAgICAgICAgICB0aGlzLm1fcmVzdWx0TWF0ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tX3RhcmdldE1hdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tX25EUEkgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubV9wSGlkZGVuQ2FudmFzID0gbnVsbDtcclxuICAgICAgICB0aGlzLm1fcEhpZGRlbk1ldGEgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubV9iaW5hcnlCaXRtYXAgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubV9yZWN0YW5nbGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubV9zcGVjQmFyY29kZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tX2lzRm91bmRQYXR0ZXJuID0gbnVsbDtcclxuICAgICAgICB0aGlzLm1faXNGb3VuZFJlY3RhbmdsZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tX2lzRm91bmRTcGVjQmFyY29kZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tX2NvZGVSZWFkZXIgPSBudWxsO1xyXG4gICAgICAgIFxyXG4gICAgfTtcclxuXHJcbiAgICBfdGhpcy5iaW5hcml6YXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBsdW1pbmFuY2VTb3VyY2UgPSBuZXcgd2luZG93W1wiWlhpbmdcIl1bXCJIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZVwiXSh0aGlzLm1fcEhpZGRlbkNhbnZhcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGh5YnJpZEJpbmFyaXplciA9IG5ldyB3aW5kb3dbXCJaWGluZ1wiXVtcIkh5YnJpZEJpbmFyaXplclwiXShsdW1pbmFuY2VTb3VyY2UpO1xyXG4gICAgICAgICAgICB0aGlzLm1fYmluYXJ5Qml0bWFwID0gbmV3IHdpbmRvd1tcIlpYaW5nXCJdW1wiQmluYXJ5Qml0bWFwXCJdKGh5YnJpZEJpbmFyaXplcik7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB3aW5kb3dbXCJPWlJlY29nbml0aW9uUGFja1wiXS50cmFjZShlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIF90aGlzLmZpbmRQYXR0ZXJuQXJlYSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgXHR2YXIgX3B0cyA9IFtdO1xyXG4gICAgICAgIHZhciBwYXR0ZXJuQ291bnQgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLmJpbmFyaXphdGlvbigpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIDEuIOyduOyLnSDtjKjthLQg7YOQ7IOJXHJcbiAgICAgICAgaWYgKCF0aGlzLmZpbmRQYXR0ZXJuKF9wdHMpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcGF0dGVybkNvdW50ID0gX3B0cy5sZW5ndGg7XHJcbiAgICAgICAgaWYgKHBhdHRlcm5Db3VudCA8IDEyKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIDIuIO2MqO2EtOyXkCDrjIDsnZHtlZjripQgcmVjdCDtg5Dsg4lcclxuICAgICAgICBpZighdGhpcy5maW5kUmVjdGFuZ2xlKF9wdHMpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgZm9yKGxldCBpPTA7IGk8NDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGN2W1wibGluZVwiXSh0aGlzLm1fdGFyZ2V0TWF0LCB0aGlzLm1fcmVjdGFuZ2xlW2ldLCB0aGlzLm1fcmVjdGFuZ2xlWyhpICsgMSkgJSA0XSwgbmV3IGN2W1wiU2NhbGFyXCJdKDAsIDI1NSwgNjQsIDI1NSksIDIsIGN2W1wiTElORV9BQVwiXSwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIDMuIOuplO2DgCDrsJTsvZTrk5wg6rKA7KadXHJcbiAgICAgICAgaWYoIXRoaXMuY2hlY2tTcGVjQmFyY29kZSgpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgZm9yKGxldCBpPTA7IGk8NDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGN2W1wibGluZVwiXSh0aGlzLm1fdGFyZ2V0TWF0LCB0aGlzLm1fcmVjdGFuZ2xlW2ldLCB0aGlzLm1fcmVjdGFuZ2xlWyhpICsgMSkgJSA0XSwgbmV3IGN2W1wiU2NhbGFyXCJdKDI1NSwgMTAwLCAwLCAyNTUpLCAyLCBjdltcIkxJTkVfQUFcIl0sIDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG5cclxuICAgIF90aGlzLmZpbmRQYXR0ZXJuID0gZnVuY3Rpb24ocGF0dGVybnMpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBmaW5kZXIgPSBuZXcgd2luZG93W1wiT1pTZWFsUmVjb2duaXRpb25cIl1bXCJPWlNlYWxGaW5kZXJQYXR0ZXJuRmluZGVyXCJdKHRoaXMubV9iaW5hcnlCaXRtYXBbXCJnZXRCbGFja01hdHJpeFwiXSgpKTtcclxuICAgICAgICAgICAgdGhpcy5tX2lzRm91bmRQYXR0ZXJuID0gZmluZGVyW1wiZmluZFwiXShwYXR0ZXJucyk7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPHBhdHRlcm5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjdltcImNpcmNsZVwiXSh0aGlzLm1fdGFyZ2V0TWF0LCBuZXcgY3ZbXCJQb2ludFwiXShwYXR0ZXJuc1tpXS54LCBwYXR0ZXJuc1tpXS55KSwgcGF0dGVybnNbaV1bXCJlc3RpbWF0ZWRNb2R1bGVTaXplXCJdLCBuZXcgY3ZbXCJTY2FsYXJcIl0oMjU1LCAxOTYsIDUwLCAyNTUpLCBwYXR0ZXJuc1tpXVtcImVzdGltYXRlZE1vZHVsZVNpemVcIl0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB3aW5kb3dbXCJPWlJlY29nbml0aW9uUGFja1wiXS50cmFjZShlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubV9pc0ZvdW5kUGF0dGVybjtcclxuICAgIH07XHJcblxyXG4gICAgX3RoaXMuZmluZFJlY3RhbmdsZSA9IGZ1bmN0aW9uKHB0cykge1xyXG4gICAgICAgIGlmIChwdHMubGVuZ3RoIDwgMykgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICBsZXQgcHRzMiA9IFtdO1xyXG4gICAgICAgIGxldCBwYXR0ZXJuO1xyXG4gICAgICAgIGlmIChwdHMyLmxlbmd0aCAhPSA0KSB7XHJcbiAgICAgICAgICAgIHB0czIgPSBbXTtcclxuICAgICAgICAgICAgZm9yKGxldCBpPTA7IGk8cHRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBwYXR0ZXJuID0gcHRzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmluZE5lYXJQb2ludHMocHRzLCBpLCBwYXR0ZXJuW1wiZXN0aW1hdGVkTW9kdWxlU2l6ZVwiXSAqIDUsIHBhdHRlcm5bXCJlc3RpbWF0ZWRNb2R1bGVTaXplXCJdICogOC41KSA+PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHRzMi5wdXNoKG5ldyBjdltcIlBvaW50XCJdKHBhdHRlcm4ueCwgcGF0dGVybi55KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHB0czIubGVuZ3RoICE9IDQpIHtcclxuICAgICAgICAgICAgcHRzMiA9IFtdO1xyXG4gICAgICAgICAgICBmb3IobGV0IGk9MDsgaTxwdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHBhdHRlcm4gPSBwdHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maW5kTmVhclBvaW50cyhwdHMsIGksIHBhdHRlcm5bXCJlc3RpbWF0ZWRNb2R1bGVTaXplXCJdICogNSwgcGF0dGVybltcImVzdGltYXRlZE1vZHVsZVNpemVcIl0gKiA3KSA+PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHRzMi5wdXNoKG5ldyBjdltcIlBvaW50XCJdKHBhdHRlcm4ueCwgcGF0dGVybi55KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHB0czIubGVuZ3RoICE9IDQpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgbGV0IGh1bGwgPSBudWxsO1xyXG4gICAgICAgIGxldCBwdHMzID0gbnVsbDtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBodWxsID0gbmV3IGN2W1wiTWF0XCJdKCk7XHJcbiAgICAgICAgICAgIHB0czMgPSBjdltcIm1hdEZyb21BcnJheVwiXSg0LCAxLCBjdltcIkNWXzMyRkMyXCJdLCBbXHJcbiAgICAgICAgICAgICAgICBwdHMyWzBdLngsIHB0czJbMF0ueSwgXHJcbiAgICAgICAgICAgICAgICBwdHMyWzFdLngsIHB0czJbMV0ueSxcclxuICAgICAgICAgICAgICAgIHB0czJbMl0ueCwgcHRzMlsyXS55LFxyXG4gICAgICAgICAgICAgICAgcHRzMlszXS54LCBwdHMyWzNdLnlcclxuICAgICAgICAgICAgXSk7XHJcbiAgICBcclxuICAgICAgICAgICAgY3ZbXCJjb252ZXhIdWxsXCJdKHB0czMsIGh1bGwpO1xyXG4gICAgICAgICAgICBjdltcImFwcHJveFBvbHlEUFwiXShodWxsLCBodWxsLCBjdltcImFyY0xlbmd0aFwiXShodWxsLCB0cnVlKSAqIDAuMDA3ICogMiwgdHJ1ZSk7XHJcbiAgICBcclxuICAgICAgICAgICAgbGV0IGh1bGxTaXplID0gaHVsbFtcImRhdGEzMkZcIl0ubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAoaHVsbFNpemUgPj0gNCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IG1pbkRpc3QgPSA5OTk5OTtcclxuICAgICAgICAgICAgICAgIGxldCBtaW5JbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8aHVsbFNpemU7IGkgKz0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBkaXN0ID0gdGhpcy5nZXREaXN0YW5jZSgwLCAwLCBodWxsW1wiZGF0YTMyRlwiXVtpXSwgaHVsbFtcImRhdGEzMkZcIl1baSsxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbkRpc3QgPiBkaXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkRpc3QgPSBkaXN0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5JbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgICAgICAgICB0aGlzLm1fcmVjdGFuZ2xlID0gW107XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1fcmVjdGFuZ2xlLnB1c2gobmV3IGN2W1wiUG9pbnRcIl0oaHVsbFtcImRhdGEzMkZcIl1bKG1pbkluZGV4ICsgMCkgJSA4XSwgaHVsbFtcImRhdGEzMkZcIl1bKG1pbkluZGV4ICsgMSkgJSA4XSkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tX3JlY3RhbmdsZS5wdXNoKG5ldyBjdltcIlBvaW50XCJdKGh1bGxbXCJkYXRhMzJGXCJdWyhtaW5JbmRleCArIDIpICUgOF0sIGh1bGxbXCJkYXRhMzJGXCJdWyhtaW5JbmRleCArIDMpICUgOF0pKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubV9yZWN0YW5nbGUucHVzaChuZXcgY3ZbXCJQb2ludFwiXShodWxsW1wiZGF0YTMyRlwiXVsobWluSW5kZXggKyA0KSAlIDhdLCBodWxsW1wiZGF0YTMyRlwiXVsobWluSW5kZXggKyA1KSAlIDhdKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1fcmVjdGFuZ2xlLnB1c2gobmV3IGN2W1wiUG9pbnRcIl0oaHVsbFtcImRhdGEzMkZcIl1bKG1pbkluZGV4ICsgNikgJSA4XSwgaHVsbFtcImRhdGEzMkZcIl1bKG1pbkluZGV4ICsgNykgJSA4XSkpO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICB0aGlzLm1faXNGb3VuZFJlY3RhbmdsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgIGh1bGxbXCJkZWxldGVcIl0oKTtcclxuICAgICAgICAgICAgaHVsbCA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICBwdHMzW1wiZGVsZXRlXCJdKCk7XHJcbiAgICAgICAgICAgIHB0czMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIF90aGlzLmdldERpc3RhbmNlID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcclxuICAgICAgICBjb25zdCBkeCA9IHgyIC0geDE7XHJcbiAgICAgICAgY29uc3QgZHkgPSB5MiAtIHkxO1xyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xyXG4gICAgfVxyXG5cclxuICAgIF90aGlzLmZpbmROZWFyUG9pbnRzID0gZnVuY3Rpb24ocHRzLCBpbmRleCwgbWluRGlzdGFuY2UsIG1heERpc3RhbmNlKSB7XHJcbiAgICAgICAgY29uc3QgcGl2b3QgPSBwdHNbaW5kZXhdO1xyXG4gICAgICAgIGxldCByZXN1bHRDb3VudCA9IDA7XHJcblxyXG4gICAgICAgIGZvcihsZXQgaT0wOyBpPHB0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaSA9PSBpbmRleCkgY29udGludWU7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBwdHNbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gdGhpcy5nZXREaXN0YW5jZShwaXZvdC54LCBwaXZvdC55LCBwYXR0ZXJuLngsIHBhdHRlcm4ueSk7XHJcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA+PSBtaW5EaXN0YW5jZSAmJiBkaXN0YW5jZSA8PSBtYXhEaXN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0Q291bnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0Q291bnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF90aGlzLmNoZWNrU3BlY0JhcmNvZGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcclxuICAgICAgICBsZXQgYmFyY29kZSA9IG51bGw7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm9yKGxldCBpPTA7aTw0O2krKykge1xyXG4gICAgICAgICAgICAgICAgYmFyY29kZSA9IHRoaXMuY29weVJlY3RhbmdsZSh0aGlzLm1fdGFyZ2V0TWF0LCAzMDAsIDMuNiwgMy42LCAyLjIsIDAuNCwgMC4wLCAzLjYpOyAvLyBib3R0b20gYmFyY29kZVxyXG4gICAgICAgICAgICAgICAgY3ZbXCJ0aHJlc2hvbGRcIl0oYmFyY29kZSwgYmFyY29kZSwgMTEyLCAyNTUsIGN2W1wiVEhSRVNIX0JJTkFSWVwiXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1fcEhpZGRlbk1ldGEud2lkdGggPSBiYXJjb2RlLmNvbHM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1fcEhpZGRlbk1ldGEuaGVpZ2h0ID0gYmFyY29kZS5yb3dzO1xyXG4gICAgICAgICAgICAgICAgY3ZbXCJpbXNob3dcIl0odGhpcy5tX3BIaWRkZW5NZXRhLCBiYXJjb2RlKTtcclxuICAgICAgICAgICAgICAgIGJhcmNvZGVbXCJkZWxldGVcIl0oKTtcclxuICAgICAgICAgICAgICAgIGJhcmNvZGUgPSBudWxsO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICBjb25zdCBsdW1pbmFuY2VTb3VyY2UgPSBuZXcgd2luZG93W1wiWlhpbmdcIl1bXCJIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZVwiXSh0aGlzLm1fcEhpZGRlbk1ldGEpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaHlicmlkQmluYXJpemVyID0gbmV3IHdpbmRvd1tcIlpYaW5nXCJdW1wiSHlicmlkQmluYXJpemVyXCJdKGx1bWluYW5jZVNvdXJjZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiaW5hcnlCaXRtYXAgPSBuZXcgd2luZG93W1wiWlhpbmdcIl1bXCJCaW5hcnlCaXRtYXBcIl0oaHlicmlkQmluYXJpemVyKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLm1fY29kZVJlYWRlcltcImRlY29kZUJpdG1hcFwiXShiaW5hcnlCaXRtYXApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVjb2RlUGFwZXJTcGVjKHJlc3VsdC50ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tX2lzRm91bmRTcGVjQmFyY29kZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB3aW5kb3dbXCJPWlJlY29nbml0aW9uUGFja1wiXS50cmFjZShlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMucm90YXRlTGVmdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdCkgcmVzdWx0ID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKGJhcmNvZGUpIHtcclxuICAgICAgICAgICAgICAgIGJhcmNvZGVbXCJkZWxldGVcIl0oKTtcclxuICAgICAgICAgICAgICAgIGJhcmNvZGUgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgX3RoaXMucm90YXRlTGVmdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGxldCB0bXAgPSBbXTtcclxuICAgICAgICBmb3IobGV0IGk9MDtpPHRoaXMubV9yZWN0YW5nbGUubGVuZ3RoO2krKykge1xyXG4gICAgICAgICAgICB0bXAucHVzaCh0aGlzLm1fcmVjdGFuZ2xlW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yKGxldCBpPTE7aTx0aGlzLm1fcmVjdGFuZ2xlLmxlbmd0aDtpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5tX3JlY3RhbmdsZVtpXSA9IHRtcFtpIC0gMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubV9yZWN0YW5nbGVbMF0gPSB0bXBbdGhpcy5tX3JlY3RhbmdsZS5sZW5ndGggLSAxXTtcclxuICAgIH07XHJcblxyXG4gICAgX3RoaXMuZGVjb2RlUGFwZXJTcGVjID0gZnVuY3Rpb24oc3RyTWV0YSkge1xyXG4gICAgICAgIGNvbnN0IGxlbiA9IHN0ck1ldGEuY2hhckF0KDApO1xyXG4gICAgICAgIGNvbnN0IG11bHRpcGx5ID0gc3RyTWV0YS5jaGFyQXQoMSk7XHJcbiAgICAgICAgY29uc3QgYmFyY29kZUxlbmd0aCA9IHN0ck1ldGEubGVuZ3RoO1xyXG5cclxuICAgICAgICBpZiAoYmFyY29kZUxlbmd0aCA8PSAyKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKGJhcmNvZGVMZW5ndGggIT0gMiArIGxlbiAqIDIpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgY29uc3QgcGFwZXJXaWR0aCA9IHN0ck1ldGEuc3Vic3RyKDIsIGxlbikgKiBtdWx0aXBseSAvIDEwLjA7XHJcbiAgICAgICAgY29uc3QgYXJlYVdpZHRoID0gc3RyTWV0YS5zdWJzdHIoMiArIHBhcnNlSW50KGxlbiksIGxlbikgKiBtdWx0aXBseSAvIDEwLjA7XHJcblxyXG4gICAgICAgIHRoaXMubV9zcGVjQmFyY29kZVtcInBhcGVyV2lkdGhcIl0gPSBwYXBlcldpZHRoO1xyXG4gICAgICAgIHRoaXMubV9zcGVjQmFyY29kZVtcImFyZWFXaWR0aFwiXSA9IGFyZWFXaWR0aDtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcblxyXG4gICAgX3RoaXMuY20ycHggPSBmdW5jdGlvbihkcGksIGNtKSB7XHJcbiAgICAgICAgcmV0dXJuIGNtIC8gMi41NCAqIGRwaTtcclxuICAgIH07XHJcblxyXG4gICAgX3RoaXMuY29weVJlY3RhbmdsZSA9IGZ1bmN0aW9uKGltYWdlLCBkcGksIHRvdGFsU2l6ZVcsIHRvdGFsU2l6ZUgsIGNhcHR1cmVTaXplVywgY2FwdHVyZVNpemVILCBvZmZzZXRYID0gMCwgb2Zmc2V0WSA9IDApIHtcclxuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuY20ycHgoZHBpLCBjYXB0dXJlU2l6ZVcpO1xyXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuY20ycHgoZHBpLCBjYXB0dXJlU2l6ZUgpO1xyXG5cclxuICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IGN2W1wiTWF0XCJdW1wiemVyb3NcIl0od2lkdGgsIGhlaWdodCwgY3ZbXCJDVl84VUMzXCJdKTtcclxuICAgICAgICBjb25zdCBtYXJnaW5MID0gdGhpcy5jbTJweChkcGksICh0b3RhbFNpemVXIC0gY2FwdHVyZVNpemVXICsgb2Zmc2V0WCkgLyAyLjApO1xyXG4gICAgICAgIGNvbnN0IG1hcmdpblQgPSB0aGlzLmNtMnB4KGRwaSwgKHRvdGFsU2l6ZUggLSBjYXB0dXJlU2l6ZUggKyBvZmZzZXRZKSAvIDIuMCk7XHJcbiAgICAgICAgY29uc3QgbWFyZ2luUiA9IHRoaXMuY20ycHgoZHBpLCAodG90YWxTaXplVyAtIGNhcHR1cmVTaXplVyAtIG9mZnNldFgpIC8gMi4wKTtcclxuICAgICAgICBjb25zdCBtYXJnaW5CID0gdGhpcy5jbTJweChkcGksICh0b3RhbFNpemVIIC0gY2FwdHVyZVNpemVIIC0gb2Zmc2V0WSkgLyAyLjApO1xyXG5cclxuICAgICAgICBsZXQgc3JjUXVhZCA9IG51bGw7XHJcbiAgICAgICAgbGV0IGRzdFF1YWQgPSBudWxsO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHNyY1F1YWQgPSBjdltcIm1hdEZyb21BcnJheVwiXSg0LCAxLCBjdltcIkNWXzMyRkMyXCJdLCBbIC8vIGNyb3DtlaAg7JiB7JetXHJcbiAgICAgICAgICAgICAgICB0aGlzLm1fcmVjdGFuZ2xlWzBdLngsIHRoaXMubV9yZWN0YW5nbGVbMF0ueSwgXHJcbiAgICAgICAgICAgICAgICB0aGlzLm1fcmVjdGFuZ2xlWzFdLngsIHRoaXMubV9yZWN0YW5nbGVbMV0ueSxcclxuICAgICAgICAgICAgICAgIHRoaXMubV9yZWN0YW5nbGVbM10ueCwgdGhpcy5tX3JlY3RhbmdsZVszXS55LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5tX3JlY3RhbmdsZVsyXS54LCB0aGlzLm1fcmVjdGFuZ2xlWzJdLnlcclxuICAgICAgICAgICAgXSk7XHJcbiAgICBcclxuICAgICAgICAgICAgZHN0UXVhZCA9IGN2W1wibWF0RnJvbUFycmF5XCJdKDQsIDEsIGN2W1wiQ1ZfMzJGQzJcIl0sIFsgLy8gZHNpemUgY3JvcCDqsrDqs7zrrLwg7YGs6riwXHJcbiAgICAgICAgICAgICAgICAwICAtIG1hcmdpbkwsIDAgLSBtYXJnaW5ULCBcclxuICAgICAgICAgICAgICAgIHdpZHRoICArIG1hcmdpblIsIDAgLSBtYXJnaW5ULFxyXG4gICAgICAgICAgICAgICAgMCAtIG1hcmdpbkwsIGhlaWdodCArIG1hcmdpbkIsXHJcbiAgICAgICAgICAgICAgICB3aWR0aCArIG1hcmdpblIsIGhlaWdodCArIG1hcmdpbkJcclxuICAgICAgICAgICAgXSk7XHJcbiAgICBcclxuICAgICAgICAgICAgY29uc3Qgd2FycE1hdGl4ID0gY3ZbXCJnZXRQZXJzcGVjdGl2ZVRyYW5zZm9ybVwiXShzcmNRdWFkLCBkc3RRdWFkKTtcclxuICAgICAgICAgICAgY3ZbXCJ3YXJwUGVyc3BlY3RpdmVcIl0oaW1hZ2UsIHJlc3VsdCwgd2FycE1hdGl4LCBuZXcgY3ZbXCJTaXplXCJdKHdpZHRoLCBoZWlnaHQpKTtcclxuICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICBzcmNRdWFkW1wiZGVsZXRlXCJdKCk7XHJcbiAgICAgICAgICAgIHNyY1F1YWQgPSBudWxsO1xyXG4gICAgICAgICAgICBkc3RRdWFkW1wiZGVsZXRlXCJdKCk7XHJcbiAgICAgICAgICAgIGRzdFF1YWQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcblxyXG4gICAgX3RoaXMuY2FwdHVyZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm1faXNGb3VuZFBhdHRlcm4gJiYgdGhpcy5tX2lzRm91bmRSZWN0YW5nbGUgJiYgdGhpcy5tX2lzRm91bmRTcGVjQmFyY29kZSkge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHRTaXplID0gdGhpcy5tX3NwZWNCYXJjb2RlW1wiYXJlYVdpZHRoXCJdO1xyXG4gICAgICAgICAgICBjb25zdCBhcmVhU2l6ZSA9IHRoaXMubV9zcGVjQmFyY29kZVtcInBhcGVyV2lkdGhcIl07XHJcbiAgICAgICAgICAgIHRoaXMubV9yZXN1bHRNYXQgPSB0aGlzLmNvcHlSZWN0YW5nbGUodGhpcy5tX3RhcmdldE1hdCwgdGhpcy5tX25EUEksIGFyZWFTaXplLCBhcmVhU2l6ZSwgcmVzdWx0U2l6ZSwgcmVzdWx0U2l6ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgIH07XHJcblxyXG4gICBfdGhpcy5nZXRSZXN1bHQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgIHJldHVybiB0aGlzLm1fcmVzdWx0TWF0O1xyXG4gICB9O1xyXG5cclxuICAgX3RoaXMuZ2V0U3BlY0JhcmNvZGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgIHJldHVybiB0aGlzLm1fc3BlY0JhcmNvZGU7XHJcbiAgIH07XHJcblxyXG4gICAgX3RoaXMuSXNGb3VuZFBhdHRlcm4gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tX2lzRm91bmRQYXR0ZXJuO1xyXG4gICAgfTtcclxuXHJcbiAgICBfdGhpcy5Jc0ZvdW5kUmVjdGFuZ2xlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubV9pc0ZvdW5kUmVjdGFuZ2xlO1xyXG4gICAgfTtcclxuXHJcbiAgICBfdGhpcy5Jc0ZvdW5kU3BlY0JhcmNvZGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tX2lzRm91bmRTcGVjQmFyY29kZTtcclxuICAgIH07XHJcbn07XHJcblxyXG5PWlNlYWxSZWNvZ25pemVyLk5PTkUgPSAwO1xyXG5PWlNlYWxSZWNvZ25pemVyLkJMQUNLX0FORF9XSElURSA9IDE7XHJcbk9aU2VhbFJlY29nbml6ZXIuQkxBQ0tfQU5EX0JMQU5LID0gMjtcclxuT1pTZWFsUmVjb2duaXplci5HUkFZU0NBTEUgPSAzO1xyXG5PWlNlYWxSZWNvZ25pemVyLlJFRF9BTkRfV0hJVEUgPSA0O1xyXG5PWlNlYWxSZWNvZ25pemVyLlJFRF9BTkRfQkxBTksgPSA1O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/OZSealRecognizer.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	__webpack_require__("./src/OZCardPreview.js");
/******/ 	__webpack_require__("./src/OZCardRecognizer.js");
/******/ 	__webpack_require__("./src/OZRecognitionPack.js");
/******/ 	__webpack_require__("./src/OZSealPreview.js");
/******/ 	__webpack_require__("./src/OZSealRecognizer.js");
/******/ 	var __webpack_exports__ = __webpack_require__("./src/OZSealRecognition.js");
/******/ 	OZSealRecognition = __webpack_exports__;
/******/ 	
/******/ })()
;